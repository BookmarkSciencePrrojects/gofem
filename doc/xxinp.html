<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Gofem &ndash; package inp</title>
<link type="text/css" rel="stylesheet" href="static/style.css">
<script type="text/javascript" src="static/godocs.js"></script>
<style type="text/css"></style>
</head>
<body>
<div id="page"><h1>Gofem &ndash; <b>inp</b> &ndash; input data structures. simulation, materials, meshes</h1>
<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script type='text/javascript'>
	document.ANALYSIS_DATA = ;
	document.CALLGRAPH = ;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/cpmech/gofem/inp"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
package inp implements the input data read from a (.sim) JSON file
</p>

			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
			
				
				<dd><a href="#FlushLog">func FlushLog()</a></dd>
			
				
				<dd><a href="#InitLogFile">func InitLogFile(dirout, fnamekey string) (err error)</a></dd>
			
				
				<dd><a href="#LogErr">func LogErr(err error, msg string) (stop bool)</a></dd>
			
				
				<dd><a href="#LogErrCond">func LogErrCond(condition bool, msg string, prm ...interface{}) (stop bool)</a></dd>
			
				
				<dd><a href="#MatfileNew2Old">func MatfileNew2Old(dirout string, fnold, fnnew string, convertsymbols bool)</a></dd>
			
				
				<dd><a href="#MatfileOld2New">func MatfileOld2New(dirout string, fnnew, fnold string, convertsymbols bool)</a></dd>
			
			
				
				<dd><a href="#Cell">type Cell</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Cell.String">func (o *Cell) String() string</a></dd>
				
			
				
				<dd><a href="#CellFaceId">type CellFaceId</a></dd>
				
				
			
				
				<dd><a href="#CellSeamId">type CellSeamId</a></dd>
				
				
			
				
				<dd><a href="#Data">type Data</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Data.PostProcess">func (o *Data) PostProcess(dir, fn string, erasefiles bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Data.SetDefault">func (o *Data) SetDefault()</a></dd>
				
			
				
				<dd><a href="#EleCond">type EleCond</a></dd>
				
				
			
				
				<dd><a href="#ElemData">type ElemData</a></dd>
				
				
			
				
				<dd><a href="#FaceBc">type FaceBc</a></dd>
				
				
			
				
				<dd><a href="#FuncData">type FuncData</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FuncData.String">func (o FuncData) String() string</a></dd>
				
			
				
				<dd><a href="#FuncsData">type FuncsData</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FuncsData.Get">func (o FuncsData) Get(name string) fun.Func</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FuncsData.String">func (o FuncsData) String() string</a></dd>
				
			
				
				<dd><a href="#HydroStData">type HydroStData</a></dd>
				
				
			
				
				<dd><a href="#LinSolData">type LinSolData</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LinSolData.PostProcess">func (o *LinSolData) PostProcess()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LinSolData.SetDefault">func (o *LinSolData) SetDefault()</a></dd>
				
			
				
				<dd><a href="#MatDb">type MatDb</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ReadMat">func ReadMat(dir, fn string) *MatDb</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MatDb.Get">func (o MatDb) Get(name string) *Material</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MatDb.GroupGet">func (o MatDb) GroupGet(matname, key string) *Material</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MatDb.GroupGet3">func (o MatDb) GroupGet3(matname, key1, key2, key3 string) (m1, m2, m3 *Material, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MatDb.String">func (o MatDb) String() string</a></dd>
				
			
				
				<dd><a href="#Material">type Material</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Material.String">func (o *Material) String() string</a></dd>
				
			
				
				<dd><a href="#MatsData">type MatsData</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MatsData.String">func (o MatsData) String() string</a></dd>
				
			
				
				<dd><a href="#Mesh">type Mesh</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ReadMsh">func ReadMsh(dir, fn string) *Mesh</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.String">func (o Mesh) String() string</a></dd>
				
			
				
				<dd><a href="#NodeBc">type NodeBc</a></dd>
				
				
			
				
				<dd><a href="#Region">type Region</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Region.Etag2data">func (d *Region) Etag2data(etag int) *ElemData</a></dd>
				
			
				
				<dd><a href="#SeamBc">type SeamBc</a></dd>
				
				
			
				
				<dd><a href="#Simulation">type Simulation</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ReadSim">func ReadSim(dir, fn string, erasefiles bool) *Simulation</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Simulation.GetInfo">func (o *Simulation) GetInfo(w io.Writer) (err error)</a></dd>
				
			
				
				<dd><a href="#SolverData">type SolverData</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SolverData.PostProcess">func (o *SolverData) PostProcess()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SolverData.SetDefault">func (o *SolverData) SetDefault()</a></dd>
				
			
				
				<dd><a href="#Stage">type Stage</a></dd>
				
				
			
				
				<dd><a href="#TimeControl">type TimeControl</a></dd>
				
				
			
				
				<dd><a href="#Vert">type Vert</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Vert.String">func (o *Vert) String() string</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/github.com/cpmech/gofem/inp/auxiliary.go">auxiliary.go</a>
			
				<a href="/src/github.com/cpmech/gofem/inp/func.go">func.go</a>
			
				<a href="/src/github.com/cpmech/gofem/inp/logging.go">logging.go</a>
			
				<a href="/src/github.com/cpmech/gofem/inp/mat.go">mat.go</a>
			
				<a href="/src/github.com/cpmech/gofem/inp/msh.go">msh.go</a>
			
				<a href="/src/github.com/cpmech/gofem/inp/sim.go">sim.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		<div id="pkg-callgraph" class="toggle" style="display: none">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
		</div> <!-- .expanded -->
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
			<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls&mdash;perhaps dynamically.
			</p>
			<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
			<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
			<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
			<!-- Zero means show all package entry points. -->
			<ul style="margin-left: 0.5in" id="callgraph-0" class="treeview"></ul>
		</div>
		</div> <!-- #pkg-callgraph -->

		
			<h2 id="pkg-constants">Constants</h2>
			
				<pre>const <span id="Ztol">Ztol</span> = 1e-7</pre>
				<p>
constants
</p>

			
		
		
		
			
			
			<h2 id="FlushLog">func <a href="/src/target/logging.go?s=722:737#L27">FlushLog</a></h2>
			<pre>func FlushLog()</pre>
			<p>
FlusLog saves log (flushes to disk)
</p>

			
			

		
			
			
			<h2 id="InitLogFile">func <a href="/src/target/logging.go?s=377:430#L9">InitLogFile</a></h2>
			<pre>func InitLogFile(dirout, fnamekey <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
InitLogFile initialises logger
</p>

			
			

		
			
			
			<h2 id="LogErr">func <a href="/src/target/logging.go?s=802:848#L32">LogErr</a></h2>
			<pre>func LogErr(err <a href="/pkg/builtin/#error">error</a>, msg <a href="/pkg/builtin/#string">string</a>) (stop <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
LogErr logs error and returs stop flag
</p>

			
			

		
			
			
			<h2 id="LogErrCond">func <a href="/src/target/logging.go?s=1050:1125#L42">LogErrCond</a></h2>
			<pre>func LogErrCond(condition <a href="/pkg/builtin/#bool">bool</a>, msg <a href="/pkg/builtin/#string">string</a>, prm ...interface{}) (stop <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
LogErr logs error using condition (==true) to stop and returs stop flag
</p>

			
			

		
			
			
			<h2 id="MatfileNew2Old">func <a href="/src/target/mat.go?s=5093:5169#L197">MatfileNew2Old</a></h2>
			<pre>func MatfileNew2Old(dirout <a href="/pkg/builtin/#string">string</a>, fnold, fnnew <a href="/pkg/builtin/#string">string</a>, convertsymbols <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
MatfileNew2Old converts a new mat file to the old mat file format
</p>
<pre>convertsymbols -- convert back symbols with Greek characters to UTF-8
</pre>

			
			

		
			
			
			<h2 id="MatfileOld2New">func <a href="/src/target/mat.go?s=3619:3695#L129">MatfileOld2New</a></h2>
			<pre>func MatfileOld2New(dirout <a href="/pkg/builtin/#string">string</a>, fnnew, fnold <a href="/pkg/builtin/#string">string</a>, convertsymbols <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
MatfileOld2New converts an old mat file to new mat file format
</p>
<pre>convertsymbols -- convert symbols with Greek characters to ANSI
</pre>

			
			

		
		
			
			
			<h2 id="Cell">type <a href="/src/target/msh.go?s=504:1046#L19">Cell</a></h2>
			<pre>type Cell struct {
    Id     <a href="/pkg/builtin/#int">int</a>    <span class="comment">// id</span>
    Tag    <a href="/pkg/builtin/#int">int</a>    <span class="comment">// tag</span>
    Geo    <a href="/pkg/builtin/#int">int</a>    <span class="comment">// geometry type (gemlab code)</span>
    Type   <a href="/pkg/builtin/#string">string</a> <span class="comment">// geometry type (string)</span>
    Part   <a href="/pkg/builtin/#int">int</a>    <span class="comment">// partition id</span>
    Verts  []<a href="/pkg/builtin/#int">int</a>  <span class="comment">// vertices</span>
    FTags  []<a href="/pkg/builtin/#int">int</a>  <span class="comment">// edge (2D) or face (3D) tags</span>
    STags  []<a href="/pkg/builtin/#int">int</a>  <span class="comment">// seam tags (for 3D only; it is actually a 3D edge tag)</span>
    JlinId <a href="/pkg/builtin/#int">int</a>    <span class="comment">// joint line id</span>
    JsldId <a href="/pkg/builtin/#int">int</a>    <span class="comment">// joint solid id</span>

    <span class="comment">// specific problems data</span>
    SeepVerts map[<a href="/pkg/builtin/#int">int</a>]<a href="/pkg/builtin/#bool">bool</a> <span class="comment">// local vertices ids of vertices on seepage faces</span>

    <span class="comment">// derived</span>
    Shp *<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Shape">Shape</a> <span class="comment">// shape structure</span>
}</pre>
			<p>
Cell holds cell data
</p>


			

			

			
			
			

			

			
				
				<h3 id="Cell.String">func (*Cell) <a href="/src/target/msh.go?s=5291:5321#L211">String</a></h3>
				<pre>func (o *<a href="#Cell">Cell</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
String returns a JSON representation of *Cell
</p>

				
				
				
			
		
			
			
			<h2 id="CellFaceId">type <a href="/src/target/msh.go?s=1072:1139#L39">CellFaceId</a></h2>
			<pre>type CellFaceId struct {
    C   *<a href="#Cell">Cell</a> <span class="comment">// cell</span>
    Fid <a href="/pkg/builtin/#int">int</a>   <span class="comment">// face id</span>
}</pre>
			<p>
CellFaceId structure
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="CellSeamId">type <a href="/src/target/msh.go?s=1165:1232#L45">CellSeamId</a></h2>
			<pre>type CellSeamId struct {
    C   *<a href="#Cell">Cell</a> <span class="comment">// cell</span>
    Sid <a href="/pkg/builtin/#int">int</a>   <span class="comment">// seam id</span>
}</pre>
			<p>
CellSeamId structure
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Data">type <a href="/src/target/sim.go?s=464:1412#L12">Data</a></h2>
			<pre>type Data struct {

    <span class="comment">// global information</span>
    Desc    <a href="/pkg/builtin/#string">string</a> `json:&#34;desc&#34;`    <span class="comment">// description of simulation</span>
    Matfile <a href="/pkg/builtin/#string">string</a> `json:&#34;matfile&#34;` <span class="comment">// materials file path</span>
    DirOut  <a href="/pkg/builtin/#string">string</a> `json:&#34;dirout&#34;`  <span class="comment">// directory for output; e.g. /tmp/gofem</span>
    Encoder <a href="/pkg/builtin/#string">string</a> `json:&#34;encoder&#34;` <span class="comment">// encoder name; e.g. &#34;gob&#34; &#34;json&#34; &#34;xml&#34;</span>

    <span class="comment">// problem definition and options</span>
    Steady  <a href="/pkg/builtin/#bool">bool</a> `json:&#34;steady&#34;`  <span class="comment">// steady simulation</span>
    Pstress <a href="/pkg/builtin/#bool">bool</a> `json:&#34;pstress&#34;` <span class="comment">// plane-stress</span>
    Axisym  <a href="/pkg/builtin/#bool">bool</a> `json:&#34;axisym&#34;`  <span class="comment">// axisymmetric</span>

    <span class="comment">// options</span>
    React <a href="/pkg/builtin/#bool">bool</a> `json:&#34;react&#34;` <span class="comment">// indicates whether or not reaction forces must be computed</span>
    ShowR <a href="/pkg/builtin/#bool">bool</a> `json:&#34;showr&#34;` <span class="comment">// show residual</span>
    NoDiv <a href="/pkg/builtin/#bool">bool</a> `json:&#34;nodiv&#34;` <span class="comment">// disregard divergence control in both fb or Lδu</span>
    CteTg <a href="/pkg/builtin/#bool">bool</a> `json:&#34;ctetg&#34;` <span class="comment">// use constant tangent (modified Newton) during iterations</span>

    <span class="comment">// derived</span>
    FnameDir <a href="/pkg/builtin/#string">string</a> <span class="comment">// directory where .sim filename is locatd</span>
    FnameKey <a href="/pkg/builtin/#string">string</a> <span class="comment">// simulation filename key; e.g. mysim01.sim =&gt; mysim01</span>
}</pre>
			<p>
Data holds global data for simulations
</p>


			

			

			
			
			

			

			
				
				<h3 id="Data.PostProcess">func (*Data) <a href="/src/target/sim.go?s=1570:1629#L42">PostProcess</a></h3>
				<pre>func (o *<a href="#Data">Data</a>) PostProcess(dir, fn <a href="/pkg/builtin/#string">string</a>, erasefiles <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
PostProcess performs a post-processing of the just read json file
</p>

				
				
				
			
				
				<h3 id="Data.SetDefault">func (*Data) <a href="/src/target/sim.go?s=1449:1476#L37">SetDefault</a></h3>
				<pre>func (o *<a href="#Data">Data</a>) SetDefault()</pre>
				<p>
SetDefault sets defaults values
</p>

				
				
				
			
		
			
			
			<h2 id="EleCond">type <a href="/src/target/sim.go?s=6102:6421#L187">EleCond</a></h2>
			<pre>type EleCond struct {
    Tag   <a href="/pkg/builtin/#int">int</a>      `json:&#34;tag&#34;`   <span class="comment">// tag of cell/element</span>
    Keys  []<a href="/pkg/builtin/#string">string</a> `json:&#34;keys&#34;`  <span class="comment">// key indicating type of condition. ex: &#34;g&#34; (gravity), &#34;qn&#34; for beams, etc.</span>
    Funcs []<a href="/pkg/builtin/#string">string</a> `json:&#34;funcs&#34;` <span class="comment">// name of function. ex: grav, none</span>
    Extra <a href="/pkg/builtin/#string">string</a>   `json:&#34;extra&#34;` <span class="comment">// extra information. ex: &#39;!λl:10&#39;</span>
}</pre>
			<p>
EleCond holds element condition
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="ElemData">type <a href="/src/target/sim.go?s=4208:4566#L142">ElemData</a></h2>
			<pre>type ElemData struct {
    Tag   <a href="/pkg/builtin/#int">int</a>    `json:&#34;tag&#34;`   <span class="comment">// tag of element</span>
    Mat   <a href="/pkg/builtin/#string">string</a> `json:&#34;mat&#34;`   <span class="comment">// material name</span>
    Type  <a href="/pkg/builtin/#string">string</a> `json:&#34;type&#34;`  <span class="comment">// type of element. ex: u, p, up, rod, beam, rjoint</span>
    Extra <a href="/pkg/builtin/#string">string</a> `json:&#34;extra&#34;` <span class="comment">// extra flags (in keycode format). ex: &#34;!thick:0.2 !nip:4&#34;</span>
    Inact <a href="/pkg/builtin/#bool">bool</a>   `json:&#34;inact&#34;` <span class="comment">// whether element starts inactive or not</span>
}</pre>
			<p>
ElemData holds element data
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="FaceBc">type <a href="/src/target/sim.go?s=5012:5333#L163">FaceBc</a></h2>
			<pre>type FaceBc struct {
    Tag   <a href="/pkg/builtin/#int">int</a>      `json:&#34;tag&#34;`   <span class="comment">// tag of face</span>
    Keys  []<a href="/pkg/builtin/#string">string</a> `json:&#34;keys&#34;`  <span class="comment">// key indicating type of bcs. ex: qn, pw, ux, uy, uz, wwx, wwy, wwz</span>
    Funcs []<a href="/pkg/builtin/#string">string</a> `json:&#34;funcs&#34;` <span class="comment">// name of function. ex: zero, load, myfunction1, etc.</span>
    Extra <a href="/pkg/builtin/#string">string</a>   `json:&#34;extra&#34;` <span class="comment">// extra information. ex: &#39;!λl:10&#39;</span>
}</pre>
			<p>
FaceBc holds face boundary condition
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="FuncData">type <a href="/src/target/func.go?s=298:512#L3">FuncData</a></h2>
			<pre>type FuncData struct {
    Name <a href="/pkg/builtin/#string">string</a>   `json:&#34;name&#34;` <span class="comment">// name of function. ex: zero, load, myfunction1, etc.</span>
    Type <a href="/pkg/builtin/#string">string</a>   `json:&#34;type&#34;` <span class="comment">// type of function. ex: cte, rmp</span>
    Prms <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Prms">Prms</a> `json:&#34;prms&#34;` <span class="comment">// parameters</span>
}</pre>
			<p>
FuncData holds function definition
</p>


			

			

			
			
			

			

			
				
				<h3 id="FuncData.String">func (FuncData) <a href="/src/target/func.go?s=931:964#L31">String</a></h3>
				<pre>func (o <a href="#FuncData">FuncData</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
String prints one function
</p>

				
				
				
			
		
			
			
			<h2 id="FuncsData">type <a href="/src/target/func.go?s=539:565#L10">FuncsData</a></h2>
			<pre>type FuncsData []*<a href="#FuncData">FuncData</a></pre>
			<p>
Funcs holds functions
</p>


			

			

			
			
			

			

			
				
				<h3 id="FuncsData.Get">func (FuncsData) <a href="/src/target/func.go?s=634:678#L14">Get</a></h3>
				<pre>func (o <a href="#FuncsData">FuncsData</a>) Get(name <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a></pre>
				<p>
Get returns function by name
</p>
<pre>Note: returns nil if not found
</pre>

				
				
				
			
				
				<h3 id="FuncsData.String">func (FuncsData) <a href="/src/target/func.go?s=1156:1190#L38">String</a></h3>
				<pre>func (o <a href="#FuncsData">FuncsData</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
String prints functions
</p>

				
				
				
			
		
			
			
			<h2 id="HydroStData">type <a href="/src/target/sim.go?s=6993:7266#L208">HydroStData</a></h2>
			<pre>type HydroStData struct {
    GamW   <a href="/pkg/builtin/#float64">float64</a> `json:&#34;gamw&#34;`   <span class="comment">// unit weight of water to use in HydroSt</span>
    Zwater <a href="/pkg/builtin/#float64">float64</a> `json:&#34;zwater&#34;` <span class="comment">// water elevation to set ponding or unsaturated condition</span>
    Unsat  <a href="/pkg/builtin/#bool">bool</a>    `json:&#34;unsat&#34;`  <span class="comment">// consider unsaturated state with zwater &lt; zmax</span>
}</pre>
			<p>
HydroStData holds data to set hydrostatic initial state
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="LinSolData">type <a href="/src/target/sim.go?s=2046:2417#L59">LinSolData</a></h2>
			<pre>type LinSolData struct {
    Name      <a href="/pkg/builtin/#string">string</a> `json:&#34;name&#34;`      <span class="comment">// &#34;mumps&#34; or &#34;umfpack&#34;</span>
    Symmetric <a href="/pkg/builtin/#bool">bool</a>   `json:&#34;symmetric&#34;` <span class="comment">// use symmetric solver</span>
    Verbose   <a href="/pkg/builtin/#bool">bool</a>   `json:&#34;verbose&#34;`   <span class="comment">// verbose?</span>
    Timing    <a href="/pkg/builtin/#bool">bool</a>   `json:&#34;timing&#34;`    <span class="comment">// show timing statistics</span>
    Ordering  <a href="/pkg/builtin/#string">string</a> `json:&#34;ordering&#34;`  <span class="comment">// ordering scheme</span>
    Scaling   <a href="/pkg/builtin/#string">string</a> `json:&#34;scaling&#34;`   <span class="comment">// scaling scheme</span>
}</pre>
			<p>
LinSolData holds data for linear solvers
</p>


			

			

			
			
			

			

			
				
				<h3 id="LinSolData.PostProcess">func (*LinSolData) <a href="/src/target/sim.go?s=2622:2656#L76">PostProcess</a></h3>
				<pre>func (o *<a href="#LinSolData">LinSolData</a>) PostProcess()</pre>
				<p>
PostProcess performs a post-processing of the just read json file
</p>

				
				
				
			
				
				<h3 id="LinSolData.SetDefault">func (*LinSolData) <a href="/src/target/sim.go?s=2454:2487#L69">SetDefault</a></h3>
				<pre>func (o *<a href="#LinSolData">LinSolData</a>) SetDefault()</pre>
				<p>
SetDefault sets defaults values
</p>

				
				
				
			
		
			
			
			<h2 id="MatDb">type <a href="/src/target/mat.go?s=798:933#L19">MatDb</a></h2>
			<pre>type MatDb struct {
    Functions <a href="#FuncsData">FuncsData</a> `json:&#34;functions&#34;` <span class="comment">// all functions</span>
    Materials <a href="#MatsData">MatsData</a>  `json:&#34;materials&#34;` <span class="comment">// all materials</span>
}</pre>
			<p>
MatDb implements a database of materials
</p>


			

			

			
			
			

			
				
				<h3 id="ReadMat">func <a href="/src/target/mat.go?s=1025:1060#L26">ReadMat</a></h3>
				<pre>func ReadMat(dir, fn <a href="/pkg/builtin/#string">string</a>) *<a href="#MatDb">MatDb</a></pre>
				<p>
ReadMat reads all materials data from a .mat JSON file
</p>
<pre>Note: returns nil on errors
</pre>

				
				
			

			
				
				<h3 id="MatDb.Get">func (MatDb) <a href="/src/target/mat.go?s=1531:1572#L49">Get</a></h3>
				<pre>func (o <a href="#MatDb">MatDb</a>) Get(name <a href="/pkg/builtin/#string">string</a>) *<a href="#Material">Material</a></pre>
				<p>
Get returns a material
</p>
<pre>Note: returns nil if not found
</pre>

				
				
				
			
				
				<h3 id="MatDb.GroupGet">func (MatDb) <a href="/src/target/mat.go?s=1733:1787#L60">GroupGet</a></h3>
				<pre>func (o <a href="#MatDb">MatDb</a>) GroupGet(matname, key <a href="/pkg/builtin/#string">string</a>) *<a href="#Material">Material</a></pre>
				<p>
GroupGet parses group data
</p>
<pre>Note: returns nil on failure
</pre>

				
				
				
			
				
				<h3 id="MatDb.GroupGet3">func (MatDb) <a href="/src/target/mat.go?s=1984:2076#L72">GroupGet3</a></h3>
				<pre>func (o <a href="#MatDb">MatDb</a>) GroupGet3(matname, key1, key2, key3 <a href="/pkg/builtin/#string">string</a>) (m1, m2, m3 *<a href="#Material">Material</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
GroupGet3 parses group data
</p>

				
				
				
			
				
				<h3 id="MatDb.String">func (MatDb) <a href="/src/target/mat.go?s=3391:3421#L123">String</a></h3>
				<pre>func (o <a href="#MatDb">MatDb</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
String outputs all materials
</p>

				
				
				
			
		
			
			
			<h2 id="Material">type <a href="/src/target/mat.go?s=334:701#L7">Material</a></h2>
			<pre>type Material struct {
    Name  <a href="/pkg/builtin/#string">string</a>   `json:&#34;name&#34;`  <span class="comment">// name of material</span>
    Desc  <a href="/pkg/builtin/#string">string</a>   `json:&#34;desc&#34;`  <span class="comment">// description of material</span>
    Model <a href="/pkg/builtin/#string">string</a>   `json:&#34;model&#34;` <span class="comment">// name of model ex: &#39;dp&#39;, &#39;vm&#39;, &#39;elast&#39;, etc.</span>
    Extra <a href="/pkg/builtin/#string">string</a>   `json:&#34;extra&#34;` <span class="comment">// extra information about this material</span>
    Prms  <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Prms">Prms</a> `json:&#34;prms&#34;`  <span class="comment">// prms holds all model parameters for this material</span>
}</pre>
			<p>
Material holds material data
</p>


			

			

			
			
			

			

			
				
				<h3 id="Material.String">func (*Material) <a href="/src/target/mat.go?s=2907:2941#L103">String</a></h3>
				<pre>func (o *<a href="#Material">Material</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
String prints one function
</p>

				
				
				
			
		
			
			
			<h2 id="MatsData">type <a href="/src/target/mat.go?s=727:752#L16">MatsData</a></h2>
			<pre>type MatsData []*<a href="#Material">Material</a></pre>
			<p>
Mats holds materials
</p>


			

			

			
			
			

			

			
				
				<h3 id="MatsData.String">func (MatsData) <a href="/src/target/mat.go?s=3186:3219#L110">String</a></h3>
				<pre>func (o <a href="#MatsData">MatsData</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
String prints materials
</p>

				
				
				
			
		
			
			
			<h2 id="Mesh">type <a href="/src/target/msh.go?s=1271:1970#L51">Mesh</a></h2>
			<pre>type Mesh struct {

    <span class="comment">// from JSON</span>
    Verts []*<a href="#Vert">Vert</a> <span class="comment">// vertices</span>
    Cells []*<a href="#Cell">Cell</a> <span class="comment">// cells</span>

    <span class="comment">// derived</span>
    Ndim       <a href="/pkg/builtin/#int">int</a>     <span class="comment">// space dimension</span>
    Xmin, Xmax <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// min and max x-coordinate</span>
    Ymin, Ymax <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// min and max x-coordinate</span>
    Zmin, Zmax <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// min and max x-coordinate</span>

    <span class="comment">// derived: maps</span>
    VertTag2verts map[<a href="/pkg/builtin/#int">int</a>][]*<a href="#Vert">Vert</a>      <span class="comment">// vertex tag =&gt; set of vertices</span>
    CellTag2cells map[<a href="/pkg/builtin/#int">int</a>][]*<a href="#Cell">Cell</a>      <span class="comment">// cell tag =&gt; set of cells</span>
    FaceTag2cells map[<a href="/pkg/builtin/#int">int</a>][]<a href="#CellFaceId">CellFaceId</a> <span class="comment">// face tag =&gt; set of cells</span>
    SeamTag2cells map[<a href="/pkg/builtin/#int">int</a>][]<a href="#CellSeamId">CellSeamId</a> <span class="comment">// seam tag =&gt; set of cells</span>
    Ctype2cells   map[<a href="/pkg/builtin/#string">string</a>][]*<a href="#Cell">Cell</a>   <span class="comment">// cell type =&gt; set of cells</span>
    Part2cells    map[<a href="/pkg/builtin/#int">int</a>][]*<a href="#Cell">Cell</a>      <span class="comment">// partition number =&gt; set of cells</span>
}</pre>
			<p>
Mesh holds a mesh for FE analyses
</p>


			

			

			
			
			

			
				
				<h3 id="ReadMsh">func <a href="/src/target/msh.go?s=2044:2078#L74">ReadMsh</a></h3>
				<pre>func ReadMsh(dir, fn <a href="/pkg/builtin/#string">string</a>) *<a href="#Mesh">Mesh</a></pre>
				<p>
ReadMsh reads a mesh for FE analyses
</p>
<pre>Note: returns nil on errors
</pre>

				
				
			

			
				
				<h3 id="Mesh.String">func (Mesh) <a href="/src/target/msh.go?s=5698:5727#L231">String</a></h3>
				<pre>func (o <a href="#Mesh">Mesh</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
String returns a JSON representation of *Mesh
</p>

				
				
				
			
		
			
			
			<h2 id="NodeBc">type <a href="/src/target/sim.go?s=5748:6065#L179">NodeBc</a></h2>
			<pre>type NodeBc struct {
    Tag   <a href="/pkg/builtin/#int">int</a>      `json:&#34;tag&#34;`   <span class="comment">// tag of node</span>
    Keys  []<a href="/pkg/builtin/#string">string</a> `json:&#34;keys&#34;`  <span class="comment">// key indicating type of bcs. ex: pw, ux, uy, uz, wwx, wwy, wwz</span>
    Funcs []<a href="/pkg/builtin/#string">string</a> `json:&#34;funcs&#34;` <span class="comment">// name of function. ex: zero, load, myfunction1, etc.</span>
    Extra <a href="/pkg/builtin/#string">string</a>   `json:&#34;extra&#34;` <span class="comment">// extra information. ex: &#39;!λl:10&#39;</span>
}</pre>
			<p>
NodeBc holds node boundary condition
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Region">type <a href="/src/target/sim.go?s=4596:4970#L151">Region</a></h2>
			<pre>type Region struct {

    <span class="comment">// input data</span>
    Desc      <a href="/pkg/builtin/#string">string</a>      `json:&#34;desc&#34;`      <span class="comment">// description of region. ex: ground, indenter, etc.</span>
    Mshfile   <a href="/pkg/builtin/#string">string</a>      `json:&#34;mshfile&#34;`   <span class="comment">// file path of file with mesh data</span>
    ElemsData []*<a href="#ElemData">ElemData</a> `json:&#34;elemsdata&#34;` <span class="comment">// list of elements data</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Region holds region data
</p>


			

			

			
			
			

			

			
				
				<h3 id="Region.Etag2data">func (*Region) <a href="/src/target/sim.go?s=11397:11443#L350">Etag2data</a></h3>
				<pre>func (d *<a href="#Region">Region</a>) Etag2data(etag <a href="/pkg/builtin/#int">int</a>) *<a href="#ElemData">ElemData</a></pre>
				<p>
Etag2data returns the ElemData corresponding to element tag
</p>
<pre>Note: returns nil if not found
</pre>

				
				
				
			
		
			
			
			<h2 id="SeamBc">type <a href="/src/target/sim.go?s=5385:5706#L171">SeamBc</a></h2>
			<pre>type SeamBc struct {
    Tag   <a href="/pkg/builtin/#int">int</a>      `json:&#34;tag&#34;`   <span class="comment">// tag of seam</span>
    Keys  []<a href="/pkg/builtin/#string">string</a> `json:&#34;keys&#34;`  <span class="comment">// key indicating type of bcs. ex: qn, pw, ux, uy, uz, wwx, wwy, wwz</span>
    Funcs []<a href="/pkg/builtin/#string">string</a> `json:&#34;funcs&#34;` <span class="comment">// name of function. ex: zero, load, myfunction1, etc.</span>
    Extra <a href="/pkg/builtin/#string">string</a>   `json:&#34;extra&#34;` <span class="comment">// extra information. ex: &#39;!λl:10&#39;</span>
}</pre>
			<p>
SeamBc holds seam (3D edge) boundary condition
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Simulation">type <a href="/src/target/sim.go?s=8370:8802#L239">Simulation</a></h2>
			<pre>type Simulation struct {
    Data      <a href="#Data">Data</a>       `json:&#34;data&#34;`      <span class="comment">// stores global simulation data</span>
    Functions <a href="#FuncsData">FuncsData</a>  `json:&#34;functions&#34;` <span class="comment">// stores all boundary condition functions</span>
    Regions   []*<a href="#Region">Region</a>  `json:&#34;regions&#34;`   <span class="comment">// stores all regions</span>
    LinSol    <a href="#LinSolData">LinSolData</a> `json:&#34;linsol&#34;`    <span class="comment">// linear solver data</span>
    Solver    <a href="#SolverData">SolverData</a> `json:&#34;solver&#34;`    <span class="comment">// FEM solver data</span>
    Stages    []*<a href="#Stage">Stage</a>   `json:&#34;stages&#34;`    <span class="comment">// stores all stages</span>
}</pre>
			<p>
Simulation holds all simulation data
</p>


			

			

			
			
			

			
				
				<h3 id="ReadSim">func <a href="/src/target/sim.go?s=8950:9007#L251">ReadSim</a></h3>
				<pre>func ReadSim(dir, fn <a href="/pkg/builtin/#string">string</a>, erasefiles <a href="/pkg/builtin/#bool">bool</a>) *<a href="#Simulation">Simulation</a></pre>
				<p>
ReadSim reads all simulation data from a .sim JSON file
</p>
<pre>Notes:  1) this function initialises log file
        2) returns nil on errors
</pre>

				
				
			

			
				
				<h3 id="Simulation.GetInfo">func (*Simulation) <a href="/src/target/sim.go?s=11570:11623#L359">GetInfo</a></h3>
				<pre>func (o *<a href="#Simulation">Simulation</a>) GetInfo(w <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Writer">Writer</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
GetInfo returns formatted information
</p>

				
				
				
			
		
			
			
			<h2 id="SolverData">type <a href="/src/target/sim.go?s=2795:3683#L87">SolverData</a></h2>
			<pre>type SolverData struct {

    <span class="comment">// constants</span>
    Eps <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// smallest number satisfying 1.0 + ϵ &gt; 1.0</span>

    <span class="comment">// nonlinear solver</span>
    NmaxIt <a href="/pkg/builtin/#int">int</a>     `json:&#34;nmaxit&#34;` <span class="comment">// number of max iterations</span>
    Atol   <a href="/pkg/builtin/#float64">float64</a> `json:&#34;atol&#34;`   <span class="comment">// absolute tolerance</span>
    Rtol   <a href="/pkg/builtin/#float64">float64</a> `json:&#34;rtol&#34;`   <span class="comment">// relative tolerance</span>
    FbTol  <a href="/pkg/builtin/#float64">float64</a> `json:&#34;fbtol&#34;`  <span class="comment">// tolerance for convergence on fb</span>
    FbMin  <a href="/pkg/builtin/#float64">float64</a> `json:&#34;fbmin&#34;`  <span class="comment">// minimum value of fb</span>

    <span class="comment">// transient analyses</span>
    DtMin <a href="/pkg/builtin/#float64">float64</a> `json:&#34;dtmin&#34;` <span class="comment">// minium value of Dt for transient (θ and Newmark / Dyn coefficients)</span>
    Theta <a href="/pkg/builtin/#float64">float64</a> `json:&#34;theta&#34;` <span class="comment">// θ-method</span>

    <span class="comment">// dynamics</span>
    Theta1 <a href="/pkg/builtin/#float64">float64</a> `json:&#34;theta1&#34;` <span class="comment">// Newmark&#39;s method parameter</span>
    Theta2 <a href="/pkg/builtin/#float64">float64</a> `json:&#34;theta2&#34;` <span class="comment">// Newmark&#39;s method parameter</span>
    HHT    <a href="/pkg/builtin/#bool">bool</a>    `json:&#34;hht&#34;`    <span class="comment">// use Hilber-Hughes-Taylor method</span>
    HHTalp <a href="/pkg/builtin/#float64">float64</a> `json:&#34;hhtalp&#34;` <span class="comment">// HHT α parameter</span>

    <span class="comment">// derived</span>
    Itol <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// iterations tolerance</span>
}</pre>
			<p>
SolverData holds FEM solver data
</p>


			

			

			
			
			

			

			
				
				<h3 id="SolverData.PostProcess">func (*SolverData) <a href="/src/target/sim.go?s=4074:4108#L137">PostProcess</a></h3>
				<pre>func (o *<a href="#SolverData">SolverData</a>) PostProcess()</pre>
				<p>
PostProcess performs a post-processing of the just read json file
</p>

				
				
				
			
				
				<h3 id="SolverData.SetDefault">func (*SolverData) <a href="/src/target/sim.go?s=3719:3752#L114">SetDefault</a></h3>
				<pre>func (o *<a href="#SolverData">SolverData</a>) SetDefault()</pre>
				<p>
SetDefault set defaults values
</p>

				
				
				
			
		
			
			
			<h2 id="Stage">type <a href="/src/target/sim.go?s=7294:8328#L215">Stage</a></h2>
			<pre>type Stage struct {

    <span class="comment">// main</span>
    Desc       <a href="/pkg/builtin/#string">string</a> `json:&#34;desc&#34;`       <span class="comment">// description of simulation stage. ex: activation of top layer</span>
    Activate   []<a href="/pkg/builtin/#int">int</a>  `json:&#34;activate&#34;`   <span class="comment">// array of tags of elements to be activated</span>
    Deactivate []<a href="/pkg/builtin/#int">int</a>  `json:&#34;deactivate&#34;` <span class="comment">// array of tags of elements to be deactivated</span>
    Save       <a href="/pkg/builtin/#bool">bool</a>   `json:&#34;save&#34;`       <span class="comment">// save stage data to binary file</span>
    Load       <a href="/pkg/builtin/#string">string</a> `json:&#34;load&#34;`       <span class="comment">// load stage data (filename) from binary file</span>

    <span class="comment">// specific problems data</span>
    HydroSt   *<a href="#HydroStData">HydroStData</a> `json:&#34;hydrost&#34;`   <span class="comment">// hydrostatic data</span>
    SeepFaces []<a href="/pkg/builtin/#int">int</a>        `json:&#34;seepfaces&#34;` <span class="comment">// face tags corresponding to seepage faces</span>

    <span class="comment">// conditions</span>
    EleConds []*<a href="#EleCond">EleCond</a> `json:&#34;eleconds&#34;` <span class="comment">// element conditions. ex: gravity or beam distributed loads</span>
    FaceBcs  []*<a href="#FaceBc">FaceBc</a>  `json:&#34;facebcs&#34;`  <span class="comment">// face boundary conditions</span>
    SeamBcs  []*<a href="#SeamBc">SeamBc</a>  `json:&#34;seambcs&#34;`  <span class="comment">// seam (3D) boundary conditions</span>
    NodeBcs  []*<a href="#NodeBc">NodeBc</a>  `json:&#34;nodebcs&#34;`  <span class="comment">// node boundary conditions</span>

    <span class="comment">// timecontrol</span>
    Control <a href="#TimeControl">TimeControl</a> `json:&#34;control&#34;` <span class="comment">// time control</span>
}</pre>
			<p>
Stage holds stage data
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="TimeControl">type <a href="/src/target/sim.go?s=6491:6932#L195">TimeControl</a></h2>
			<pre>type TimeControl struct {
    Tf     <a href="/pkg/builtin/#float64">float64</a> `json:&#34;tf&#34;`     <span class="comment">// final time</span>
    Dt     <a href="/pkg/builtin/#float64">float64</a> `json:&#34;dt&#34;`     <span class="comment">// time step size (if constant)</span>
    DtOut  <a href="/pkg/builtin/#float64">float64</a> `json:&#34;dtout&#34;`  <span class="comment">// time step size for output</span>
    DtFcn  <a href="/pkg/builtin/#string">string</a>  `json:&#34;dtfcn&#34;`  <span class="comment">// time step size (function name)</span>
    DtoFcn <a href="/pkg/builtin/#string">string</a>  `json:&#34;tdofcn&#34;` <span class="comment">// time step size for output (function name)</span>

    <span class="comment">// derived</span>
    DtFunc  <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// time step function</span>
    DtoFunc <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// output time step function</span>
}</pre>
			<p>
TimeControl holds data for defining the simulation time stepping
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Vert">type <a href="/src/target/msh.go?s=370:478#L12">Vert</a></h2>
			<pre>type Vert struct {
    Id  <a href="/pkg/builtin/#int">int</a>       <span class="comment">// id</span>
    Tag <a href="/pkg/builtin/#int">int</a>       <span class="comment">// tag</span>
    C   []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// coordinates (size==2 or 3)</span>
}</pre>
			<p>
Vert holds vertex data
</p>


			

			

			
			
			

			

			
				
				<h3 id="Vert.String">func (*Vert) <a href="/src/target/msh.go?s=5035:5065#L198">String</a></h3>
				<pre>func (o *<a href="#Vert">Vert</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
String returns a JSON representation of *Vert
</p>

				
				
				
			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	
	<table class="dir">
	<tr>
	<th>Name</th>
	<th>&nbsp;&nbsp;&nbsp;&nbsp;</th>
	<th style="text-align: left; width: auto">Synopsis</th>
	</tr>
	
		<tr>
		<td><a href="..">..</a></td>
		</tr>
	
	
		
			<tr>
			<td class="name"><a href="data/">data</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto"></td>
			</tr>
		
	
	</table>

	

</div><!-- page -->
<div id="footer">
<br /><br />
<hr>
<pre class="copyright">
Copyright (c) 2015, Dorival Pedroso & Raul Durand
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of gofem nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

</pre><!-- copyright -->
</div><!-- footer -->
</body>
</html>
