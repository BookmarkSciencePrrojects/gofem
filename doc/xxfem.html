<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Gofem &ndash; package fem</title>
<link type="text/css" rel="stylesheet" href="static/style.css">
<script type="text/javascript" src="static/godocs.js"></script>
<style type="text/css"></style>
</head>
<body>
<div id="page"><h1>Gofem &ndash; <b>fem</b> &ndash; finite element method</h1>
<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script type='text/javascript'>
	document.ANALYSIS_DATA = ;
	document.CALLGRAPH = ;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/cpmech/gofem/fem"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
package fem contains elements and solvers for running simulations using the finite element method
</p>

			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
			
				
				<dd><a href="#BuildCoordsMatrix">func BuildCoordsMatrix(cell *inp.Cell, msh *inp.Mesh) (x [][]float64)</a></dd>
			
				
				<dd><a href="#DerivSig">func DerivSig(DσDun [][]float64, n, ndim int, G, D [][]float64)</a></dd>
			
				
				<dd><a href="#GasFlowKeys">func GasFlowKeys(ndim int) []string</a></dd>
			
				
				<dd><a href="#GetContactFaceFlags">func GetContactFaceFlags(extra string) (Macaulay bool, BetRamp, Kappa float64)</a></dd>
			
				
				<dd><a href="#GetIsEssenKeyMap">func GetIsEssenKeyMap() map[string]bool</a></dd>
			
				
				<dd><a href="#GetSeepFaceFlags">func GetSeepFaceFlags(extra string) (Macaulay bool, BetRamp, Kappa float64)</a></dd>
			
				
				<dd><a href="#GetSolidFlags">func GetSolidFlags(axisym, pstress bool, extra string) (useB, debug bool, thickness float64)</a></dd>
			
				
				<dd><a href="#IpAddToKt">func IpAddToKt(Kt [][]float64, nne, ndim int, coef float64, G, D [][]float64)</a></dd>
			
				
				<dd><a href="#IpBmatrix">func IpBmatrix(B [][]float64, ndim, nne int, G [][]float64, radius float64, S []float64, axisym bool)</a></dd>
			
				
				<dd><a href="#IpBmatrix_sparse">func IpBmatrix_sparse(B *la.Triplet, ndim, nne int, G [][]float64, radius float64, S []float64, axisym bool)</a></dd>
			
				
				<dd><a href="#IpStrains">func IpStrains(εs []float64, nne, ndim int, u []float64, Umap []int, G [][]float64)</a></dd>
			
				
				<dd><a href="#IpStrainsAndInc">func IpStrainsAndInc(εs, Δεs []float64, nne, ndim int, u, Δu []float64, Umap []int, G [][]float64)</a></dd>
			
				
				<dd><a href="#IpStrainsAndIncB">func IpStrainsAndIncB(εs, Δεs []float64, nσ, nu int, B [][]float64, u, Δu []float64, Umap []int)</a></dd>
			
				
				<dd><a href="#Ivs2sigmas">func Ivs2sigmas(σ []float64, i int, ivs map[string][]float64)</a></dd>
			
				
				<dd><a href="#LiqFlowKeys">func LiqFlowKeys(ndim int) []string</a></dd>
			
				
				<dd><a href="#NewDomains">func NewDomains(sim *inp.Simulation, dyncfs *DynCoefs, proc, nproc int, distr bool) (doms []*Domain)</a></dd>
			
				
				<dd><a href="#PlotAllBendingMom2d">func PlotAllBendingMom2d(dom *Domain, nstations int, withtext bool, numfmt string, tolM, coef, sf float64) (beams []*Beam, allMrr [][]float64)</a></dd>
			
				
				<dd><a href="#StressKeys">func StressKeys(ndim int) []string</a></dd>
			
				
				<dd><a href="#TestingCompareResultsU">func TestingCompareResultsU(tst *testing.T, simfilepath, cmpfname, alias string, tolK, tolu, tols float64, skipK, verbose bool, extraAfterSetStage func(dom *Domain))</a></dd>
			
			
				
				<dd><a href="#Beam">type Beam</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.AddToKb">func (o *Beam) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.AddToRhs">func (o *Beam) AddToRhs(fb []float64, sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.CalcMoment2d">func (o *Beam) CalcMoment2d(sol *Solution, ξ float64, nstations int) (M22 []float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.CalcMoment3d">func (o *Beam) CalcMoment3d(sol *Solution, ξ float64, nstations int) (M22, M11, T00 []float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.CalcShearForce2d">func (o *Beam) CalcShearForce2d(sol *Solution, ξ float64, nstations int) (V1 []float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.Decode">func (o *Beam) Decode(dec Decoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.Encode">func (o *Beam) Encode(enc Encoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.Id">func (o *Beam) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.InterpStarVars">func (o *Beam) InterpStarVars(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.OutIpCoords">func (o *Beam) OutIpCoords() (C [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.OutIpKeys">func (o *Beam) OutIpKeys() []string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.OutIpVals">func (o *Beam) OutIpVals(M *IpsMap, sol *Solution)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.PlotDiagMoment">func (o *Beam) PlotDiagMoment(M []float64, withtext bool, numfmt string, tolM, sf float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.Recompute">func (o *Beam) Recompute(withM bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.SetEleConds">func (o *Beam) SetEleConds(key string, f fun.Func, extra string) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.SetEqs">func (o *Beam) SetEqs(eqs [][]int, mixedform_eqs []int) (err error)</a></dd>
				
			
				
				<dd><a href="#BjointComp">type BjointComp</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#BjointComp.AddToKb">func (o *BjointComp) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BjointComp.AddToRhs">func (o *BjointComp) AddToRhs(fb []float64, sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BjointComp.BackupIvs">func (o *BjointComp) BackupIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BjointComp.Connect">func (o *BjointComp) Connect(cid2elem []Elem, cell *inp.Cell) (nnzK int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BjointComp.Decode">func (o *BjointComp) Decode(dec Decoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BjointComp.Encode">func (o *BjointComp) Encode(enc Encoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BjointComp.Id">func (o *BjointComp) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BjointComp.InterpStarVars">func (o *BjointComp) InterpStarVars(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BjointComp.Ipoints">func (o *BjointComp) Ipoints() (coords [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BjointComp.OutIpCoords">func (o *BjointComp) OutIpCoords() (C [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BjointComp.OutIpKeys">func (o *BjointComp) OutIpKeys() []string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BjointComp.OutIpVals">func (o *BjointComp) OutIpVals(M *IpsMap, sol *Solution)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BjointComp.RestoreIvs">func (o *BjointComp) RestoreIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BjointComp.SetEleConds">func (o *BjointComp) SetEleConds(key string, f fun.Func, extra string) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BjointComp.SetEqs">func (o *BjointComp) SetEqs(eqs [][]int, mixedform_eqs []int) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BjointComp.SetIniIvs">func (o *BjointComp) SetIniIvs(sol *Solution, ivs map[string][]float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BjointComp.Update">func (o *BjointComp) Update(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BjointComp.Ureset">func (o *BjointComp) Ureset(sol *Solution) (err error)</a></dd>
				
			
				
				<dd><a href="#ColLayer">type ColLayer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ColLayer.Calc">func (o ColLayer) Calc(z float64) (pl, pg, ρL, ρG, ρ, σV float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ColLayer.Calc_ρ">func (o ColLayer) Calc_ρ(ρL, ρG float64) (ρ float64)</a></dd>
				
			
				
				<dd><a href="#ColLayers">type ColLayers</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ColLayers.Len">func (o ColLayers) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ColLayers.Less">func (o ColLayers) Less(i, j int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ColLayers.Swap">func (o ColLayers) Swap(i, j int)</a></dd>
				
			
				
				<dd><a href="#DebugKb_t">type DebugKb_t</a></dd>
				
				
			
				
				<dd><a href="#Decoder">type Decoder</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GetDecoder">func GetDecoder(r goio.Reader, enctype string) Decoder</a></dd>
				
				
			
				
				<dd><a href="#Dof">type Dof</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Dof.String">func (o *Dof) String() string</a></dd>
				
			
				
				<dd><a href="#Domain">type Domain</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.Clean">func (o *Domain) Clean()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.IniSetFileFunc">func (o *Domain) IniSetFileFunc(stg *inp.Stage) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.IniSetPorous">func (o *Domain) IniSetPorous(stg *inp.Stage) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.IniSetStress">func (o *Domain) IniSetStress(stg *inp.Stage) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.Read">func (o *Domain) Read(sum *Summary, tidx, proc int, allInOne bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.ReadIvs">func (o *Domain) ReadIvs(dir, fnkey, enctype string, tidx, proc int) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.ReadSol">func (o *Domain) ReadSol(dir, fnkey, enctype string, tidx int) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.RecomputeKM">func (o *Domain) RecomputeKM()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.Save">func (o *Domain) Save(tidx int, verbose bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.SaveIvs">func (o Domain) SaveIvs(tidx int, verbose bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.SaveSol">func (o Domain) SaveSol(tidx int, verbose bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.SetIniVals">func (o *Domain) SetIniVals(stgidx int, zeroSol bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.SetStage">func (o *Domain) SetStage(stgidx int) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.UpdateElems">func (o *Domain) UpdateElems() (err error)</a></dd>
				
			
				
				<dd><a href="#DynCoefs">type DynCoefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#DynCoefs.CalcAlphas">func (o *DynCoefs) CalcAlphas(Δt float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DynCoefs.CalcBetas">func (o *DynCoefs) CalcBetas(Δt float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DynCoefs.CalcBoth">func (o *DynCoefs) CalcBoth(Δt float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DynCoefs.Init">func (o *DynCoefs) Init(dat *inp.SolverData)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DynCoefs.Print">func (o *DynCoefs) Print()</a></dd>
				
			
				
				<dd><a href="#EbcArray">type EbcArray</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EbcArray.Len">func (o EbcArray) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EbcArray.Less">func (o EbcArray) Less(i, j int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EbcArray.Swap">func (o EbcArray) Swap(i, j int)</a></dd>
				
			
				
				<dd><a href="#ElastRod">type ElastRod</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ElastRod.AddToKb">func (o *ElastRod) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElastRod.AddToRhs">func (o *ElastRod) AddToRhs(fb []float64, sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElastRod.CalcSig">func (o *ElastRod) CalcSig(sol *Solution) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElastRod.Decode">func (o *ElastRod) Decode(dec Decoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElastRod.Encode">func (o *ElastRod) Encode(enc Encoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElastRod.Id">func (o *ElastRod) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElastRod.InterpStarVars">func (o *ElastRod) InterpStarVars(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElastRod.OutIpCoords">func (o *ElastRod) OutIpCoords() (C [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElastRod.OutIpKeys">func (o *ElastRod) OutIpKeys() []string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElastRod.OutIpVals">func (o *ElastRod) OutIpVals(M *IpsMap, sol *Solution)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElastRod.Recompute">func (o *ElastRod) Recompute(withM bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElastRod.SetEleConds">func (o *ElastRod) SetEleConds(key string, f fun.Func, extra string) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElastRod.SetEqs">func (o *ElastRod) SetEqs(eqs [][]int, mixedform_eqs []int) (err error)</a></dd>
				
			
				
				<dd><a href="#Elem">type Elem</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewElem">func NewElem(cell *inp.Cell, reg *inp.Region, sim *inp.Simulation) (ele Elem, err error)</a></dd>
				
				
			
				
				<dd><a href="#ElemConnector">type ElemConnector</a></dd>
				
				
			
				
				<dd><a href="#ElemExtrap">type ElemExtrap</a></dd>
				
				
			
				
				<dd><a href="#ElemFixedKM">type ElemFixedKM</a></dd>
				
				
			
				
				<dd><a href="#ElemIntvars">type ElemIntvars</a></dd>
				
				
			
				
				<dd><a href="#ElemOutIps">type ElemOutIps</a></dd>
				
				
			
				
				<dd><a href="#ElemP">type ElemP</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.AddToKb">func (o *ElemP) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.AddToRhs">func (o *ElemP) AddToRhs(fb []float64, sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.BackupIvs">func (o *ElemP) BackupIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.Decode">func (o *ElemP) Decode(dec Decoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.Encode">func (o *ElemP) Encode(enc Encoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.Id">func (o *ElemP) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.InterpStarVars">func (o *ElemP) InterpStarVars(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.Ipoints">func (o *ElemP) Ipoints() (coords [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.OutIpCoords">func (o *ElemP) OutIpCoords() (C [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.OutIpKeys">func (o *ElemP) OutIpKeys() []string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.OutIpVals">func (o *ElemP) OutIpVals(M *IpsMap, sol *Solution)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.RestoreIvs">func (o *ElemP) RestoreIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.SetEleConds">func (o *ElemP) SetEleConds(key string, f fun.Func, extra string) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.SetEqs">func (o *ElemP) SetEqs(eqs [][]int, mixedform_eqs []int) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.SetIniIvs">func (o *ElemP) SetIniIvs(sol *Solution, ignored map[string][]float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.Update">func (o *ElemP) Update(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.Ureset">func (o *ElemP) Ureset(sol *Solution) (err error)</a></dd>
				
			
				
				<dd><a href="#ElemPP">type ElemPP</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPP.AddToKb">func (o *ElemPP) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPP.AddToRhs">func (o *ElemPP) AddToRhs(fb []float64, sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPP.BackupIvs">func (o *ElemPP) BackupIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPP.Decode">func (o *ElemPP) Decode(dec Decoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPP.Encode">func (o *ElemPP) Encode(enc Encoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPP.Id">func (o *ElemPP) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPP.InterpStarVars">func (o *ElemPP) InterpStarVars(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPP.Ipoints">func (o *ElemPP) Ipoints() (coords [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPP.OutIpCoords">func (o *ElemPP) OutIpCoords() (C [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPP.OutIpKeys">func (o *ElemPP) OutIpKeys() []string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPP.OutIpVals">func (o *ElemPP) OutIpVals(M *IpsMap, sol *Solution)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPP.RestoreIvs">func (o *ElemPP) RestoreIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPP.SetEleConds">func (o *ElemPP) SetEleConds(key string, f fun.Func, extra string) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPP.SetEqs">func (o *ElemPP) SetEqs(eqs [][]int, mixedform_eqs []int) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPP.SetIniIvs">func (o *ElemPP) SetIniIvs(sol *Solution, ignored map[string][]float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPP.Update">func (o *ElemPP) Update(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPP.Ureset">func (o *ElemPP) Ureset(sol *Solution) (err error)</a></dd>
				
			
				
				<dd><a href="#ElemPhi">type ElemPhi</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.AddToKb">func (o *ElemPhi) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.AddToRhs">func (o *ElemPhi) AddToRhs(fb []float64, sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.Decode">func (o *ElemPhi) Decode(dec Decoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.Encode">func (o *ElemPhi) Encode(enc Encoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.Id">func (o *ElemPhi) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.InterpStarVars">func (o *ElemPhi) InterpStarVars(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.OutIpCoords">func (o *ElemPhi) OutIpCoords() (C [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.OutIpKeys">func (o *ElemPhi) OutIpKeys() []string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.OutIpVals">func (o *ElemPhi) OutIpVals(M *IpsMap, sol *Solution)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.SetEleConds">func (o *ElemPhi) SetEleConds(key string, f fun.Func, extra string) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.SetEqs">func (o *ElemPhi) SetEqs(eqs [][]int, mixedform_eqs []int) (err error)</a></dd>
				
			
				
				<dd><a href="#ElemU">type ElemU</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.AddToExt">func (o *ElemU) AddToExt(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.AddToKb">func (o *ElemU) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.AddToRhs">func (o *ElemU) AddToRhs(fb []float64, sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.BackupIvs">func (o *ElemU) BackupIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.Decode">func (o *ElemU) Decode(dec Decoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.Encode">func (o *ElemU) Encode(enc Encoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.Id">func (o *ElemU) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.InterpStarVars">func (o *ElemU) InterpStarVars(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.Ipoints">func (o *ElemU) Ipoints() (coords [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.OutIpCoords">func (o *ElemU) OutIpCoords() (C [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.OutIpKeys">func (o *ElemU) OutIpKeys() []string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.OutIpVals">func (o *ElemU) OutIpVals(M *IpsMap, sol *Solution)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.RestoreIvs">func (o *ElemU) RestoreIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.SetEleConds">func (o *ElemU) SetEleConds(key string, f fun.Func, extra string) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.SetEqs">func (o *ElemU) SetEqs(eqs [][]int, mixedform_eqs []int) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.SetIniIvs">func (o *ElemU) SetIniIvs(sol *Solution, ivs map[string][]float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.Update">func (o *ElemU) Update(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.Ureset">func (o *ElemU) Ureset(sol *Solution) (err error)</a></dd>
				
			
				
				<dd><a href="#ElemUP">type ElemUP</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.AddToKb">func (o *ElemUP) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.AddToRhs">func (o *ElemUP) AddToRhs(fb []float64, sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.BackupIvs">func (o *ElemUP) BackupIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.Decode">func (o *ElemUP) Decode(dec Decoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.Encode">func (o *ElemUP) Encode(enc Encoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.Id">func (o *ElemUP) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.InterpStarVars">func (o *ElemUP) InterpStarVars(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.Ipoints">func (o *ElemUP) Ipoints() (coords [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.OutIpCoords">func (o *ElemUP) OutIpCoords() (C [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.OutIpKeys">func (o *ElemUP) OutIpKeys() []string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.OutIpVals">func (o *ElemUP) OutIpVals(M *IpsMap, sol *Solution)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.RestoreIvs">func (o *ElemUP) RestoreIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.SetEleConds">func (o *ElemUP) SetEleConds(key string, f fun.Func, extra string) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.SetEqs">func (o *ElemUP) SetEqs(eqs [][]int, mixedform_eqs []int) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.SetIniIvs">func (o *ElemUP) SetIniIvs(sol *Solution, ivs map[string][]float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.Update">func (o *ElemUP) Update(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.Ureset">func (o *ElemUP) Ureset(sol *Solution) (err error)</a></dd>
				
			
				
				<dd><a href="#ElemUPP">type ElemUPP</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUPP.AddToKb">func (o *ElemUPP) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUPP.AddToRhs">func (o *ElemUPP) AddToRhs(fb []float64, sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUPP.BackupIvs">func (o *ElemUPP) BackupIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUPP.Decode">func (o *ElemUPP) Decode(dec Decoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUPP.Encode">func (o *ElemUPP) Encode(enc Encoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUPP.Id">func (o *ElemUPP) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUPP.InterpStarVars">func (o *ElemUPP) InterpStarVars(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUPP.Ipoints">func (o *ElemUPP) Ipoints() (coords [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUPP.OutIpCoords">func (o *ElemUPP) OutIpCoords() (C [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUPP.OutIpKeys">func (o *ElemUPP) OutIpKeys() []string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUPP.OutIpVals">func (o *ElemUPP) OutIpVals(M *IpsMap, sol *Solution)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUPP.RestoreIvs">func (o *ElemUPP) RestoreIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUPP.SetEleConds">func (o *ElemUPP) SetEleConds(key string, f fun.Func, extra string) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUPP.SetEqs">func (o *ElemUPP) SetEqs(eqs [][]int, mixedform_eqs []int) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUPP.SetIniIvs">func (o *ElemUPP) SetIniIvs(sol *Solution, ivs map[string][]float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUPP.Update">func (o *ElemUPP) Update(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUPP.Ureset">func (o *ElemUPP) Ureset(sol *Solution) (err error)</a></dd>
				
			
				
				<dd><a href="#Encoder">type Encoder</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GetEncoder">func GetEncoder(w goio.Writer, enctype string) Encoder</a></dd>
				
				
			
				
				<dd><a href="#EssentialBc">type EssentialBc</a></dd>
				
				
			
				
				<dd><a href="#EssentialBcs">type EssentialBcs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EssentialBcs.AddToRhs">func (o *EssentialBcs) AddToRhs(fb []float64, sol *Solution)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EssentialBcs.Build">func (o *EssentialBcs) Build(ny int) (nλ, nnzA int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EssentialBcs.FixIniVals">func (o *EssentialBcs) FixIniVals(sol *Solution)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EssentialBcs.Init">func (o *EssentialBcs) Init(liqmdl *fld.Model)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EssentialBcs.List">func (o *EssentialBcs) List(t float64) (l string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EssentialBcs.Set">func (o *EssentialBcs) Set(key string, nodes []*Node, fcn fun.Func, extra string) (err error)</a></dd>
				
			
				
				<dd><a href="#FEM">type FEM</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFEM">func NewFEM(simfilepath, alias string, erasePrev, saveSummary, readSummary, allowParallel, verbose bool, goroutineId int) (o *FEM)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FEM.Run">func (o *FEM) Run() (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FEM.SetStage">func (o *FEM) SetStage(stgidx int) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FEM.SolveOneStage">func (o *FEM) SolveOneStage(stgidx int, zerostage bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FEM.ZeroStage">func (o *FEM) ZeroStage(stgidx int, zeroSol bool) (err error)</a></dd>
				
			
				
				<dd><a href="#FEsolver">type FEsolver</a></dd>
				
				
			
				
				<dd><a href="#Info">type Info</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GetElemInfo">func GetElemInfo(cell *inp.Cell, reg *inp.Region, sim *inp.Simulation) (info *Info, inactive bool, err error)</a></dd>
				
				
			
				
				<dd><a href="#IpsMap">type IpsMap</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewIpsMap">func NewIpsMap() *IpsMap</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IpsMap.Get">func (o *IpsMap) Get(key string, idx int) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IpsMap.Set">func (o *IpsMap) Set(key string, idx, nip int, val float64)</a></dd>
				
			
				
				<dd><a href="#NaturalBc">type NaturalBc</a></dd>
				
				
			
				
				<dd><a href="#Node">type Node</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewNode">func NewNode(v *inp.Vert) *Node</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.AddDofAndEq">func (o *Node) AddDofAndEq(ukey string, eqnum int) (nexteq int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.GetDof">func (o *Node) GetDof(ukey string) *Dof</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.GetEq">func (o *Node) GetEq(ukey string) (eqNumber int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.GetKeys">func (o *Node) GetKeys() []string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.SetEq">func (o *Node) SetEq(ukey string, eqNumber int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.String">func (o *Node) String() string</a></dd>
				
			
				
				<dd><a href="#PtNaturalBc">type PtNaturalBc</a></dd>
				
				
			
				
				<dd><a href="#PtNaturalBcs">type PtNaturalBcs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PtNaturalBcs.AddToRhs">func (o PtNaturalBcs) AddToRhs(fb []float64, t float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PtNaturalBcs.List">func (o *PtNaturalBcs) List(t float64) (l string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PtNaturalBcs.Reset">func (o *PtNaturalBcs) Reset()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PtNaturalBcs.Set">func (o *PtNaturalBcs) Set(key string, nod *Node, fcn fun.Func, extra string) (setisok bool)</a></dd>
				
			
				
				<dd><a href="#RichardsonExtrap">type RichardsonExtrap</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RichardsonExtrap.Init">func (o *RichardsonExtrap) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RichardsonExtrap.Run">func (o *RichardsonExtrap) Run(tf float64, dtFunc, dtoFunc fun.Func, verbose bool, dbgKb DebugKb_t) (err error)</a></dd>
				
			
				
				<dd><a href="#Rjoint">type Rjoint</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.AddToKb">func (o *Rjoint) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.AddToRhs">func (o *Rjoint) AddToRhs(fb []float64, sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.BackupIvs">func (o *Rjoint) BackupIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.Connect">func (o *Rjoint) Connect(cid2elem []Elem, c *inp.Cell) (nnzK int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.Decode">func (o *Rjoint) Decode(dec Decoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.Encode">func (o *Rjoint) Encode(enc Encoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.Id">func (o *Rjoint) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.InterpStarVars">func (o *Rjoint) InterpStarVars(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.Ipoints">func (o *Rjoint) Ipoints() (coords [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.OutIpCoords">func (o *Rjoint) OutIpCoords() (C [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.OutIpKeys">func (o *Rjoint) OutIpKeys() []string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.OutIpVals">func (o *Rjoint) OutIpVals(M *IpsMap, sol *Solution)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.RestoreIvs">func (o *Rjoint) RestoreIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.SetEleConds">func (o *Rjoint) SetEleConds(key string, f fun.Func, extra string) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.SetEqs">func (o *Rjoint) SetEqs(eqs [][]int, mixedform_eqs []int) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.SetIniIvs">func (o *Rjoint) SetIniIvs(sol *Solution, ivs map[string][]float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.Update">func (o *Rjoint) Update(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.Ureset">func (o *Rjoint) Ureset(sol *Solution) (err error)</a></dd>
				
			
				
				<dd><a href="#Rod">type Rod</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.AddToKb">func (o *Rod) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.AddToRhs">func (o *Rod) AddToRhs(fb []float64, sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.BackupIvs">func (o *Rod) BackupIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.Decode">func (o *Rod) Decode(dec Decoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.Encode">func (o *Rod) Encode(enc Encoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.Id">func (o *Rod) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.InterpStarVars">func (o *Rod) InterpStarVars(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.Ipoints">func (o *Rod) Ipoints() (coords [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.OutIpCoords">func (o *Rod) OutIpCoords() (C [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.OutIpKeys">func (o *Rod) OutIpKeys() []string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.OutIpVals">func (o *Rod) OutIpVals(M *IpsMap, sol *Solution)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.RestoreIvs">func (o *Rod) RestoreIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.SetEleConds">func (o *Rod) SetEleConds(key string, f fun.Func, extra string) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.SetEqs">func (o *Rod) SetEqs(eqs [][]int, mixedform_eqs []int) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.SetIniIvs">func (o *Rod) SetIniIvs(sol *Solution, ivs map[string][]float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.SetIvs">func (o *Rod) SetIvs(zvars map[string][]float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.Update">func (o *Rod) Update(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.Ureset">func (o *Rod) Ureset(sol *Solution) (err error)</a></dd>
				
			
				
				<dd><a href="#Solution">type Solution</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Solution.Reset">func (o *Solution) Reset(steady bool)</a></dd>
				
			
				
				<dd><a href="#SolverImplicit">type SolverImplicit</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SolverImplicit.Run">func (o *SolverImplicit) Run(tf float64, dtFunc, dtoFunc fun.Func, verbose bool, dbgKb DebugKb_t) (err error)</a></dd>
				
			
				
				<dd><a href="#SolverLinearImplicit">type SolverLinearImplicit</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SolverLinearImplicit.Run">func (o *SolverLinearImplicit) Run(tf float64, dtFunc, dtoFunc fun.Func, verbose bool, notused DebugKb_t) (err error)</a></dd>
				
			
				
				<dd><a href="#Summary">type Summary</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Summary.Read">func (o *Summary) Read(dir, fnkey, enctype string) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Summary.Save">func (o Summary) Save(dirout, fnkey, enctype string, nproc, proc int, verbose bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Summary.SaveDomains">func (o *Summary) SaveDomains(time float64, doms []*Domain, verbose bool) (err error)</a></dd>
				
			
				
				<dd><a href="#T_iteration">type T_iteration</a></dd>
				
				
			
				
				<dd><a href="#T_results">type T_results</a></dd>
				
				
			
				
				<dd><a href="#T_results_set">type T_results_set</a></dd>
				
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/github.com/cpmech/gofem/fem/auxsolid.go">auxsolid.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/domain.go">domain.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/dyncoefs.go">dyncoefs.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_beam.go">e_beam.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_bjointcomp.go">e_bjointcomp.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_elastrod.go">e_elastrod.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_p.go">e_p.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_phi.go">e_phi.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_pp.go">e_pp.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_rjoint.go">e_rjoint.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_rod.go">e_rod.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_u.go">e_u.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_u_contact.go">e_u_contact.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_u_xfem.go">e_u_xfem.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_up.go">e_up.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_upp.go">e_upp.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/element.go">element.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/essenbcs.go">essenbcs.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/fem.go">fem.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/fileio.go">fileio.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/i_filefunc.go">i_filefunc.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/i_porous.go">i_porous.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/i_stress.go">i_stress.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/keycodes.go">keycodes.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/naturalbcs.go">naturalbcs.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/node.go">node.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/output.go">output.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/ptnatbcs.go">ptnatbcs.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/s_implicit.go">s_implicit.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/s_linimp.go">s_linimp.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/s_richardson.go">s_richardson.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/summary.go">summary.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/testing.go">testing.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		<div id="pkg-callgraph" class="toggle" style="display: none">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
		</div> <!-- .expanded -->
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
			<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls&mdash;perhaps dynamically.
			</p>
			<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
			<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
			<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
			<!-- Zero means show all package entry points. -->
			<ul style="margin-left: 0.5in" id="callgraph-0" class="treeview"></ul>
		</div>
		</div> <!-- #pkg-callgraph -->

		
			<h2 id="pkg-constants">Constants</h2>
			
				<pre>const <span id="SQ2">SQ2</span> = <a href="/pkg/math/">math</a>.<a href="/pkg/math/#Sqrt2">Sqrt2</a></pre>
				
			
		
		
		
			
			
			<h2 id="BuildCoordsMatrix">func <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=6191:6260#L156">BuildCoordsMatrix</a></h2>
			<pre>func BuildCoordsMatrix(cell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>, msh *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Mesh">Mesh</a>) (x [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
BuildCoordsMatrix returns the coordinate matrix of a particular Cell
</p>

			
			

		
			
			
			<h2 id="DerivSig">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=4943:5007#L74">DerivSig</a></h2>
			<pre>func DerivSig(DσDun [][]<a href="/pkg/builtin/#float64">float64</a>, n, ndim <a href="/pkg/builtin/#int">int</a>, G, D [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
DerivSig returns the derivative of σ (Mandel) with respect to displacement at nodes
</p>
<pre>Note: DσDun = ∂σ/∂un  [nσ][ndim]
</pre>

			
			

		
			
			
			<h2 id="GasFlowKeys">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=9743:9778#L224">GasFlowKeys</a></h2>
			<pre>func GasFlowKeys(ndim <a href="/pkg/builtin/#int">int</a>) []<a href="/pkg/builtin/#string">string</a></pre>
			
			
			

		
			
			
			<h2 id="GetContactFaceFlags">func <a href="https://github.com/cpmech/gofem/blob/master/fem/keycodes.go?s=1318:1396#L56">GetContactFaceFlags</a></h2>
			<pre>func GetContactFaceFlags(extra <a href="/pkg/builtin/#string">string</a>) (Macaulay <a href="/pkg/builtin/#bool">bool</a>, BetRamp, Kappa <a href="/pkg/builtin/#float64">float64</a>)</pre>
			
			
			

		
			
			
			<h2 id="GetIsEssenKeyMap">func <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=3385:3424#L103">GetIsEssenKeyMap</a></h2>
			<pre>func GetIsEssenKeyMap() map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
GetIsEssenKeyMap returns the &#34;YandC&#34; map with special keys that EssentialBcs can handle,
including:
</p>
<pre>rigid  -- define rigid element constraints
incsup -- inclined support constraints
hst    -- set hydrostatic pressures
</pre>

			
			

		
			
			
			<h2 id="GetSeepFaceFlags">func <a href="https://github.com/cpmech/gofem/blob/master/fem/keycodes.go?s=815:890#L32">GetSeepFaceFlags</a></h2>
			<pre>func GetSeepFaceFlags(extra <a href="/pkg/builtin/#string">string</a>) (Macaulay <a href="/pkg/builtin/#bool">bool</a>, BetRamp, Kappa <a href="/pkg/builtin/#float64">float64</a>)</pre>
			
			
			

		
			
			
			<h2 id="GetSolidFlags">func <a href="https://github.com/cpmech/gofem/blob/master/fem/keycodes.go?s=240:332#L3">GetSolidFlags</a></h2>
			<pre>func GetSolidFlags(axisym, pstress <a href="/pkg/builtin/#bool">bool</a>, extra <a href="/pkg/builtin/#string">string</a>) (useB, debug <a href="/pkg/builtin/#bool">bool</a>, thickness <a href="/pkg/builtin/#float64">float64</a>)</pre>
			
			
			

		
			
			
			<h2 id="IpAddToKt">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=294:371#L6">IpAddToKt</a></h2>
			<pre>func IpAddToKt(Kt [][]<a href="/pkg/builtin/#float64">float64</a>, nne, ndim <a href="/pkg/builtin/#int">int</a>, coef <a href="/pkg/builtin/#float64">float64</a>, G, D [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			
			
			

		
			
			
			<h2 id="IpBmatrix">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=7076:7177#L106">IpBmatrix</a></h2>
			<pre>func IpBmatrix(B [][]<a href="/pkg/builtin/#float64">float64</a>, ndim, nne <a href="/pkg/builtin/#int">int</a>, G [][]<a href="/pkg/builtin/#float64">float64</a>, radius <a href="/pkg/builtin/#float64">float64</a>, S []<a href="/pkg/builtin/#float64">float64</a>, axisym <a href="/pkg/builtin/#bool">bool</a>)</pre>
			
			
			

		
			
			
			<h2 id="IpBmatrix_sparse">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=8113:8221#L149">IpBmatrix_sparse</a></h2>
			<pre>func IpBmatrix_sparse(B *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, ndim, nne <a href="/pkg/builtin/#int">int</a>, G [][]<a href="/pkg/builtin/#float64">float64</a>, radius <a href="/pkg/builtin/#float64">float64</a>, S []<a href="/pkg/builtin/#float64">float64</a>, axisym <a href="/pkg/builtin/#bool">bool</a>)</pre>
			
			
			

		
			
			
			<h2 id="IpStrains">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=3773:3857#L33">IpStrains</a></h2>
			<pre>func IpStrains(εs []<a href="/pkg/builtin/#float64">float64</a>, nne, ndim <a href="/pkg/builtin/#int">int</a>, u []<a href="/pkg/builtin/#float64">float64</a>, Umap []<a href="/pkg/builtin/#int">int</a>, G [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			
			
			

		
			
			
			<h2 id="IpStrainsAndInc">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=4212:4314#L51">IpStrainsAndInc</a></h2>
			<pre>func IpStrainsAndInc(εs, Δεs []<a href="/pkg/builtin/#float64">float64</a>, nne, ndim <a href="/pkg/builtin/#int">int</a>, u, Δu []<a href="/pkg/builtin/#float64">float64</a>, Umap []<a href="/pkg/builtin/#int">int</a>, G [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			
			
			

		
			
			
			<h2 id="IpStrainsAndIncB">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=7845:7946#L139">IpStrainsAndIncB</a></h2>
			<pre>func IpStrainsAndIncB(εs, Δεs []<a href="/pkg/builtin/#float64">float64</a>, nσ, nu <a href="/pkg/builtin/#int">int</a>, B [][]<a href="/pkg/builtin/#float64">float64</a>, u, Δu []<a href="/pkg/builtin/#float64">float64</a>, Umap []<a href="/pkg/builtin/#int">int</a>)</pre>
			
			
			

		
			
			
			<h2 id="Ivs2sigmas">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=9045:9107#L186">Ivs2sigmas</a></h2>
			<pre>func Ivs2sigmas(σ []<a href="/pkg/builtin/#float64">float64</a>, i <a href="/pkg/builtin/#int">int</a>, ivs map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Ivs2sigmas converts ivs map to σ values [nsig]
</p>
<pre>σ -- [ndim] stresses
i -- index of integration point
</pre>

			
			

		
			
			
			<h2 id="LiqFlowKeys">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=9570:9605#L216">LiqFlowKeys</a></h2>
			<pre>func LiqFlowKeys(ndim <a href="/pkg/builtin/#int">int</a>) []<a href="/pkg/builtin/#string">string</a></pre>
			
			
			

		
			
			
			<h2 id="NewDomains">func <a href="https://github.com/cpmech/gofem/blob/master/fem/domain.go?s=4949:5049#L111">NewDomains</a></h2>
			<pre>func NewDomains(sim *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Simulation">Simulation</a>, dyncfs *<a href="#DynCoefs">DynCoefs</a>, proc, nproc <a href="/pkg/builtin/#int">int</a>, distr <a href="/pkg/builtin/#bool">bool</a>) (doms []*<a href="#Domain">Domain</a>)</pre>
			<p>
NewDomains returns domains
</p>

			
			

		
			
			
			<h2 id="PlotAllBendingMom2d">func <a href="https://github.com/cpmech/gofem/blob/master/fem/output.go?s=804:946#L14">PlotAllBendingMom2d</a></h2>
			<pre>func PlotAllBendingMom2d(dom *<a href="#Domain">Domain</a>, nstations <a href="/pkg/builtin/#int">int</a>, withtext <a href="/pkg/builtin/#bool">bool</a>, numfmt <a href="/pkg/builtin/#string">string</a>, tolM, coef, sf <a href="/pkg/builtin/#float64">float64</a>) (beams []*<a href="#Beam">Beam</a>, allMrr [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
PlotAllBendingMom2d plots all bending moments (2D beams)
</p>
<pre>Input:
 dom       -- Domain
 nstations -- number of stations
 withtext  -- show bending moment values
 numfmt    -- number format for values. use &#34;&#34; for default
 tolM      -- tolerance to clip absolute values of M
 coef      -- coefficient to scale max(dimension) divided by max(Y); e.g. 0.1
 sf        -- scaling factor. use 0 for automatic computation
Output:
 beams  -- all beam elements
 allMrr -- all Mrr bending moments at all beams
</pre>

			
			

		
			
			
			<h2 id="StressKeys">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=9412:9446#L209">StressKeys</a></h2>
			<pre>func StressKeys(ndim <a href="/pkg/builtin/#int">int</a>) []<a href="/pkg/builtin/#string">string</a></pre>
			
			
			

		
			
			
			<h2 id="TestingCompareResultsU">func <a href="https://github.com/cpmech/gofem/blob/master/fem/testing.go?s=1265:1430#L33">TestingCompareResultsU</a></h2>
			<pre>func TestingCompareResultsU(tst *<a href="/pkg/testing/">testing</a>.<a href="/pkg/testing/#T">T</a>, simfilepath, cmpfname, alias <a href="/pkg/builtin/#string">string</a>, tolK, tolu, tols <a href="/pkg/builtin/#float64">float64</a>, skipK, verbose <a href="/pkg/builtin/#bool">bool</a>, extraAfterSetStage func(dom *<a href="#Domain">Domain</a>))</pre>
			<p>
testing_compare_results_u compares results with u-formulation
</p>

			
			

		
		
			
			
			<h2 id="Beam">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=1710:3544#L38">Beam</a></h2>
			<pre>type Beam struct {

    <span class="comment">// basic data</span>
    Cell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>   <span class="comment">// the cell structure</span>
    X    [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// matrix of nodal coordinates [ndim][nnode]</span>
    P02  []<a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// [3] point defining y0-y2 plane (from X matrix or computed here for horizontal/vertical beams)</span>
    Nu   <a href="/pkg/builtin/#int">int</a>         <span class="comment">// total number of unknowns</span>
    Ndim <a href="/pkg/builtin/#int">int</a>         <span class="comment">// space dimension</span>

    <span class="comment">// parameters and properties</span>
    Mdl *<a href="/pkg/github.com/cpmech/gofem/mdl/sld/">sld</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/sld/#OnedLinElast">OnedLinElast</a> <span class="comment">// material model with: E, G, A, I22, I11, Jtt and Rho</span>
    L   <a href="/pkg/builtin/#float64">float64</a>           <span class="comment">// (derived) length of beam</span>

    <span class="comment">// for output</span>
    Nstations <a href="/pkg/builtin/#int">int</a> <span class="comment">// number of points along beam to generate bending moment / shear force diagrams</span>

    <span class="comment">// variables for dynamics</span>
    Gfcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// gravity function</span>

    <span class="comment">// vectors and matrices</span>
    T   [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// global-to-local transformation matrix [nnode*ndim][nnode*ndim]</span>
    Kl  [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// local K matrix</span>
    K   [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// global K matrix</span>
    Ml  [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// local M matrices</span>
    M   [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// global M matrices</span>
    Rus []<a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// residual: Rus = fi - fx</span>

    <span class="comment">// problem variables</span>
    Umap []<a href="/pkg/builtin/#int">int</a>    <span class="comment">// assembly map (location array/element equations)</span>
    Hasq <a href="/pkg/builtin/#bool">bool</a>     <span class="comment">// has distributed loads</span>
    QnL  <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// distributed normal load functions: left</span>
    QnR  <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// distributed normal load functions: right</span>
    Qt   <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// distributed tangential load</span>
    Q1   <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// 3D: load on plane s-t</span>
    Q2   <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// 3D: load on plane r-t</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Beam represents a structural beam element (Euler-Bernoulli, linear elastic)
</p>
<pre>2D    y1     y2 is out-of-plane
       ^
       | qnL          qn            qnR     Props:    Nodes:
       o-------------------------------o     E, A      0 and 1
       |                               |     I22
       |                               |
     (y2)-----------------------------(1)------&gt; y0

3D                    ,o--------o    ,y0
                    ,&#39; |     ,&#39; |  ,&#39;
      y1          ,&#39;       ,&#39;   |,&#39;
       ^        ,&#39;q1     ,&#39;    ,|
       |      ,&#39;  V    ,&#39;    ,  |
       |    ,&#39;       ,&#39;    ,    |
       |  ,&#39;       ,&#39;  | ,      |
       |,&#39;       ,&#39;   (1) - - - o   -   -  (2)
       o--------o    ,        ,&#39;
       |        |  ,  &lt;q2   ,&#39;    Props:          Nodes:
       |        |,        ,&#39;       E, G, A         0, 1, 2
       |       ,|       ,&#39;         I22 ~ Imax      where node (2) is a point located on plane
       |     ,  |     ,&#39;           I11 ~ Imin      y0-y2 and non-colinear to (0) and (1).
       |   ,    |   ,&#39;             Jtt             Node (2) doest not have any DOF
       | ,      | ,&#39;
      (0)-------o&#39; --------&gt; y2
</pre>


			

			

			
			
			

			

			
				
				<h3 id="Beam.AddToKb">func (*Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=8196:8275#L290">AddToKb</a></h3>
				<pre>func (o *<a href="#Beam">Beam</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="Beam.AddToRhs">func (*Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=6980:7044#L237">AddToRhs</a></h3>
				<pre>func (o *<a href="#Beam">Beam</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="Beam.CalcMoment2d">func (*Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=17303:17388#L638">CalcMoment2d</a></h3>
				<pre>func (o *<a href="#Beam">Beam</a>) CalcMoment2d(sol *<a href="#Solution">Solution</a>, ξ <a href="/pkg/builtin/#float64">float64</a>, nstations <a href="/pkg/builtin/#int">int</a>) (M22 []<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
CalcMoment2d calculates bending moment along 2D beam
</p>
<pre>Input:
 ξ         -- natural coordinate along bar   0 ≤ ξ ≤ 1
 nstations -- compute many values; otherwise, if nstations&lt;2, compute @ s
Output:
 M22 -- bending moment @ stations or s
</pre>

				
				
				
			
				
				<h3 id="Beam.CalcMoment3d">func (*Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=16512:16607#L615">CalcMoment3d</a></h3>
				<pre>func (o *<a href="#Beam">Beam</a>) CalcMoment3d(sol *<a href="#Solution">Solution</a>, ξ <a href="/pkg/builtin/#float64">float64</a>, nstations <a href="/pkg/builtin/#int">int</a>) (M22, M11, T00 []<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
CalcMoment3d calculates moments along 3D beam
</p>
<pre>Input:
 ξ         -- natural coordinate along bar   0 ≤ ξ ≤ 1
 nstations -- compute many values; otherwise, if nstations&lt;2, compute @ s
Output:
 M22 -- bending moment about y2-axis
 M11 -- bending moment about y1-axis
 T00 -- twisting moment around y0-axis
</pre>

				
				
				
			
				
				<h3 id="Beam.CalcShearForce2d">func (*Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=17939:18027#L659">CalcShearForce2d</a></h3>
				<pre>func (o *<a href="#Beam">Beam</a>) CalcShearForce2d(sol *<a href="#Solution">Solution</a>, ξ <a href="/pkg/builtin/#float64">float64</a>, nstations <a href="/pkg/builtin/#int">int</a>) (V1 []<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
CalcShearForce2d calculates shear force for 2D beam
</p>
<pre>Input:
 ξ         -- natural coordinate along bar   0 ≤ ξ ≤ 1
 nstations -- compute many values; otherwise, if nstations&lt;2, compute @ s
Output:
 V1 -- shear force @ stations or s
</pre>

				
				
				
			
				
				<h3 id="Beam.Decode">func (*Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=8676:8722#L314">Decode</a></h3>
				<pre>func (o *<a href="#Beam">Beam</a>) Decode(dec <a href="#Decoder">Decoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="Beam.Encode">func (*Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=8579:8625#L309">Encode</a></h3>
				<pre>func (o *<a href="#Beam">Beam</a>) Encode(enc <a href="#Encoder">Encoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="Beam.Id">func (*Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=5853:5876#L184">Id</a></h3>
				<pre>func (o *<a href="#Beam">Beam</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="Beam.InterpStarVars">func (*Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=6815:6871#L229">InterpStarVars</a></h3>
				<pre>func (o *<a href="#Beam">Beam</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
InterpStarVars interpolates star variables to integration points
</p>

				
				
				
			
				
				<h3 id="Beam.OutIpCoords">func (*Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=8797:8841#L319">OutIpCoords</a></h3>
				<pre>func (o *<a href="#Beam">Beam</a>) OutIpCoords() (C [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
OutIpCoords returns the coordinates of integration points
</p>

				
				
				
			
				
				<h3 id="Beam.OutIpKeys">func (*Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=9158:9193#L333">OutIpKeys</a></h3>
				<pre>func (o *<a href="#Beam">Beam</a>) OutIpKeys() []<a href="/pkg/builtin/#string">string</a></pre>
				<p>
OutIpKeys returns the integration points&#39; keys
</p>

				
				
				
			
				
				<h3 id="Beam.OutIpVals">func (*Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=9357:9407#L341">OutIpVals</a></h3>
				<pre>func (o *<a href="#Beam">Beam</a>) OutIpVals(M *<a href="#IpsMap">IpsMap</a>, sol *<a href="#Solution">Solution</a>)</pre>
				<p>
OutIpVals returns the integration points&#39; values corresponding to keys
</p>

				
				
				
			
				
				<h3 id="Beam.PlotDiagMoment">func (*Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=21148:21238#L766">PlotDiagMoment</a></h3>
				<pre>func (o *<a href="#Beam">Beam</a>) PlotDiagMoment(M []<a href="/pkg/builtin/#float64">float64</a>, withtext <a href="/pkg/builtin/#bool">bool</a>, numfmt <a href="/pkg/builtin/#string">string</a>, tolM, sf <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
PlotDiagMoment plots bending moment diagram
</p>
<pre>Input:
 M        -- moment along stations
 withtext -- show bending moment values
 numfmt   -- number format for values. use &#34;&#34; to chose default one
 tolM     -- tolerance to clip absolute values of M
 sf       -- scaling factor
</pre>

				
				
				
			
				
				<h3 id="Beam.Recompute">func (*Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=10005:10041#L361">Recompute</a></h3>
				<pre>func (o *<a href="#Beam">Beam</a>) Recompute(withM <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Recompute re-compute matrices after dimensions or parameters are externally changed
</p>

				
				
				
			
				
				<h3 id="Beam.SetEleConds">func (*Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=6248:6324#L200">SetEleConds</a></h3>
				<pre>func (o *<a href="#Beam">Beam</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEleConds set element conditions
</p>

				
				
				
			
				
				<h3 id="Beam.SetEqs">func (*Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=5968:6035#L187">SetEqs</a></h3>
				<pre>func (o *<a href="#Beam">Beam</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEqs set equations [2][?]. Format of eqs == format of info.Dofs
</p>

				
				
				
			
		
			
			
			<h2 id="BjointComp">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_bjointcomp.go?s=672:2391#L11">BjointComp</a></h2>
			<pre>type BjointComp struct {

    <span class="comment">// basic data</span>
    Sim    *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Simulation">Simulation</a> <span class="comment">// simulation</span>
    Cell   *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>       <span class="comment">// the cell structure</span>
    Edat   *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#ElemData">ElemData</a>   <span class="comment">// element data; stored in allocator to be used in Connect</span>
    Ny     <a href="/pkg/builtin/#int">int</a>             <span class="comment">// total number of dofs == LinNu + sld.Nu where LinNu is the number of displacement DOFs of beam == 2*Ndim</span>
    Ndim   <a href="/pkg/builtin/#int">int</a>             <span class="comment">// space dimension</span>
    TolNod <a href="/pkg/builtin/#float64">float64</a>         <span class="comment">// tolerance to find beam/solid compatible nodes</span>

    <span class="comment">// essential</span>
    Lin *<a href="#Beam">Beam</a>         <span class="comment">// beam (line) element</span>
    Sld *<a href="#ElemU">ElemU</a>        <span class="comment">// solid element</span>
    Mdl *<a href="/pkg/github.com/cpmech/gofem/mdl/sld/">sld</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/sld/#RjointM1">RjointM1</a> <span class="comment">// material model</span>

    <span class="comment">// asembly maps</span>
    LinUmap []<a href="/pkg/builtin/#int">int</a> <span class="comment">// beam umap with displacement DOFs equations only</span>
    SldUmap []<a href="/pkg/builtin/#int">int</a> <span class="comment">// solid umap with displacement DOFs at nodes connected to beam</span>

    <span class="comment">// shape and integration points</span>
    LinShp *<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Shape">Shape</a>   <span class="comment">// lin2 shape</span>
    LinIps []<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Ipoint">Ipoint</a> <span class="comment">// integration points along line of beam / joint</span>

    Δw []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [ndim] relative displacement</span>

    <span class="comment">// temporary Jacobian matrices</span>
    Kll [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [linNu][linNu] K_lin_lin: ∂fl/∂ub</span>
    Kls [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [linNu][linNu] K_lin_sld: ∂fl/∂u</span>
    Ksl [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [linNu][linNu] K_sld_lin: ∂fs/∂ub</span>
    Kss [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [linNu][linNu] K_sld_sld: ∂fs/∂u</span>

    <span class="comment">// internal values</span>
    States    []*<a href="/pkg/github.com/cpmech/gofem/mdl/sld/">sld</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/sld/#OnedState">OnedState</a> <span class="comment">// [nip] internal states</span>
    StatesBkp []*<a href="/pkg/github.com/cpmech/gofem/mdl/sld/">sld</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/sld/#OnedState">OnedState</a> <span class="comment">// [nip] backup internal states</span>
    StatesAux []*<a href="/pkg/github.com/cpmech/gofem/mdl/sld/">sld</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/sld/#OnedState">OnedState</a> <span class="comment">// [nip] backup internal states</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
BjointComp implements a beam-joint (interface/link) element for embedded beams with nodes
compatible with the nodes of the surrounding solid elements
</p>
<pre>Note: beamNu corresponds to the number of displacemetns DOFs of beam; i.e. without rotations
</pre>


			

			

			
			
			

			

			
				
				<h3 id="BjointComp.AddToKb">func (*BjointComp) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_bjointcomp.go?s=7246:7331#L242">AddToKb</a></h3>
				<pre>func (o *<a href="#BjointComp">BjointComp</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="BjointComp.AddToRhs">func (*BjointComp) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_bjointcomp.go?s=6199:6269#L194">AddToRhs</a></h3>
				<pre>func (o *<a href="#BjointComp">BjointComp</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="BjointComp.BackupIvs">func (*BjointComp) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_bjointcomp.go?s=12485:12537#L458">BackupIvs</a></h3>
				<pre>func (o *<a href="#BjointComp">BjointComp</a>) BackupIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
BackupIvs create copy of internal variables
</p>

				
				
				
			
				
				<h3 id="BjointComp.Connect">func (*BjointComp) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_bjointcomp.go?s=3488:3571#L91">Connect</a></h3>
				<pre>func (o *<a href="#BjointComp">BjointComp</a>) Connect(cid2elem []<a href="#Elem">Elem</a>, cell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>) (nnzK <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Connect connects rod/solid elements in this BjointComp
</p>

				
				
				
			
				
				<h3 id="BjointComp.Decode">func (*BjointComp) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_bjointcomp.go?s=13357:13409#L498">Decode</a></h3>
				<pre>func (o *<a href="#BjointComp">BjointComp</a>) Decode(dec <a href="#Decoder">Decoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="BjointComp.Encode">func (*BjointComp) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_bjointcomp.go?s=13233:13285#L493">Encode</a></h3>
				<pre>func (o *<a href="#BjointComp">BjointComp</a>) Encode(enc <a href="#Encoder">Encoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="BjointComp.Id">func (*BjointComp) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_bjointcomp.go?s=3378:3407#L88">Id</a></h3>
				<pre>func (o *<a href="#BjointComp">BjointComp</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="BjointComp.InterpStarVars">func (*BjointComp) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_bjointcomp.go?s=6083:6145#L189">InterpStarVars</a></h3>
				<pre>func (o *<a href="#BjointComp">BjointComp</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
InterpStarVars interpolates star variables to integration points
</p>

				
				
				
			
				
				<h3 id="BjointComp.Ipoints">func (*BjointComp) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_bjointcomp.go?s=10841:10892#L399">Ipoints</a></h3>
				<pre>func (o *<a href="#BjointComp">BjointComp</a>) Ipoints() (coords [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Ipoints returns the real coordinates of integration points [nip][ndim]
</p>

				
				
				
			
				
				<h3 id="BjointComp.OutIpCoords">func (*BjointComp) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_bjointcomp.go?s=13561:13611#L507">OutIpCoords</a></h3>
				<pre>func (o *<a href="#BjointComp">BjointComp</a>) OutIpCoords() (C [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
OutIpCoords returns the coordinates of integration points
</p>

				
				
				
			
				
				<h3 id="BjointComp.OutIpKeys">func (*BjointComp) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_bjointcomp.go?s=13795:13836#L516">OutIpKeys</a></h3>
				<pre>func (o *<a href="#BjointComp">BjointComp</a>) OutIpKeys() []<a href="/pkg/builtin/#string">string</a></pre>
				<p>
OutIpKeys returns the integration points&#39; keys
</p>

				
				
				
			
				
				<h3 id="BjointComp.OutIpVals">func (*BjointComp) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_bjointcomp.go?s=13948:14004#L521">OutIpVals</a></h3>
				<pre>func (o *<a href="#BjointComp">BjointComp</a>) OutIpVals(M *<a href="#IpsMap">IpsMap</a>, sol *<a href="#Solution">Solution</a>)</pre>
				<p>
OutIpVals returns the integration points&#39; values corresponding to keys
</p>

				
				
				
			
				
				<h3 id="BjointComp.RestoreIvs">func (*BjointComp) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_bjointcomp.go?s=12743:12796#L472">RestoreIvs</a></h3>
				<pre>func (o *<a href="#BjointComp">BjointComp</a>) RestoreIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
RestoreIvs restore internal variables from copies
</p>

				
				
				
			
				
				<h3 id="BjointComp.SetEleConds">func (*BjointComp) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_bjointcomp.go?s=5919:6001#L184">SetEleConds</a></h3>
				<pre>func (o *<a href="#BjointComp">BjointComp</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEleConds set element conditions
</p>

				
				
				
			
				
				<h3 id="BjointComp.SetEqs">func (*BjointComp) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_bjointcomp.go?s=5794:5867#L179">SetEqs</a></h3>
				<pre>func (o *<a href="#BjointComp">BjointComp</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEqs set equations
</p>

				
				
				
			
				
				<h3 id="BjointComp.SetIniIvs">func (*BjointComp) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_bjointcomp.go?s=11104:11187#L408">SetIniIvs</a></h3>
				<pre>func (o *<a href="#BjointComp">BjointComp</a>) SetIniIvs(sol *<a href="#Solution">Solution</a>, ivs map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetIniIvs sets initial ivs for given values in sol and ivs map
</p>

				
				
				
			
				
				<h3 id="BjointComp.Update">func (*BjointComp) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_bjointcomp.go?s=9539:9593#L345">Update</a></h3>
				<pre>func (o *<a href="#BjointComp">BjointComp</a>) Update(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Update perform (tangent) update
</p>

				
				
				
			
				
				<h3 id="BjointComp.Ureset">func (*BjointComp) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_bjointcomp.go?s=13025:13079#L486">Ureset</a></h3>
				<pre>func (o *<a href="#BjointComp">BjointComp</a>) Ureset(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Ureset fixes internal variables after u (displacements) have been zeroed
</p>

				
				
				
			
		
			
			
			<h2 id="ColLayer">type <a href="https://github.com/cpmech/gofem/blob/master/fem/i_porous.go?s=816:1679#L18">ColLayer</a></h2>
			<pre>type ColLayer struct {

    <span class="comment">// geometry</span>
    Tags  []<a href="/pkg/builtin/#int">int</a>   <span class="comment">// tags of cells within this layer</span>
    Zmin  <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// coordinate (elevation) at bottom of layer</span>
    Zmax  <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// coordinate (elevation) at top of layer</span>
    Elems []<a href="#Elem">Elem</a>  <span class="comment">// elements in layer</span>
    Nodes []*<a href="#Node">Node</a> <span class="comment">// nodes in layer</span>

    <span class="comment">// parameters: porous medium</span>
    SlMax <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// maximum liquid saturation; e.g. 1.0</span>
    Nf0   <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// initial (constant) porosity</span>
    RhoS0 <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// initial density of solids</span>

    <span class="comment">// parameters: total stress analysis</span>
    TotRho    <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// density for total stress analyses</span>
    TotStress <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// total stress analysis</span>

    <span class="comment">// additional data</span>
    K0   <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// coefficient to multiply effective vertical stresses and obtain horizontal effective stresses</span>
    SigV <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// state @ top of layer</span>

    <span class="comment">// auxiliary</span>
    Grav <a href="/pkg/builtin/#float64">float64</a>    <span class="comment">// gravity</span>
    Liq  *<a href="/pkg/github.com/cpmech/gofem/mdl/fld/">fld</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/fld/#Model">Model</a> <span class="comment">// liquid model</span>
    Gas  *<a href="/pkg/github.com/cpmech/gofem/mdl/fld/">fld</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/fld/#Model">Model</a> <span class="comment">// gas model</span>
}</pre>
			<p>
ColLayer holds information of one porous column layer. It computes pressures and densities
based on the following expressions (maximum liquid saturation and minimum gas saturation)
</p>
<pre>ρL  = ρL0 + Cl・(pl - pl0)   thus   dρL/dpl = Cl
ρG  = ρG0 + Cg・(pg - pg0)   thus   dρG/dpg = Cg
sl  = slmax
sg  = 1 - slmax
ρ   = nf・sl・ρL  +  nf・sg・ρG  +  (1 - nf)・ρS
ns  = 1 - nf
σV  = σV0 + ρ・g・(H - z)
</pre>


			

			

			
			
			

			

			
				
				<h3 id="ColLayer.Calc">func (ColLayer) <a href="https://github.com/cpmech/gofem/blob/master/fem/i_porous.go?s=1928:1997#L57">Calc</a></h3>
				<pre>func (o <a href="#ColLayer">ColLayer</a>) Calc(z <a href="/pkg/builtin/#float64">float64</a>) (pl, pg, ρL, ρG, ρ, σV <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Calc computes state @ level z
</p>

				
				
				
			
				
				<h3 id="ColLayer.Calc_ρ">func (ColLayer) <a href="https://github.com/cpmech/gofem/blob/master/fem/i_porous.go?s=1722:1778#L47">Calc_ρ</a></h3>
				<pre>func (o <a href="#ColLayer">ColLayer</a>) Calc_ρ(ρL, ρG <a href="/pkg/builtin/#float64">float64</a>) (ρ <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Calc_ρ computes ρ (mixture density)
</p>

				
				
				
			
		
			
			
			<h2 id="ColLayers">type <a href="https://github.com/cpmech/gofem/blob/master/fem/i_porous.go?s=8318:8344#L297">ColLayers</a></h2>
			<pre>type ColLayers []*<a href="#ColLayer">ColLayer</a></pre>
			<p>
ColLayers is a set of Layer
</p>


			

			

			
			
			

			

			
				
				<h3 id="ColLayers.Len">func (ColLayers) <a href="https://github.com/cpmech/gofem/blob/master/fem/i_porous.go?s=8374:8402#L300">Len</a></h3>
				<pre>func (o <a href="#ColLayers">ColLayers</a>) Len() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Len the length of Layers
</p>

				
				
				
			
				
				<h3 id="ColLayers.Less">func (ColLayers) <a href="https://github.com/cpmech/gofem/blob/master/fem/i_porous.go?s=8561:8599#L310">Less</a></h3>
				<pre>func (o <a href="#ColLayers">ColLayers</a>) Less(i, j <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Less compares Layers: sort from top to bottom
</p>

				
				
				
			
				
				<h3 id="ColLayers.Swap">func (ColLayers) <a href="https://github.com/cpmech/gofem/blob/master/fem/i_porous.go?s=8448:8481#L305">Swap</a></h3>
				<pre>func (o <a href="#ColLayers">ColLayers</a>) Swap(i, j <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Swap swaps two Layers
</p>

				
				
				
			
		
			
			
			<h2 id="DebugKb_t">type <a href="https://github.com/cpmech/gofem/blob/master/fem/fem.go?s=514:552#L10">DebugKb_t</a></h2>
			<pre>type DebugKb_t func(d *<a href="#Domain">Domain</a>, it <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
function to debug global Jacobian matrix
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Decoder">type <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=478:533#L15">Decoder</a></h2>
			<pre>type Decoder interface {
    Decode(e interface{}) <a href="/pkg/builtin/#error">error</a>
}</pre>
			<p>
Decoder defines decoders; e.g. gob or json
</p>


			

			

			
			
			

			
				
				<h3 id="GetDecoder">func <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=748:802#L28">GetDecoder</a></h3>
				<pre>func GetDecoder(r <a href="/pkg/io/">goio</a>.<a href="/pkg/io/#Reader">Reader</a>, enctype <a href="/pkg/builtin/#string">string</a>) <a href="#Decoder">Decoder</a></pre>
				<p>
GetDecoder returns a new decoder
</p>

				
				
			

			
		
			
			
			<h2 id="Dof">type <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=335:432#L4">Dof</a></h2>
			<pre>type Dof struct {
    Key <a href="/pkg/builtin/#string">string</a> <span class="comment">// primary variable key. e.g. &#34;ux&#34;</span>
    Eq  <a href="/pkg/builtin/#int">int</a>    <span class="comment">// equation number</span>
}</pre>
			<p>
Dof holds information about a degree-of-freedom == solution variable
</p>


			

			

			
			
			

			

			
				
				<h3 id="Dof.String">func (*Dof) <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=490:519#L10">String</a></h3>
				<pre>func (o *<a href="#Dof">Dof</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
String returns the string representation of this Dof
</p>

				
				
				
			
		
			
			
			<h2 id="Domain">type <a href="https://github.com/cpmech/gofem/blob/master/fem/domain.go?s=1765:4750#L44">Domain</a></h2>
			<pre>type Domain struct {

    <span class="comment">// init: auxiliary variables</span>
    Distr  <a href="/pkg/builtin/#bool">bool</a>            <span class="comment">// distributed/parallel run</span>
    Proc   <a href="/pkg/builtin/#int">int</a>             <span class="comment">// this processor number</span>
    Sim    *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Simulation">Simulation</a> <span class="comment">// [from FEM] input data</span>
    Reg    *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Region">Region</a>     <span class="comment">// region data</span>
    Msh    *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Mesh">Mesh</a>       <span class="comment">// mesh data</span>
    LinSol <a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#LinSol">LinSol</a>       <span class="comment">// linear solver</span>
    DynCfs *<a href="#DynCoefs">DynCoefs</a>       <span class="comment">// [from FEM] coefficients for dynamics/transient simulations</span>

    <span class="comment">// stage: nodes (active) and elements (active AND in this processor)</span>
    Nodes  []*<a href="#Node">Node</a> <span class="comment">// active nodes (for each stage). Note: indices in Nodes do NOT correpond to Ids =&gt; use Vid2node to access Nodes using Ids.</span>
    Elems  []<a href="#Elem">Elem</a>  <span class="comment">// [procNcells] only active elements in this processor (for each stage)</span>
    MyCids []<a href="/pkg/builtin/#int">int</a>   <span class="comment">// [procNcells] the ids of cells in this processor</span>

    <span class="comment">// stage: auxiliary maps for dofs and equation types</span>
    F2Y      map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#string">string</a> <span class="comment">// converts f-keys to y-keys; e.g.: &#34;ux&#34; =&gt; &#34;fx&#34;</span>
    YandC    map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#bool">bool</a>   <span class="comment">// y and constraints keys; e.g. &#34;ux&#34;, &#34;pl&#34;, &#34;H&#34;, &#34;incsup&#34;, &#34;rigid&#34;</span>
    Dof2Tnum map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#int">int</a>    <span class="comment">// {t1,t2}-types: dof =&gt; t_number; e.g. &#34;ux&#34; =&gt; 2, &#34;pl&#34; =&gt; 1</span>

    <span class="comment">// stage: auxiliary maps for nodes and elements</span>
    Vid2node   []*<a href="#Node">Node</a> <span class="comment">// [nverts] VertexId =&gt; index in Nodes. Inactive vertices are &#39;nil&#39;</span>
    Cid2elem   []<a href="#Elem">Elem</a>  <span class="comment">// [ncells] CellId =&gt; index in Elems. Cells in other processors or inactive are &#39;nil&#39;</span>
    Cid2active []<a href="/pkg/builtin/#bool">bool</a>  <span class="comment">// [ncells] CellId =&gt; whether cell is active or not in ANY processor</span>

    <span class="comment">// stage: subsets of elements</span>
    ElemIntvars   []<a href="#ElemIntvars">ElemIntvars</a>   <span class="comment">// elements with internal vars in this processor</span>
    ElemIvsCon    []<a href="#ElemIntvars">ElemIntvars</a>   <span class="comment">// elements with internal vars that are connectors</span>
    ElemIvsNotCon []<a href="#ElemIntvars">ElemIntvars</a>   <span class="comment">// elements with internal vars that are not connectors</span>
    ElemConnect   []<a href="#ElemConnector">ElemConnector</a> <span class="comment">// connector elements in this processor</span>
    ElemExtrap    []<a href="#ElemExtrap">ElemExtrap</a>    <span class="comment">// elements with internal values to be extrapolated</span>
    ElemFixedKM   []<a href="#ElemFixedKM">ElemFixedKM</a>   <span class="comment">// elements with fixed K,M matrices; to be recomputed if prms are changed</span>

    <span class="comment">// stage: coefficients and prescribed forces</span>
    EssenBcs <a href="#EssentialBcs">EssentialBcs</a> <span class="comment">// constraints (Lagrange multipliers)</span>
    PtNatBcs <a href="#PtNaturalBcs">PtNaturalBcs</a> <span class="comment">// point loads such as prescribed forces at nodes</span>

    <span class="comment">// stage: t1 and t2 variables</span>
    T1eqs []<a href="/pkg/builtin/#int">int</a> <span class="comment">// first t-derivative variables; e.g.:  dp/dt vars (subset of ykeys)</span>
    T2eqs []<a href="/pkg/builtin/#int">int</a> <span class="comment">// second t-derivative variables; e.g.: d²u/dt² vars (subset of ykeys)</span>

    <span class="comment">// stage: dimensions</span>
    NnzKb <a href="/pkg/builtin/#int">int</a> <span class="comment">// number of nonzeros in Kb matrix</span>
    Ny    <a href="/pkg/builtin/#int">int</a> <span class="comment">// total number of dofs, except λ</span>
    Nlam  <a href="/pkg/builtin/#int">int</a> <span class="comment">// total number of Lagrange multipliers</span>
    NnzA  <a href="/pkg/builtin/#int">int</a> <span class="comment">// number of nonzeros in A (constraints) matrix</span>
    Nyb   <a href="/pkg/builtin/#int">int</a> <span class="comment">// total number of equations: ny + nλ</span>

    <span class="comment">// stage: solution and linear solver</span>
    Sol      *<a href="#Solution">Solution</a>   <span class="comment">// solution state</span>
    Kb       *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a> <span class="comment">// Jacobian == dRdy</span>
    Fb       []<a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// residual == -fb</span>
    Wb       []<a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// workspace</span>
    InitLSol <a href="/pkg/builtin/#bool">bool</a>        <span class="comment">// flag telling that linear solver needs to be initialised prior to any further call</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Domain holds all Nodes and Elements active during a stage in addition to the Solution at nodes.
Only elements in this processor are recorded here; however information from
all cells might be recorded as well.
</p>


			

			

			
			
			

			

			
				
				<h3 id="Domain.Clean">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/domain.go?s=4795:4819#L105">Clean</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) Clean()</pre>
				<p>
Clean cleans memory allocated by domain
</p>

				
				
				
			
				
				<h3 id="Domain.IniSetFileFunc">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/i_filefunc.go?s=375:434#L4">IniSetFileFunc</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) IniSetFileFunc(stg *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Stage">Stage</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
IniSetFileFunc sets initial state with values given in a file or by a function
</p>

				
				
				
			
				
				<h3 id="Domain.IniSetPorous">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/i_porous.go?s=2408:2465#L76">IniSetPorous</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) IniSetPorous(stg *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Stage">Stage</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
IniSetPorous sets porous medium initial state (including geostatic or hydrostatic)
</p>

				
				
				
			
				
				<h3 id="Domain.IniSetStress">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/i_stress.go?s=359:416#L4">IniSetStress</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) IniSetStress(stg *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Stage">Stage</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
IniSetStress sets all elements with homogeneous initial stress
</p>

				
				
				
			
				
				<h3 id="Domain.Read">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=4565:4643#L178">Read</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) Read(sum *<a href="#Summary">Summary</a>, tidx, proc <a href="/pkg/builtin/#int">int</a>, allInOne <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
In performs the inverse operation of Out()
</p>
<pre>allInOne -- indicates that all results must be read into the root processor only
            For example when plotting or generating VTU files (or testing)

If allInOne is false, each processor will read its part as described by Summary.
Thus, recoreving the state as in the previous simulation.
</pre>

				
				
				
			
				
				<h3 id="Domain.ReadIvs">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=3268:3348#L128">ReadIvs</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) ReadIvs(dir, fnkey, enctype <a href="/pkg/builtin/#string">string</a>, tidx, proc <a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadIvs reads elements&#39;s internal values from a file which name is set with tidx (time output index)
</p>

				
				
				
			
				
				<h3 id="Domain.ReadSol">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=1836:1910#L71">ReadSol</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) ReadSol(dir, fnkey, enctype <a href="/pkg/builtin/#string">string</a>, tidx <a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadSol reads Solution from a file which name is set with tidx (time output index)
</p>

				
				
				
			
				
				<h3 id="Domain.RecomputeKM">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/domain.go?s=15773:15803#L536">RecomputeKM</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) RecomputeKM()</pre>
				<p>
RecomputeKM recompute K and M matrices of elements with static matrices
</p>

				
				
				
			
				
				<h3 id="Domain.Save">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=4042:4099#L162">Save</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) Save(tidx <a href="/pkg/builtin/#int">int</a>, verbose <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Out performs output of Solution and Internal values to files
</p>

				
				
				
			
				
				<h3 id="Domain.SaveIvs">func (Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=2718:2777#L105">SaveIvs</a></h3>
				<pre>func (o <a href="#Domain">Domain</a>) SaveIvs(tidx <a href="/pkg/builtin/#int">int</a>, verbose <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SaveIvs saves elements&#39;s internal values to a file which name is set with tidx (time output index)
</p>

				
				
				
			
				
				<h3 id="Domain.SaveSol">func (Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=981:1040#L36">SaveSol</a></h3>
				<pre>func (o <a href="#Domain">Domain</a>) SaveSol(tidx <a href="/pkg/builtin/#int">int</a>, verbose <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SaveSol saves solution (o.Sol) to a file which name is set with tidx (time output index)
</p>

				
				
				
			
				
				<h3 id="Domain.SetIniVals">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/domain.go?s=12789:12854#L412">SetIniVals</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) SetIniVals(stgidx <a href="/pkg/builtin/#int">int</a>, zeroSol <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetIniVals sets/resets initial values (nodes and integration points)
</p>

				
				
				
			
				
				<h3 id="Domain.SetStage">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/domain.go?s=5633:5682#L132">SetStage</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) SetStage(stgidx <a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetStage set nodes, equation numbers and auxiliary data for given stage
</p>

				
				
				
			
				
				<h3 id="Domain.UpdateElems">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/domain.go?s=14891:14933#L494">UpdateElems</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) UpdateElems() (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
UpdateElems update elements after Solution has been updated
</p>

				
				
				
			
		
			
			
			<h2 id="DynCoefs">type <a href="https://github.com/cpmech/gofem/blob/master/fem/dyncoefs.go?s=677:880#L11">DynCoefs</a></h2>
			<pre>type DynCoefs struct {
    HHT <a href="/pkg/builtin/#bool">bool</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
DynCoefs calculates θ-method, Newmark&#39;s or HHT coefficients.
</p>
<pre>Notes:
 θ1  -- Newmark parameter (gamma)  [0 &lt;= θ1 &lt;= 1]
 θ2  -- Newmark parameter (2*beta) [0 &lt;= θ2 &lt;= 1]
 HHT -- use Hilber-Hughes-Taylor method ?
 α   -- Hilber-Hughes-Taylor parameter [-1/3 &lt;= α &lt;= 0]
 if HHT==True, θ1 and θ2 are automatically calculated for unconditional stability
</pre>


			

			

			
			
			

			

			
				
				<h3 id="DynCoefs.CalcAlphas">func (*DynCoefs) <a href="https://github.com/cpmech/gofem/blob/master/fem/dyncoefs.go?s=2261:2315#L87">CalcAlphas</a></h3>
				<pre>func (o *<a href="#DynCoefs">DynCoefs</a>) CalcAlphas(Δt <a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
CalcAlphas computes only alphas
</p>

				
				
				
			
				
				<h3 id="DynCoefs.CalcBetas">func (*DynCoefs) <a href="https://github.com/cpmech/gofem/blob/master/fem/dyncoefs.go?s=1959:2012#L72">CalcBetas</a></h3>
				<pre>func (o *<a href="#DynCoefs">DynCoefs</a>) CalcBetas(Δt <a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
CalcBetas computes only betas
</p>

				
				
				
			
				
				<h3 id="DynCoefs.CalcBoth">func (*DynCoefs) <a href="https://github.com/cpmech/gofem/blob/master/fem/dyncoefs.go?s=1782:1834#L62">CalcBoth</a></h3>
				<pre>func (o *<a href="#DynCoefs">DynCoefs</a>) CalcBoth(Δt <a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
CalcBoth computes betas and alphas
</p>

				
				
				
			
				
				<h3 id="DynCoefs.Init">func (*DynCoefs) <a href="https://github.com/cpmech/gofem/blob/master/fem/dyncoefs.go?s=917:961#L26">Init</a></h3>
				<pre>func (o *<a href="#DynCoefs">DynCoefs</a>) Init(dat *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#SolverData">SolverData</a>)</pre>
				<p>
Init initialises this structure
</p>

				
				
				
			
				
				<h3 id="DynCoefs.Print">func (*DynCoefs) <a href="https://github.com/cpmech/gofem/blob/master/fem/dyncoefs.go?s=2781:2807#L110">Print</a></h3>
				<pre>func (o *<a href="#DynCoefs">DynCoefs</a>) Print()</pre>
				<p>
Print prints coefficients
</p>

				
				
				
			
		
			
			
			<h2 id="EbcArray">type <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=1249:1277#L30">EbcArray</a></h2>
			<pre>type EbcArray []*<a href="#EssentialBc">EssentialBc</a></pre>
			<p>
EbcArray is an array of EssentialBc&#39;s
</p>


			

			

			
			
			

			

			
				
				<h3 id="EbcArray.Len">func (EbcArray) <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=8057:8084#L286">Len</a></h3>
				<pre>func (o <a href="#EbcArray">EbcArray</a>) Len() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
functions to implement Sort interface
</p>

				
				
				
			
				
				<h3 id="EbcArray.Less">func (EbcArray) <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=8169:8206#L288">Less</a></h3>
				<pre>func (o <a href="#EbcArray">EbcArray</a>) Less(i, j <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="EbcArray.Swap">func (EbcArray) <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=8108:8140#L287">Swap</a></h3>
				<pre>func (o <a href="#EbcArray">EbcArray</a>) Swap(i, j <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
				
			
		
			
			
			<h2 id="ElastRod">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=584:1408#L11">ElastRod</a></h2>
			<pre>type ElastRod struct {

    <span class="comment">// basic data</span>
    Cell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>   <span class="comment">// the cell structure</span>
    X    [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// matrix of nodal coordinates [ndim][nnode]</span>
    Nu   <a href="/pkg/builtin/#int">int</a>         <span class="comment">// total number of unknowns == 2 * nsn</span>
    Ndim <a href="/pkg/builtin/#int">int</a>         <span class="comment">// space dimension</span>

    <span class="comment">// parameters and properties</span>
    Mdl *<a href="/pkg/github.com/cpmech/gofem/mdl/sld/">sld</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/sld/#OnedLinElast">OnedLinElast</a> <span class="comment">// material model with: E, G, A, I22, I11, Jtt and Rho</span>
    L   <a href="/pkg/builtin/#float64">float64</a>           <span class="comment">// length of rod</span>

    <span class="comment">// variables for dynamics</span>
    Gfcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// gravity function</span>

    <span class="comment">// vectors and matrices</span>
    T [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [ndim][nu] transformation matrix: system aligned to rod =&gt; element system</span>
    K [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nu][nu] element K matrix</span>
    M [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nu][nu] element M matrix</span>

    <span class="comment">// problem variables</span>
    Umap []<a href="/pkg/builtin/#int">int</a> <span class="comment">// assembly map (location array/element equations)</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
ElastRod represents a structural rod element (for axial loads only) with 2 nodes only and
simply implemented with constant stiffness matrix; i.e. no numerical integration is needed
</p>


			

			

			
			
			

			

			
				
				<h3 id="ElastRod.AddToKb">func (*ElastRod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=4637:4720#L175">AddToKb</a></h3>
				<pre>func (o *<a href="#ElastRod">ElastRod</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AddToKb adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="ElastRod.AddToRhs">func (*ElastRod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=4396:4464#L165">AddToRhs</a></h3>
				<pre>func (o *<a href="#ElastRod">ElastRod</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AddToRhs adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="ElastRod.CalcSig">func (*ElastRod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=5855:5904#L218">CalcSig</a></h3>
				<pre>func (o *<a href="#ElastRod">ElastRod</a>) CalcSig(sol *<a href="#Solution">Solution</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
CalcSig computes the axial stress for given nodal displacements
</p>

				
				
				
			
				
				<h3 id="ElastRod.Decode">func (*ElastRod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=5070:5120#L192">Decode</a></h3>
				<pre>func (o *<a href="#ElastRod">ElastRod</a>) Decode(dec <a href="#Decoder">Decoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElastRod.Encode">func (*ElastRod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=4965:5015#L187">Encode</a></h3>
				<pre>func (o *<a href="#ElastRod">ElastRod</a>) Encode(enc <a href="#Encoder">Encoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElastRod.Id">func (*ElastRod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=3623:3650#L134">Id</a></h3>
				<pre>func (o *<a href="#ElastRod">ElastRod</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="ElastRod.InterpStarVars">func (*ElastRod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=3989:4049#L149">InterpStarVars</a></h3>
				<pre>func (o *<a href="#ElastRod">ElastRod</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
InterpStarVars interpolates star variables to integration points
</p>

				
				
				
			
				
				<h3 id="ElastRod.OutIpCoords">func (*ElastRod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=5199:5247#L197">OutIpCoords</a></h3>
				<pre>func (o *<a href="#ElastRod">ElastRod</a>) OutIpCoords() (C [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
OutIpCoords returns the coordinates of integration points
</p>

				
				
				
			
				
				<h3 id="ElastRod.OutIpKeys">func (*ElastRod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=5446:5485#L206">OutIpKeys</a></h3>
				<pre>func (o *<a href="#ElastRod">ElastRod</a>) OutIpKeys() []<a href="/pkg/builtin/#string">string</a></pre>
				<p>
OutIpKeys returns the integration points&#39; keys
</p>

				
				
				
			
				
				<h3 id="ElastRod.OutIpVals">func (*ElastRod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=5589:5643#L211">OutIpVals</a></h3>
				<pre>func (o *<a href="#ElastRod">ElastRod</a>) OutIpVals(M *<a href="#IpsMap">IpsMap</a>, sol *<a href="#Solution">Solution</a>)</pre>
				<p>
OutIpVals returns the integration points&#39; values corresponding to keys
</p>

				
				
				
			
				
				<h3 id="ElastRod.Recompute">func (*ElastRod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=6311:6351#L232">Recompute</a></h3>
				<pre>func (o *<a href="#ElastRod">ElastRod</a>) Recompute(withM <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Recompute re-compute matrices after dimensions or parameters are externally changed
</p>

				
				
				
			
				
				<h3 id="ElastRod.SetEleConds">func (*ElastRod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=4170:4250#L156">SetEleConds</a></h3>
				<pre>func (o *<a href="#ElastRod">ElastRod</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEleConds set element conditions
</p>

				
				
				
			
				
				<h3 id="ElastRod.SetEqs">func (*ElastRod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=3697:3768#L137">SetEqs</a></h3>
				<pre>func (o *<a href="#ElastRod">ElastRod</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEqs set equations
</p>

				
				
				
			
		
			
			
			<h2 id="Elem">type <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=1341:2224#L40">Elem</a></h2>
			<pre>type Elem interface {

    <span class="comment">// information and initialisation</span>
    Id() <a href="/pkg/builtin/#int">int</a>                                             <span class="comment">// returns the cell Id</span>
    SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>) <span class="comment">// set equations</span>

    <span class="comment">// conditions (natural BCs and element&#39;s)</span>
    SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>) <span class="comment">// set element conditions</span>

    <span class="comment">// called for each time step</span>
    InterpStarVars(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>) <span class="comment">// interpolate star variables to integration points</span>

    <span class="comment">// called for each iteration</span>
    AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)                <span class="comment">// adds -R to global residual vector fb</span>
    AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>) <span class="comment">// adds element K to global Jacobian matrix Kb</span>

    <span class="comment">// reading and writing of element data</span>
    Encode(enc <a href="#Encoder">Encoder</a>) (err <a href="/pkg/builtin/#error">error</a>) <span class="comment">// encodes internal variables</span>
    Decode(dec <a href="#Decoder">Decoder</a>) (err <a href="/pkg/builtin/#error">error</a>) <span class="comment">// decodes internal variables</span>
}</pre>
			<p>
Elem defines what all elements must compute
</p>


			

			

			
			
			

			
				
				<h3 id="NewElem">func <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=5507:5595#L136">NewElem</a></h3>
				<pre>func NewElem(cell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>, reg *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Region">Region</a>, sim *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Simulation">Simulation</a>) (ele <a href="#Elem">Elem</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
NewElem returns a new element from its type; e.g. &#34;p&#34;, &#34;u&#34; or &#34;up&#34;
</p>

				
				
			

			
		
			
			
			<h2 id="ElemConnector">type <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=3080:3331#L72">ElemConnector</a></h2>
			<pre>type ElemConnector interface {
    Id() <a href="/pkg/builtin/#int">int</a>                                                    <span class="comment">// returns the cell Id</span>
    Connect(cid2elem []<a href="#Elem">Elem</a>, c *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>) (nnzK <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>) <span class="comment">// connect multiple elements; e.g.: connect rod/solid elements in Rjoints</span>
}</pre>
			<p>
ElemConnector defines connector elements; elements that depend upon others
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="ElemExtrap">type <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=3410:3520#L78">ElemExtrap</a></h2>
			<pre>type ElemExtrap interface {
    AddToExt(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>) <span class="comment">// adds extrapolated values to global array</span>
}</pre>
			<p>
ElemExtrap defines elements with functions to extrapolate internal values
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="ElemFixedKM">type <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=4026:4100#L91">ElemFixedKM</a></h2>
			<pre>type ElemFixedKM interface {
    Recompute(withM <a href="/pkg/builtin/#bool">bool</a>) <span class="comment">// recompute K and M</span>
}</pre>
			<p>
ElemFixedKM defines elements with fixed K,M matrices; to be recomputed if prms are changed
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="ElemIntvars">type <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=2288:3000#L62">ElemIntvars</a></h2>
			<pre>type ElemIntvars interface {
    Update(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)                              <span class="comment">// perform (tangent) update</span>
    Ipoints() (coords [][]<a href="/pkg/builtin/#float64">float64</a>)                                 <span class="comment">// returns the real coordinates of integration points [nip][ndim]</span>
    SetIniIvs(sol *<a href="#Solution">Solution</a>, ivs map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>) <span class="comment">// sets initial ivs for given values in sol and ivs map</span>
    BackupIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)                                <span class="comment">// create copy of internal variables</span>
    RestoreIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)                               <span class="comment">// restore internal variables from copies</span>
    Ureset(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)                              <span class="comment">// fixes internal variables after u (displacements) have been zeroed</span>
}</pre>
			<p>
ElemIntvars defines elements with {z,q} internal variables
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="ElemOutIps">type <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=3596:3930#L83">ElemOutIps</a></h2>
			<pre>type ElemOutIps interface {
    Id() <a href="/pkg/builtin/#int">int</a>                            <span class="comment">// returns the cell Id</span>
    OutIpCoords() [][]<a href="/pkg/builtin/#float64">float64</a>           <span class="comment">// coordinates of integration points</span>
    OutIpKeys() []<a href="/pkg/builtin/#string">string</a>                <span class="comment">// integration points&#39; keys; e.g. &#34;pl&#34;, &#34;sl&#34;</span>
    OutIpVals(M *<a href="#IpsMap">IpsMap</a>, sol *<a href="#Solution">Solution</a>) <span class="comment">// integration points&#39; values corresponding to keys</span>
}</pre>
			<p>
ElemOutIps defines elements that can output integration points&#39; values
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="ElemP">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=757:3335#L16">ElemP</a></h2>
			<pre>type ElemP struct {

    <span class="comment">// basic data</span>
    Cell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>   <span class="comment">// the cell structure</span>
    X    [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// matrix of nodal coordinates [ndim][nnode]</span>
    Np   <a href="/pkg/builtin/#int">int</a>         <span class="comment">// total number of unknowns == number of vertices</span>
    Ndim <a href="/pkg/builtin/#int">int</a>         <span class="comment">// space dimension</span>

    <span class="comment">// integration points</span>
    IpsElem []<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Ipoint">Ipoint</a> <span class="comment">// integration points of element</span>
    IpsFace []<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Ipoint">Ipoint</a> <span class="comment">// integration points corresponding to faces</span>

    <span class="comment">// material model</span>
    Mdl *<a href="/pkg/github.com/cpmech/gofem/mdl/por/">por</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/por/#Model">Model</a> <span class="comment">// model</span>

    <span class="comment">// problem variables</span>
    Pmap []<a href="/pkg/builtin/#int">int</a> <span class="comment">// assembly map (location array/element equations)</span>

    <span class="comment">// internal variables</span>
    States    []*<a href="/pkg/github.com/cpmech/gofem/mdl/por/">por</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/por/#State">State</a>
    StatesBkp []*<a href="/pkg/github.com/cpmech/gofem/mdl/por/">por</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/por/#State">State</a>
    StatesAux []*<a href="/pkg/github.com/cpmech/gofem/mdl/por/">por</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/por/#State">State</a>

    <span class="comment">// gravity</span>
    Gfcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// gravity function</span>

    <span class="comment">// natural boundary conditions</span>
    NatBcs []*<a href="#NaturalBc">NaturalBc</a> <span class="comment">// natural boundary conditions</span>

    Emat     [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nverts][nips] extrapolator matrix</span>
    DoExtrap <a href="/pkg/builtin/#bool">bool</a>        <span class="comment">// do extrapolation of ρl and Cpl =&gt; for use with flux and seepage conditions</span>

    <span class="comment">// seepage face</span>
    Nf         <a href="/pkg/builtin/#int">int</a>   <span class="comment">// number of fl variables</span>
    HasSeep    <a href="/pkg/builtin/#bool">bool</a>  <span class="comment">// indicates if this element has seepage faces</span>
    Vid2seepId []<a href="/pkg/builtin/#int">int</a> <span class="comment">// [nverts] maps local vertex id to index in Fmap</span>
    SeepId2vid []<a href="/pkg/builtin/#int">int</a> <span class="comment">// [nf] maps seepage face variable id to local vertex id</span>
    Fmap       []<a href="/pkg/builtin/#int">int</a> <span class="comment">// [nf] map of &#34;fl&#34; variables (seepage face)</span>
    Macaulay   <a href="/pkg/builtin/#bool">bool</a>  <span class="comment">// use discrete ramp function instead of smooth ramp</span>

    Hst   []<a href="/pkg/builtin/#bool">bool</a>      <span class="comment">// [nf] set hydrostatic plmax</span>
    Plmax [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nf][nipsFace] specified plmax (not corrected by multiplier)</span>

    Kpp [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [np][np] Kpp := dRpl/dpl consistent tangent matrix</span>
    Kpf [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [np][nf] Kpf := dRpl/dfl consistent tangent matrix</span>
    Kfp [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nf][np] Kfp := dRfl/dpl consistent tangent matrix</span>
    Kff [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nf][nf] Kff := dRfl/dfl consistent tangent matrix</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
ElemP implements an element for transient seepage analyses [1]
</p>
<pre>References:
 [1] Pedroso DM (2015) A solution to transient seepage in unsaturated porous media.
     Computer Methods in Applied Mechanics and Engineering, 285 791-816,
     <a href="http://dx.doi.org/10.1016/j.cma.2014.12.009">http://dx.doi.org/10.1016/j.cma.2014.12.009</a>
</pre>


			

			

			
			
			

			

			
				
				<h3 id="ElemP.AddToKb">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=9678:9758#L335">AddToKb</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AddToKb adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="ElemP.AddToRhs">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=8220:8285#L273">AddToRhs</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AddToRhs adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="ElemP.BackupIvs">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=14780:14827#L558">BackupIvs</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) BackupIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
BackupIvs creates copy of internal variables
</p>

				
				
				
			
				
				<h3 id="ElemP.Decode">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=15633:15680#L598">Decode</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) Decode(dec <a href="#Decoder">Decoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemP.Encode">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=15514:15561#L593">Encode</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) Encode(enc <a href="#Encoder">Encoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemP.Id">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=7182:7206#L227">Id</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="ElemP.InterpStarVars">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=7758:7815#L252">InterpStarVars</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
InterpStarVars interpolates star variables to integration points
</p>

				
				
				
			
				
				<h3 id="ElemP.Ipoints">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=12732:12778#L469">Ipoints</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) Ipoints() (coords [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Ipoints returns the real coordinates of integration points [nip][ndim]
</p>

				
				
				
			
				
				<h3 id="ElemP.OutIpCoords">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=15832:15877#L607">OutIpCoords</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) OutIpCoords() (C [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
OutIpCoords returns the coordinates of integration points
</p>

				
				
				
			
				
				<h3 id="ElemP.OutIpKeys">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=16061:16097#L616">OutIpKeys</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) OutIpKeys() []<a href="/pkg/builtin/#string">string</a></pre>
				<p>
OutIpKeys returns the integration points&#39; keys
</p>

				
				
				
			
				
				<h3 id="ElemP.OutIpVals">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=16238:16289#L621">OutIpVals</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) OutIpVals(M *<a href="#IpsMap">IpsMap</a>, sol *<a href="#Solution">Solution</a>)</pre>
				<p>
OutIpVals returns the integration points&#39; values corresponding to keys
</p>

				
				
				
			
				
				<h3 id="ElemP.RestoreIvs">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=15034:15082#L572">RestoreIvs</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) RestoreIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
RestoreIvs restores internal variables from copies
</p>

				
				
				
			
				
				<h3 id="ElemP.SetEleConds">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=7555:7632#L244">SetEleConds</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEleConds sets element conditions
</p>

				
				
				
			
				
				<h3 id="ElemP.SetEqs">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=7254:7322#L230">SetEqs</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEqs sets equations
</p>

				
				
				
			
				
				<h3 id="ElemP.SetIniIvs">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=12990:13072#L478">SetIniIvs</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) SetIniIvs(sol *<a href="#Solution">Solution</a>, ignored map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetIniIvs sets initial ivs for given values in sol and ivs map
</p>

				
				
				
			
				
				<h3 id="ElemP.Update">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=11951:12000#L437">Update</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) Update(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Update performs (tangent) update
</p>

				
				
				
			
				
				<h3 id="ElemP.Ureset">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=15311:15360#L586">Ureset</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) Ureset(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Ureset fixes internal variables after u (displacements) have been zeroed
</p>

				
				
				
			
		
			
			
			<h2 id="ElemPP">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_pp.go?s=518:3922#L12">ElemPP</a></h2>
			<pre>type ElemPP struct {

    <span class="comment">// basic data</span>
    Cell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>   <span class="comment">// the cell structure</span>
    X    [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// matrix of nodal coordinates [ndim][nnode]</span>
    Np   <a href="/pkg/builtin/#int">int</a>         <span class="comment">// number of vertices == number of pl or pg</span>
    Ndim <a href="/pkg/builtin/#int">int</a>         <span class="comment">// space dimension</span>

    <span class="comment">// integration points</span>
    IpsElem []<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Ipoint">Ipoint</a> <span class="comment">// integration points of element</span>
    IpsFace []<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Ipoint">Ipoint</a> <span class="comment">// integration points corresponding to faces</span>

    <span class="comment">// material model</span>
    Mdl *<a href="/pkg/github.com/cpmech/gofem/mdl/por/">por</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/por/#Model">Model</a> <span class="comment">// model</span>

    <span class="comment">// problem variables</span>
    Plmap []<a href="/pkg/builtin/#int">int</a> <span class="comment">// assembly map -- liquid pressure</span>
    Pgmap []<a href="/pkg/builtin/#int">int</a> <span class="comment">// assembly map -- gas pressure</span>

    <span class="comment">// internal variables</span>
    States    []*<a href="/pkg/github.com/cpmech/gofem/mdl/por/">por</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/por/#State">State</a>
    StatesBkp []*<a href="/pkg/github.com/cpmech/gofem/mdl/por/">por</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/por/#State">State</a>
    StatesAux []*<a href="/pkg/github.com/cpmech/gofem/mdl/por/">por</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/por/#State">State</a>

    <span class="comment">// gravity</span>
    Gfcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// gravity function</span>

    <span class="comment">// natural boundary conditions</span>
    NatBcs []*<a href="#NaturalBc">NaturalBc</a> <span class="comment">// natural boundary conditions</span>

    Emat     [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nverts][nips] extrapolator matrix</span>
    DoExtrap <a href="/pkg/builtin/#bool">bool</a>        <span class="comment">// do extrapolation of ρl and Cpl =&gt; for use with flux and seepage conditions</span>

    <span class="comment">// seepage face</span>
    Nf         <a href="/pkg/builtin/#int">int</a>   <span class="comment">// number of fl variables</span>
    HasSeep    <a href="/pkg/builtin/#bool">bool</a>  <span class="comment">// indicates if this element has seepage faces</span>
    Vid2seepId []<a href="/pkg/builtin/#int">int</a> <span class="comment">// [nverts] maps local vertex id to index in Fmap</span>
    SeepId2vid []<a href="/pkg/builtin/#int">int</a> <span class="comment">// [nf] maps seepage face variable id to local vertex id</span>
    Flmap      []<a href="/pkg/builtin/#int">int</a> <span class="comment">// [nf] map of &#34;fl&#34; variables (seepage face)</span>
    Macaulay   <a href="/pkg/builtin/#bool">bool</a>  <span class="comment">// use discrete ramp function instead of smooth ramp</span>

    Hst   []<a href="/pkg/builtin/#bool">bool</a>      <span class="comment">// [nf] set hydrostatic plmax</span>
    Plmax [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nf][nipsFace] specified plmax (not corrected by multiplier)</span>

    Kll [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [np][np] dRpl/dpl consistent tangent matrix</span>
    Klg [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [np][np] dRpl/dpg consistent tangent matrix</span>
    Kgl [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [np][np] dRpg/dpl consistent tangent matrix</span>
    Kgg [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [np][np] dRpg/dpg consistent tangent matrix</span>
    Klf [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [np][nf] dRpl/dfl consistent tangent matrix</span>
    Kfl [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nf][np] dRfl/dpl consistent tangent matrix</span>
    Kff [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nf][nf] dRfl/dfl consistent tangent matrix</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
ElemPP implements an element for liquid-gas flow analyses
</p>


			

			

			
			
			

			

			
				
				<h3 id="ElemPP.AddToKb">func (*ElemPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_pp.go?s=11238:11319#L368">AddToKb</a></h3>
				<pre>func (o *<a href="#ElemPP">ElemPP</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AddToKb adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="ElemPP.AddToRhs">func (*ElemPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_pp.go?s=9381:9447#L296">AddToRhs</a></h3>
				<pre>func (o *<a href="#ElemPP">ElemPP</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AddToRhs adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="ElemPP.BackupIvs">func (*ElemPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_pp.go?s=18485:18533#L650">BackupIvs</a></h3>
				<pre>func (o *<a href="#ElemPP">ElemPP</a>) BackupIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
BackupIvs creates copy of internal variables
</p>

				
				
				
			
				
				<h3 id="ElemPP.Decode">func (*ElemPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_pp.go?s=19342:19390#L690">Decode</a></h3>
				<pre>func (o *<a href="#ElemPP">ElemPP</a>) Decode(dec <a href="#Decoder">Decoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemPP.Encode">func (*ElemPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_pp.go?s=19222:19270#L685">Encode</a></h3>
				<pre>func (o *<a href="#ElemPP">ElemPP</a>) Encode(enc <a href="#Encoder">Encoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemPP.Id">func (*ElemPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_pp.go?s=8211:8236#L247">Id</a></h3>
				<pre>func (o *<a href="#ElemPP">ElemPP</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="ElemPP.InterpStarVars">func (*ElemPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_pp.go?s=8847:8905#L274">InterpStarVars</a></h3>
				<pre>func (o *<a href="#ElemPP">ElemPP</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
InterpStarVars interpolates star variables to integration points
</p>

				
				
				
			
				
				<h3 id="ElemPP.Ipoints">func (*ElemPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_pp.go?s=16118:16165#L554">Ipoints</a></h3>
				<pre>func (o *<a href="#ElemPP">ElemPP</a>) Ipoints() (coords [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Ipoints returns the real coordinates of integration points [nip][ndim]
</p>

				
				
				
			
				
				<h3 id="ElemPP.OutIpCoords">func (*ElemPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_pp.go?s=19542:19588#L699">OutIpCoords</a></h3>
				<pre>func (o *<a href="#ElemPP">ElemPP</a>) OutIpCoords() (C [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
OutIpCoords returns the coordinates of integration points
</p>

				
				
				
			
				
				<h3 id="ElemPP.OutIpKeys">func (*ElemPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_pp.go?s=19772:19809#L708">OutIpKeys</a></h3>
				<pre>func (o *<a href="#ElemPP">ElemPP</a>) OutIpKeys() []<a href="/pkg/builtin/#string">string</a></pre>
				<p>
OutIpKeys returns the integration points&#39; keys
</p>

				
				
				
			
				
				<h3 id="ElemPP.OutIpVals">func (*ElemPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_pp.go?s=20002:20054#L714">OutIpVals</a></h3>
				<pre>func (o *<a href="#ElemPP">ElemPP</a>) OutIpVals(M *<a href="#IpsMap">IpsMap</a>, sol *<a href="#Solution">Solution</a>)</pre>
				<p>
OutIpVals returns the integration points&#39; values corresponding to keys
</p>

				
				
				
			
				
				<h3 id="ElemPP.RestoreIvs">func (*ElemPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_pp.go?s=18740:18789#L664">RestoreIvs</a></h3>
				<pre>func (o *<a href="#ElemPP">ElemPP</a>) RestoreIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
RestoreIvs restores internal variables from copies
</p>

				
				
				
			
				
				<h3 id="ElemPP.SetEleConds">func (*ElemPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_pp.go?s=8643:8721#L266">SetEleConds</a></h3>
				<pre>func (o *<a href="#ElemPP">ElemPP</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEleConds sets element conditions
</p>

				
				
				
			
				
				<h3 id="ElemPP.SetEqs">func (*ElemPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_pp.go?s=8284:8353#L250">SetEqs</a></h3>
				<pre>func (o *<a href="#ElemPP">ElemPP</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEqs sets equations
</p>

				
				
				
			
				
				<h3 id="ElemPP.SetIniIvs">func (*ElemPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_pp.go?s=16518:16601#L565">SetIniIvs</a></h3>
				<pre>func (o *<a href="#ElemPP">ElemPP</a>) SetIniIvs(sol *<a href="#Solution">Solution</a>, ignored map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetIniIvs sets initial ivs for given values in sol and ivs map
</p>
<pre>Note: this function assumes a hydrostatic fully saturated initial condition, thus:
      sl=1, krl=1, wlb=0  sg=0, krg=krgMin, wgb=0
</pre>

				
				
				
			
				
				<h3 id="ElemPP.Update">func (*ElemPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_pp.go?s=15194:15244#L519">Update</a></h3>
				<pre>func (o *<a href="#ElemPP">ElemPP</a>) Update(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Update performs (tangent) update
</p>

				
				
				
			
				
				<h3 id="ElemPP.Ureset">func (*ElemPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_pp.go?s=19018:19068#L678">Ureset</a></h3>
				<pre>func (o *<a href="#ElemPP">ElemPP</a>) Ureset(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Ureset fixes internal variables after u (displacements) have been zeroed
</p>

				
				
				
			
		
			
			
			<h2 id="ElemPhi">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=529:1114#L10">ElemPhi</a></h2>
			<pre>type ElemPhi struct {

    <span class="comment">// basic data</span>
    Cell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>   <span class="comment">// the cell structure</span>
    X    [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [ndim][nnode] matrix of nodal coordinates</span>
    Nu   <a href="/pkg/builtin/#int">int</a>         <span class="comment">// total number of unknowns == number of vertices</span>
    Ndim <a href="/pkg/builtin/#int">int</a>         <span class="comment">// space dimension</span>

    <span class="comment">// integration points</span>
    IpsElem []<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Ipoint">Ipoint</a> <span class="comment">// [nip] integration points of element</span>

    <span class="comment">// scratchpad. computed @ each ip</span>
    K [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nu][nu] consistent tangent matrix</span>

    <span class="comment">// problem variables</span>
    Umap []<a href="/pkg/builtin/#int">int</a> <span class="comment">// assembly map (location array/element equations)</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
ElemPhi implementes a general element to solve the following equation
</p>
<pre>dφ       ∂φ
-- + v . -- = s(x)
dt       ∂x
</pre>
<p>
Notes: v is a constant vector
</p>


			

			

			
			
			

			

			
				
				<h3 id="ElemPhi.AddToKb">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=4169:4251#L163">AddToKb</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AddToKb adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="ElemPhi.AddToRhs">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=3319:3386#L126">AddToRhs</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AddToRhs adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="ElemPhi.Decode">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=5148:5197#L210">Decode</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) Decode(dec <a href="#Decoder">Decoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemPhi.Encode">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=5048:5097#L205">Encode</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) Encode(enc <a href="#Encoder">Encoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemPhi.Id">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=2429:2455#L88">Id</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="ElemPhi.InterpStarVars">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=2868:2927#L105">InterpStarVars</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
InterpStarVars interpolate star variables to integration points
</p>

				
				
				
			
				
				<h3 id="ElemPhi.OutIpCoords">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=5272:5319#L215">OutIpCoords</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) OutIpCoords() (C [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
OutIpCoords returns the coordinates of integration points
</p>

				
				
				
			
				
				<h3 id="ElemPhi.OutIpKeys">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=5503:5541#L224">OutIpKeys</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) OutIpKeys() []<a href="/pkg/builtin/#string">string</a></pre>
				<p>
OutIpKeys returns the integration points&#39; keys
</p>

				
				
				
			
				
				<h3 id="ElemPhi.OutIpVals">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=5722:5775#L232">OutIpVals</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) OutIpVals(M *<a href="#IpsMap">IpsMap</a>, sol *<a href="#Solution">Solution</a>)</pre>
				<p>
OutIpVals returns the integration points&#39; values corresponding to keys
</p>

				
				
				
			
				
				<h3 id="ElemPhi.SetEleConds">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=2708:2787#L100">SetEleConds</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEleConds set element conditions
</p>

				
				
				
			
				
				<h3 id="ElemPhi.SetEqs">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=2502:2572#L91">SetEqs</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEqs set equations
</p>

				
				
				
			
		
			
			
			<h2 id="ElemU">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=526:4161#L10">ElemU</a></h2>
			<pre>type ElemU struct {

    <span class="comment">// basic data</span>
    Cell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>   <span class="comment">// the cell structure</span>
    X    [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// matrix of nodal coordinates [ndim][nnode]</span>
    Nu   <a href="/pkg/builtin/#int">int</a>         <span class="comment">// total number of unknowns</span>
    Ndim <a href="/pkg/builtin/#int">int</a>         <span class="comment">// space dimension</span>

    <span class="comment">// variables for dynamics</span>
    Cdam <a href="/pkg/builtin/#float64">float64</a>  <span class="comment">// coefficient for damping // TODO: read this value</span>
    Gfcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// gravity function</span>

    <span class="comment">// optional data</span>
    UseB      <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// use B matrix</span>
    Thickness <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// thickness</span>
    Debug     <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// debugging flag</span>

    <span class="comment">// integration points</span>
    IpsElem []<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Ipoint">Ipoint</a> <span class="comment">// integration points of element</span>
    IpsFace []<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Ipoint">Ipoint</a> <span class="comment">// integration points corresponding to faces</span>

    <span class="comment">// material model and internal variables</span>
    Mdl      <a href="/pkg/github.com/cpmech/gofem/mdl/sld/">sld</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/sld/#Model">Model</a> <span class="comment">// material model</span>
    MdlSmall <a href="/pkg/github.com/cpmech/gofem/mdl/sld/">sld</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/sld/#Small">Small</a> <span class="comment">// model specialisation for small strains</span>
    MdlLarge <a href="/pkg/github.com/cpmech/gofem/mdl/sld/">sld</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/sld/#Large">Large</a> <span class="comment">// model specialisation for large deformations</span>

    <span class="comment">// internal variables</span>
    States    []*<a href="/pkg/github.com/cpmech/gofem/mdl/sld/">sld</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/sld/#State">State</a> <span class="comment">// [nip] states</span>
    StatesBkp []*<a href="/pkg/github.com/cpmech/gofem/mdl/sld/">sld</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/sld/#State">State</a> <span class="comment">// [nip] backup states</span>
    StatesAux []*<a href="/pkg/github.com/cpmech/gofem/mdl/sld/">sld</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/sld/#State">State</a> <span class="comment">// [nip] auxiliary backup states</span>

    <span class="comment">// additional variables</span>
    Umap   []<a href="/pkg/builtin/#int">int</a>        <span class="comment">// assembly map (location array/element equations)</span>
    NatBcs []*<a href="#NaturalBc">NaturalBc</a> <span class="comment">// natural boundary conditions</span>
    Emat   [][]<a href="/pkg/builtin/#float64">float64</a>  <span class="comment">// [nvert][nip] extrapolator matrix; if AddToExt is called</span>

    K [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nu][nu] consistent tangent (stiffness) matrix</span>
    B [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nsig][nu] B matrix for axisymetric case</span>
    D [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nsig][nsig] constitutive consistent tangent matrix</span>

    Δε []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// incremental strains leading to updated strains</span>

    <span class="comment">// contact (see e_u_contact.go)</span>
    Nq            <a href="/pkg/builtin/#int">int</a>   <span class="comment">// number of qb variables</span>
    HasContact    <a href="/pkg/builtin/#bool">bool</a>  <span class="comment">// indicates if this element has contact faces</span>
    Vid2contactId []<a href="/pkg/builtin/#int">int</a> <span class="comment">// [nverts] maps local vertex id to index in Qmap</span>
    ContactId2vid []<a href="/pkg/builtin/#int">int</a> <span class="comment">// [nq] maps contact face variable id to local vertex id</span>
    Qmap          []<a href="/pkg/builtin/#int">int</a> <span class="comment">// [nq] map of &#34;qb&#34; variables (contact face)</span>
    Macaulay      <a href="/pkg/builtin/#bool">bool</a>  <span class="comment">// contact: use discrete ramp function instead of smooth ramp</span>

    Kuq [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nu][nq] Kuq := dRu/dq consistent tangent matrix</span>
    Kqu [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nq][nu] Kqu := dRq/du consistent tangent matrix</span>
    Kqq [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nq][nq] Kqq := dRq/dq consistent tangent matrix</span>

    <span class="comment">// XFEM (material interface or not)</span>
    Xmat <a href="/pkg/builtin/#bool">bool</a>        <span class="comment">// material interface</span>
    Xcrk <a href="/pkg/builtin/#bool">bool</a>        <span class="comment">// crack</span>
    Xfem <a href="/pkg/builtin/#bool">bool</a>        <span class="comment">// Xmat || Xcrk</span>
    Na   <a href="/pkg/builtin/#int">int</a>         <span class="comment">// number of additional degrees of freedom (XFEM)</span>
    Amap []<a href="/pkg/builtin/#int">int</a>       <span class="comment">// additional DOFs map</span>
    Kua  [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// TODO: [nu][na] Kua := dRu/da consistent tangent matrix</span>
    Kau  [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// TODO: [na][nu] Kau := dRa/du consistent tangent matrix</span>
    Kaa  [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// TODO: [na][na] Kaa := dRa/da consistent tangent matrix</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
ElemU represents a solid element with displacements u as primary variables
</p>


			

			

			
			
			

			

			
				
				<h3 id="ElemU.AddToExt">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=16859:16910#L634">AddToExt</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) AddToExt(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AddToExt extrapolates stresses at integration points to nodes
</p>

				
				
				
			
				
				<h3 id="ElemU.AddToKb">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=10941:11021#L387">AddToKb</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AddToKb adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="ElemU.AddToRhs">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=8945:9010#L296">AddToRhs</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AddToRhs adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="ElemU.BackupIvs">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=14654:14701#L543">BackupIvs</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) BackupIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
BackupIvs create copy of internal variables
</p>

				
				
				
			
				
				<h3 id="ElemU.Decode">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=15649:15696#L589">Decode</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) Decode(dec <a href="#Decoder">Decoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemU.Encode">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=15530:15577#L584">Encode</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) Encode(enc <a href="#Encoder">Encoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemU.Id">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=7323:7347#L222">Id</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="ElemU.InterpStarVars">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=8266:8323#L266">InterpStarVars</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
InterpStarVars interpolates star variables to integration points
</p>

				
				
				
			
				
				<h3 id="ElemU.Ipoints">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=13737:13783#L506">Ipoints</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) Ipoints() (coords [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Ipoints returns the real coordinates of integration points [nip][ndim]
</p>

				
				
				
			
				
				<h3 id="ElemU.OutIpCoords">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=15848:15893#L598">OutIpCoords</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) OutIpCoords() (C [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
OutIpCoords returns the coordinates of integration points
</p>

				
				
				
			
				
				<h3 id="ElemU.OutIpKeys">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=16077:16113#L607">OutIpKeys</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) OutIpKeys() []<a href="/pkg/builtin/#string">string</a></pre>
				<p>
OutIpKeys returns the integration points&#39; keys
</p>

				
				
				
			
				
				<h3 id="ElemU.OutIpVals">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=16323:16374#L616">OutIpVals</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) OutIpVals(M *<a href="#IpsMap">IpsMap</a>, sol *<a href="#Solution">Solution</a>)</pre>
				<p>
OutIpVals returns the integration points&#39; values corresponding to keys
</p>

				
				
				
			
				
				<h3 id="ElemU.RestoreIvs">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=14907:14955#L557">RestoreIvs</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) RestoreIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
RestoreIvs restore internal variables from copies
</p>

				
				
				
			
				
				<h3 id="ElemU.SetEleConds">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=8063:8140#L258">SetEleConds</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEleConds set element conditions
</p>

				
				
				
			
				
				<h3 id="ElemU.SetEqs">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=7394:7462#L225">SetEqs</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEqs set equations
</p>

				
				
				
			
				
				<h3 id="ElemU.SetIniIvs">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=13995:14073#L515">SetIniIvs</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) SetIniIvs(sol *<a href="#Solution">Solution</a>, ivs map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetIniIvs sets initial ivs for given values in sol and ivs map
</p>

				
				
				
			
				
				<h3 id="ElemU.Update">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=12658:12707#L468">Update</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) Update(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Update perform (tangent) update
</p>

				
				
				
			
				
				<h3 id="ElemU.Ureset">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=15184:15233#L571">Ureset</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) Ureset(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Ureset fixes internal variables after u (displacements) have been zeroed
</p>

				
				
				
			
		
			
			
			<h2 id="ElemUP">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=876:1836#L14">ElemUP</a></h2>
			<pre>type ElemUP struct {

    <span class="comment">// auxiliary</span>
    Sim     *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Simulation">Simulation</a> <span class="comment">// simulation</span>
    Cell    *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>       <span class="comment">// cell</span>
    LbbCell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>       <span class="comment">// if LBB==false, same as Cell; otherwise LbbCell is a new cell with less vertices</span>
    Edat    *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#ElemData">ElemData</a>   <span class="comment">// element data; stored in allocator to be used in Connect</span>
    Ndim    <a href="/pkg/builtin/#int">int</a>             <span class="comment">// space dimension</span>

    <span class="comment">// underlying elements</span>
    U *<a href="#ElemU">ElemU</a> <span class="comment">// u-element</span>
    P *<a href="#ElemP">ElemP</a> <span class="comment">// p-element</span>

    Kup [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nu][np] Kup := dRus/dpl consistent tangent matrix</span>
    Kpu [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [np][nu] Kpu := dRpl/dus consistent tangent matrix</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
ElemUP represents an element for porous media based on the u-p formulation [1]
</p>
<pre>References:
 [1] Pedroso DM. A consistent u-p formulation for porous media with hysteresis.
     Int Journal for Numerical Methods in Engineering, 101(8):606-634; 2015
     <a href="http://dx.doi.org/10.1002/nme.4808">http://dx.doi.org/10.1002/nme.4808</a>
 [2] Pedroso DM. A solution to transient seepage in unsaturated porous media.
     Computer Methods in Applied Mechanics and Engineering, 285:791-816; 2015
     <a href="http://dx.doi.org/10.1016/j.cma.2014.12.009">http://dx.doi.org/10.1016/j.cma.2014.12.009</a>
</pre>


			

			

			
			
			

			

			
				
				<h3 id="ElemUP.AddToKb">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=9321:9402#L350">AddToKb</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="ElemUP.AddToRhs">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=6381:6447#L228">AddToRhs</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="ElemUP.BackupIvs">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=16172:16220#L628">BackupIvs</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) BackupIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
BackupIvs create copy of internal variables
</p>

				
				
				
			
				
				<h3 id="ElemUP.Decode">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=17459:17507#L683">Decode</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) Decode(dec <a href="#Decoder">Decoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemUP.Encode">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=17292:17340#L674">Encode</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) Encode(enc <a href="#Encoder">Encoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemUP.Id">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=4154:4179#L133">Id</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="ElemUP.InterpStarVars">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=5344:5402#L181">InterpStarVars</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
InterpStarVars interpolates star variables to integration points
</p>

				
				
				
			
				
				<h3 id="ElemUP.Ipoints">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=14749:14796#L567">Ipoints</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) Ipoints() (coords [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Ipoints returns the real coordinates of integration points [nip][ndim]
</p>

				
				
				
			
				
				<h3 id="ElemUP.OutIpCoords">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=17650:17696#L692">OutIpCoords</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) OutIpCoords() (C [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
OutIpCoords returns the coordinates of integration points
</p>

				
				
				
			
				
				<h3 id="ElemUP.OutIpKeys">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=17778:17815#L697">OutIpKeys</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) OutIpKeys() []<a href="/pkg/builtin/#string">string</a></pre>
				<p>
OutIpKeys returns the integration points&#39; keys
</p>

				
				
				
			
				
				<h3 id="ElemUP.OutIpVals">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=18005:18057#L703">OutIpVals</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) OutIpVals(M *<a href="#IpsMap">IpsMap</a>, sol *<a href="#Solution">Solution</a>)</pre>
				<p>
OutIpVals returns the integration points&#39; values corresponding to keys
</p>

				
				
				
			
				
				<h3 id="ElemUP.RestoreIvs">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=16361:16410#L637">RestoreIvs</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) RestoreIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
RestoreIvs restore internal variables from copies
</p>

				
				
				
			
				
				<h3 id="ElemUP.SetEleConds">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=5086:5164#L172">SetEleConds</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEleConds set element conditions
</p>

				
				
				
			
				
				<h3 id="ElemUP.SetEqs">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=4226:4295#L136">SetEqs</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEqs set equations
</p>

				
				
				
			
				
				<h3 id="ElemUP.SetIniIvs">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=15016:15095#L576">SetIniIvs</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) SetIniIvs(sol *<a href="#Solution">Solution</a>, ivs map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetIniIvs sets initial ivs for given values in sol and ivs map
</p>

				
				
				
			
				
				<h3 id="ElemUP.Update">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=14440:14490#L556">Update</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) Update(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Update perform (tangent) update
</p>

				
				
				
			
				
				<h3 id="ElemUP.Ureset">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=16576:16626#L646">Ureset</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) Ureset(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Ureset fixes internal variables after u (displacements) have been zeroed
</p>

				
				
				
			
		
			
			
			<h2 id="ElemUPP">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_upp.go?s=399:1476#L7">ElemUPP</a></h2>
			<pre>type ElemUPP struct {

    <span class="comment">// auxiliary</span>
    Sim     *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Simulation">Simulation</a> <span class="comment">// simulation</span>
    Cell    *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>       <span class="comment">// cell</span>
    LbbCell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>       <span class="comment">// if LBB==false, same as Cell; otherwise LbbCell is a new cell with less vertices</span>
    Edat    *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#ElemData">ElemData</a>   <span class="comment">// element data; stored in allocator to be used in Connect</span>
    Ndim    <a href="/pkg/builtin/#int">int</a>             <span class="comment">// space dimension</span>

    <span class="comment">// underlying elements</span>
    U *<a href="#ElemU">ElemU</a>  <span class="comment">// u-element</span>
    P *<a href="#ElemPP">ElemPP</a> <span class="comment">// pp-element</span>

    Kul [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nu][np] dRus/dpl</span>
    Kug [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nu][np] dRus/dpl</span>
    Klu [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [np][nu] dRpl/dus</span>
    Kgu [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [np][nu] dRpg/dus</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
ElemUPP implements the u-pl-pg formulation
</p>


			

			

			
			
			

			

			
				
				<h3 id="ElemUPP.AddToKb">func (*ElemUPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_upp.go?s=9425:9507#L356">AddToKb</a></h3>
				<pre>func (o *<a href="#ElemUPP">ElemUPP</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="ElemUPP.AddToRhs">func (*ElemUPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_upp.go?s=6200:6267#L229">AddToRhs</a></h3>
				<pre>func (o *<a href="#ElemUPP">ElemUPP</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="ElemUPP.BackupIvs">func (*ElemUPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_upp.go?s=17423:17472#L653">BackupIvs</a></h3>
				<pre>func (o *<a href="#ElemUPP">ElemUPP</a>) BackupIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
BackupIvs create copy of internal variables
</p>

				
				
				
			
				
				<h3 id="ElemUPP.Decode">func (*ElemUPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_upp.go?s=18714:18763#L708">Decode</a></h3>
				<pre>func (o *<a href="#ElemUPP">ElemUPP</a>) Decode(dec <a href="#Decoder">Decoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemUPP.Encode">func (*ElemUPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_upp.go?s=18546:18595#L699">Encode</a></h3>
				<pre>func (o *<a href="#ElemUPP">ElemUPP</a>) Encode(enc <a href="#Encoder">Encoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemUPP.Id">func (*ElemUPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_upp.go?s=3896:3922#L133">Id</a></h3>
				<pre>func (o *<a href="#ElemUPP">ElemUPP</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="ElemUPP.InterpStarVars">func (*ElemUPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_upp.go?s=5090:5149#L181">InterpStarVars</a></h3>
				<pre>func (o *<a href="#ElemUPP">ElemUPP</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
InterpStarVars interpolates star variables to integration points
</p>

				
				
				
			
				
				<h3 id="ElemUPP.Ipoints">func (*ElemUPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_upp.go?s=15869:15917#L587">Ipoints</a></h3>
				<pre>func (o *<a href="#ElemUPP">ElemUPP</a>) Ipoints() (coords [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Ipoints returns the real coordinates of integration points [nip][ndim]
</p>

				
				
				
			
				
				<h3 id="ElemUPP.OutIpCoords">func (*ElemUPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_upp.go?s=18906:18953#L717">OutIpCoords</a></h3>
				<pre>func (o *<a href="#ElemUPP">ElemUPP</a>) OutIpCoords() (C [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
OutIpCoords returns the coordinates of integration points
</p>

				
				
				
			
				
				<h3 id="ElemUPP.OutIpKeys">func (*ElemUPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_upp.go?s=19035:19073#L722">OutIpKeys</a></h3>
				<pre>func (o *<a href="#ElemUPP">ElemUPP</a>) OutIpKeys() []<a href="/pkg/builtin/#string">string</a></pre>
				<p>
OutIpKeys returns the integration points&#39; keys
</p>

				
				
				
			
				
				<h3 id="ElemUPP.OutIpVals">func (*ElemUPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_upp.go?s=19322:19375#L729">OutIpVals</a></h3>
				<pre>func (o *<a href="#ElemUPP">ElemUPP</a>) OutIpVals(M *<a href="#IpsMap">IpsMap</a>, sol *<a href="#Solution">Solution</a>)</pre>
				<p>
OutIpVals returns the integration points&#39; values corresponding to keys
</p>

				
				
				
			
				
				<h3 id="ElemUPP.RestoreIvs">func (*ElemUPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_upp.go?s=17613:17663#L662">RestoreIvs</a></h3>
				<pre>func (o *<a href="#ElemUPP">ElemUPP</a>) RestoreIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
RestoreIvs restore internal variables from copies
</p>

				
				
				
			
				
				<h3 id="ElemUPP.SetEleConds">func (*ElemUPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_upp.go?s=4831:4910#L172">SetEleConds</a></h3>
				<pre>func (o *<a href="#ElemUPP">ElemUPP</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEleConds set element conditions
</p>

				
				
				
			
				
				<h3 id="ElemUPP.SetEqs">func (*ElemUPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_upp.go?s=3969:4039#L136">SetEqs</a></h3>
				<pre>func (o *<a href="#ElemUPP">ElemUPP</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEqs set equations
</p>

				
				
				
			
				
				<h3 id="ElemUPP.SetIniIvs">func (*ElemUPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_upp.go?s=16137:16217#L596">SetIniIvs</a></h3>
				<pre>func (o *<a href="#ElemUPP">ElemUPP</a>) SetIniIvs(sol *<a href="#Solution">Solution</a>, ivs map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetIniIvs sets initial ivs for given values in sol and ivs map
</p>

				
				
				
			
				
				<h3 id="ElemUPP.Update">func (*ElemUPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_upp.go?s=15559:15610#L576">Update</a></h3>
				<pre>func (o *<a href="#ElemUPP">ElemUPP</a>) Update(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Update perform (tangent) update
</p>

				
				
				
			
				
				<h3 id="ElemUPP.Ureset">func (*ElemUPP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_upp.go?s=17829:17880#L671">Ureset</a></h3>
				<pre>func (o *<a href="#ElemUPP">ElemUPP</a>) Ureset(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Ureset fixes internal variables after u (displacements) have been zeroed
</p>

				
				
				
			
		
			
			
			<h2 id="Encoder">type <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=375:430#L10">Encoder</a></h2>
			<pre>type Encoder interface {
    Encode(e interface{}) <a href="/pkg/builtin/#error">error</a>
}</pre>
			<p>
Encoder defines encoders; e.g. gob or json
</p>


			

			

			
			
			

			
				
				<h3 id="GetEncoder">func <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=571:625#L20">GetEncoder</a></h3>
				<pre>func GetEncoder(w <a href="/pkg/io/">goio</a>.<a href="/pkg/io/#Writer">Writer</a>, enctype <a href="/pkg/builtin/#string">string</a>) <a href="#Encoder">Encoder</a></pre>
				<p>
GetEncoder returns a new encoder
</p>

				
				
			

			
		
			
			
			<h2 id="EssentialBc">type <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=910:1206#L22">EssentialBc</a></h2>
			<pre>type EssentialBc struct {
    Key   <a href="/pkg/builtin/#string">string</a>    <span class="comment">// key such as &#39;ux&#39;, &#39;uy&#39;, &#39;rigid&#39;, &#39;incsup&#39;, &#39;hst&#39;</span>
    Eqs   []<a href="/pkg/builtin/#int">int</a>     <span class="comment">// equations numbers; can be more than one e.g. for inclined support</span>
    ValsA []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// values for matrix A</span>
    Fcn   <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>  <span class="comment">// function that implements the &#34;c&#34; vector in  A・y = c</span>
}</pre>
			<p>
EssentialBc holds information about essential bounday conditions such as constrained nodes.
Lagrange multipliers are used to implement both single- and multi-point constraints.
</p>
<pre>In general, essential bcs / constraints are defined by means of:

    A・y = c

The resulting Kb matrix will then have the following form:
    _       _
   |  K  At  | / δy \   / -R - At*λ \
   |         | |    | = |           |
   |_ A   0 _| \ δλ /   \  c - A*y  /
       Kb       δyb          fb
</pre>


			

			

			
			
			

			

			
		
			
			
			<h2 id="EssentialBcs">type <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=1440:1755#L34">EssentialBcs</a></h2>
			<pre>type EssentialBcs struct {
    LiqMdl *<a href="/pkg/github.com/cpmech/gofem/mdl/fld/">fld</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/fld/#Model">Model</a>   <span class="comment">// for computing hydrostatic conditions</span>
    EqsIni map[<a href="/pkg/builtin/#int">int</a>]<a href="/pkg/builtin/#bool">bool</a> <span class="comment">// equations that depend on initial values</span>
    Bcs    <a href="#EbcArray">EbcArray</a>     <span class="comment">// active essential bcs / constraints</span>
    A      <a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>   <span class="comment">// matrix of coefficients &#39;A&#39;</span>
    Am     *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#CCMatrix">CCMatrix</a> <span class="comment">// compressed form of A matrix</span>
}</pre>
			<p>
EssentialBcs implements a structure to record the definition of essential bcs / constraints.
Each constraint will have a unique Lagrange multiplier index.
</p>


			

			

			
			
			

			

			
				
				<h3 id="EssentialBcs.AddToRhs">func (*EssentialBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=2741:2801#L80">AddToRhs</a></h3>
				<pre>func (o *<a href="#EssentialBcs">EssentialBcs</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>)</pre>
				<p>
AddtoRhs adds the essential bcs / constraints terms to the augmented fb vector
</p>

				
				
				
			
				
				<h3 id="EssentialBcs.Build">func (*EssentialBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=2136:2188#L52">Build</a></h3>
				<pre>func (o *<a href="#EssentialBcs">EssentialBcs</a>) Build(ny <a href="/pkg/builtin/#int">int</a>) (nλ, nnzA <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Build builds the structures required for assembling A matrix
</p>
<pre>nλ   -- is the number of essential bcs / constraints == number of Lagrange multipliers
nnzA -- is the number of non-zeros in matrix &#39;A&#39;
</pre>

				
				
				
			
				
				<h3 id="EssentialBcs.FixIniVals">func (*EssentialBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=6636:6684#L237">FixIniVals</a></h3>
				<pre>func (o *<a href="#EssentialBcs">EssentialBcs</a>) FixIniVals(sol *<a href="#Solution">Solution</a>)</pre>
				<p>
FixIniVals fixes functions of BCs that depend on initial values
</p>

				
				
				
			
				
				<h3 id="EssentialBcs.Init">func (*EssentialBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=1792:1838#L43">Init</a></h3>
				<pre>func (o *<a href="#EssentialBcs">EssentialBcs</a>) Init(liqmdl *<a href="/pkg/github.com/cpmech/gofem/mdl/fld/">fld</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/fld/#Model">Model</a>)</pre>
				<p>
Init initialises this structure
</p>

				
				
				
			
				
				<h3 id="EssentialBcs.List">func (*EssentialBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=6954:7003#L252">List</a></h3>
				<pre>func (o *<a href="#EssentialBcs">EssentialBcs</a>) List(t <a href="/pkg/builtin/#float64">float64</a>) (l <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
List returns a simple list logging bcs at time t
</p>

				
				
				
			
				
				<h3 id="EssentialBcs.Set">func (*EssentialBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=4174:4267#L118">Set</a></h3>
				<pre>func (o *<a href="#EssentialBcs">EssentialBcs</a>) Set(key <a href="/pkg/builtin/#string">string</a>, nodes []*<a href="#Node">Node</a>, fcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Set sets a constraint if it does not exist yet.
</p>
<pre>key   -- can be Dof key such as &#34;ux&#34;, &#34;uy&#34; or constraint type such as &#34;incsup&#34; or &#34;rigid&#34;
extra -- is a keycode-style data. e.g. &#34;!type:incsup2d !alp:30&#34;
Notes:
 1) the default key is single point constraint; e.g. &#34;ux&#34;, &#34;uy&#34;, ...
 2) hydraulic head can be set with key == &#34;hst&#34; (hydrostatic). In this case, fcn==shift
    computes a &#39;shift&#39; such that:
        pl(t,z) = pl(z) - shift(t)
 3) if the key as a suffix &#34;_ini&#34;, the initial value of essential key will be multiplied
    by fcn==mult in order to define the boundary condition according to:
        y(t,z) = y(z)_ini・mult(t)
</pre>

				
				
				
			
		
			
			
			<h2 id="FEM">type <a href="https://github.com/cpmech/gofem/blob/master/fem/fem.go?s=940:1456#L21">FEM</a></h2>
			<pre>type FEM struct {
    Sim     *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Simulation">Simulation</a> <span class="comment">// simulation data</span>
    Summary *<a href="#Summary">Summary</a>        <span class="comment">// summary structure</span>
    DynCfs  *<a href="#DynCoefs">DynCoefs</a>       <span class="comment">// coefficients for dynamics/transient simulations</span>
    Domains []*<a href="#Domain">Domain</a>       <span class="comment">// all domains</span>
    Solver  <a href="#FEsolver">FEsolver</a>        <span class="comment">// finite element method solver; e.g. implicit, Richardson extrapolation, etc.</span>
    DebugKb <a href="#DebugKb_t">DebugKb_t</a>       <span class="comment">// debug Kb callback function</span>
    Nproc   <a href="/pkg/builtin/#int">int</a>             <span class="comment">// number of processors</span>
    Proc    <a href="/pkg/builtin/#int">int</a>             <span class="comment">// processor id</span>
    Verbose <a href="/pkg/builtin/#bool">bool</a>            <span class="comment">// show messages</span>
}</pre>
			<p>
FEM holds all data for a simulation using the finite element method
</p>


			

			

			
			
			

			
				
				<h3 id="NewFEM">func <a href="https://github.com/cpmech/gofem/blob/master/fem/fem.go?s=1972:2102#L42">NewFEM</a></h3>
				<pre>func NewFEM(simfilepath, alias <a href="/pkg/builtin/#string">string</a>, erasePrev, saveSummary, readSummary, allowParallel, verbose <a href="/pkg/builtin/#bool">bool</a>, goroutineId <a href="/pkg/builtin/#int">int</a>) (o *<a href="#FEM">FEM</a>)</pre>
				<p>
NewFEM returns a new FEM structure
</p>
<pre>Input:
 simfilepath   -- simulation (.sim) filename including full path
 alias         -- word to be appended to simulation key; e.g. when running multiple FE solutions
 erasePrev     -- erase previous results files
 saveSummary   -- save summary
 readSummary   -- ready summary of previous simulation
 allowParallel -- allow parallel execution; otherwise, run in serial mode regardless whether MPI is on or not
 verbose       -- show messages
</pre>

				
				
			

			
				
				<h3 id="FEM.Run">func (*FEM) <a href="https://github.com/cpmech/gofem/blob/master/fem/fem.go?s=3273:3304#L98">Run</a></h3>
				<pre>func (o *<a href="#FEM">FEM</a>) Run() (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Run runs FE simulation
</p>

				
				
				
			
				
				<h3 id="FEM.SetStage">func (*FEM) <a href="https://github.com/cpmech/gofem/blob/master/fem/fem.go?s=4146:4192#L147">SetStage</a></h3>
				<pre>func (o *<a href="#FEM">FEM</a>) SetStage(stgidx <a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetStage sets stage for all domains
</p>
<pre>Input:
 stgidx -- stage index (in o.Sim.Stages)
</pre>

				
				
				
			
				
				<h3 id="FEM.SolveOneStage">func (*FEM) <a href="https://github.com/cpmech/gofem/blob/master/fem/fem.go?s=4935:5002#L176">SolveOneStage</a></h3>
				<pre>func (o *<a href="#FEM">FEM</a>) SolveOneStage(stgidx <a href="/pkg/builtin/#int">int</a>, zerostage <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SolveOneStage solves one stage that was already set
</p>
<pre>Input:
 stgidx    -- stage index (in o.Sim.Stages)
 zerostage -- zero vectors in domains.Sol =&gt; call ZeroStage
</pre>

				
				
				
			
				
				<h3 id="FEM.ZeroStage">func (*FEM) <a href="https://github.com/cpmech/gofem/blob/master/fem/fem.go?s=4578:4639#L162">ZeroStage</a></h3>
				<pre>func (o *<a href="#FEM">FEM</a>) ZeroStage(stgidx <a href="/pkg/builtin/#int">int</a>, zeroSol <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ZeroStage zeroes solution varaibles; i.e. it initialises solution vectors (Y, dYdt, internal
values such as States.Sig, etc.) in all domains for all nodes and all elements
</p>
<pre>Input:
 stgidx  -- stage index (in o.Sim.Stages)
 zeroSol -- zero vectors in domains.Sol
</pre>

				
				
				
			
		
			
			
			<h2 id="FEsolver">type <a href="https://github.com/cpmech/gofem/blob/master/fem/fem.go?s=607:720#L13">FEsolver</a></h2>
			<pre>type FEsolver interface {
    Run(tf <a href="/pkg/builtin/#float64">float64</a>, dtFunc, dtoFunc <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, verbose <a href="/pkg/builtin/#bool">bool</a>, dbgKb <a href="#DebugKb_t">DebugKb_t</a>) (err <a href="/pkg/builtin/#error">error</a>)
}</pre>
			<p>
FEsolver implements the actual solver (time loop)
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Info">type <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=4167:4697#L96">Info</a></h2>
			<pre>type Info struct {

    <span class="comment">// essential</span>
    Dofs [][]<a href="/pkg/builtin/#string">string</a>        <span class="comment">// solution variables PER NODE. ex for 2 nodes: [[&#34;ux&#34;, &#34;uy&#34;, &#34;rz&#34;], [&#34;ux&#34;, &#34;uy&#34;, &#34;rz&#34;]]</span>
    Y2F  map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#string">string</a> <span class="comment">// maps &#34;y&#34; keys to &#34;f&#34; keys. ex: &#34;ux&#34; =&gt; &#34;fx&#34;, &#34;pl&#34; =&gt; &#34;ql&#34;</span>

    <span class="comment">// internal Dofs; e.g. for mixed formulations</span>
    NintDofs <a href="/pkg/builtin/#int">int</a> <span class="comment">// number of internal dofs</span>

    <span class="comment">// t1 and t2 variables (time-derivatives of first and second order)</span>
    T1vars []<a href="/pkg/builtin/#string">string</a> <span class="comment">// &#34;pl&#34;</span>
    T2vars []<a href="/pkg/builtin/#string">string</a> <span class="comment">// &#34;ux&#34;, &#34;uy&#34;</span>

    <span class="comment">// required to be extrapolated; e.g. by beam-joints</span>
    Nextrap <a href="/pkg/builtin/#int">int</a> <span class="comment">// e.g. &#34;nsig&#34;</span>
}</pre>
			<p>
Info holds all information required to set a simulation stage
</p>


			

			

			
			
			

			
				
				<h3 id="GetElemInfo">func <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=4815:4924#L116">GetElemInfo</a></h3>
				<pre>func GetElemInfo(cell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>, reg *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Region">Region</a>, sim *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Simulation">Simulation</a>) (info *<a href="#Info">Info</a>, inactive <a href="/pkg/builtin/#bool">bool</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
GetElemInfo returns information about elements/formulations
</p>
<pre>cellType -- e.g. &#34;qua8&#34;
elemType -- e.g. &#34;u&#34;
</pre>

				
				
			

			
		
			
			
			<h2 id="IpsMap">type <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=383:415#L6">IpsMap</a></h2>
			<pre>type IpsMap map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
IpsMap defines a map to hold integration points&#39; results
</p>


			

			

			
			
			

			
				
				<h3 id="NewIpsMap">func <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=451:475#L9">NewIpsMap</a></h3>
				<pre>func NewIpsMap() *<a href="#IpsMap">IpsMap</a></pre>
				<p>
NewIpsMap returns a new IpsMap
</p>

				
				
			

			
				
				<h3 id="IpsMap.Get">func (*IpsMap) <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=1173:1222#L32">Get</a></h3>
				<pre>func (o *<a href="#IpsMap">IpsMap</a>) Get(key <a href="/pkg/builtin/#string">string</a>, idx <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Get returns item corresponding to &#39;key&#39; and integration point &#39;idx&#39;
</p>
<pre>Note: this function returns 0 if &#39;key&#39; is not found. It also does not check for out-of-bound errors
</pre>

				
				
				
			
				
				<h3 id="IpsMap.Set">func (*IpsMap) <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=801:860#L20">Set</a></h3>
				<pre>func (o *<a href="#IpsMap">IpsMap</a>) Set(key <a href="/pkg/builtin/#string">string</a>, idx, nip <a href="/pkg/builtin/#int">int</a>, val <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Set sets item in map by key and ip-index. The slice is resized with nip in case it&#39;s empty
</p>
<pre>Input:
 idx -- index of integration point
 nip -- number of integration points (to resize if necessary)
 val -- value of &#39;key&#39; @ integration point &#39;idx&#39;
</pre>

				
				
				
			
		
			
			
			<h2 id="NaturalBc">type <a href="https://github.com/cpmech/gofem/blob/master/fem/naturalbcs.go?s=348:559#L1">NaturalBc</a></h2>
			<pre>type NaturalBc struct {
    Key     <a href="/pkg/builtin/#string">string</a>   <span class="comment">// key such as qn, qn0, ql, seepH, seepP, etc...</span>
    IdxFace <a href="/pkg/builtin/#int">int</a>      <span class="comment">// local index of face</span>
    Fcn     <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// function callback</span>
    Extra   <a href="/pkg/builtin/#string">string</a>   <span class="comment">// extra information</span>
}</pre>
			<p>
NaturalBc holds information on natural boundary conditioins such as
distributed loads or fluxes acting on surfaces
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Node">type <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=630:747#L16">Node</a></h2>
			<pre>type Node struct {
    Dofs []*<a href="#Dof">Dof</a>    <span class="comment">// degrees-of-freedom == solution variables</span>
    Vert *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Vert">Vert</a> <span class="comment">// pointer to Vertex</span>
}</pre>
			<p>
Node holds node dofs information
</p>


			

			

			
			
			

			
				
				<h3 id="NewNode">func <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=781:812#L22">NewNode</a></h3>
				<pre>func NewNode(v *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Vert">Vert</a>) *<a href="#Node">Node</a></pre>
				<p>
NewNode allocates a new Node
</p>

				
				
			

			
				
				<h3 id="Node.AddDofAndEq">func (*Node) <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=1241:1304#L40">AddDofAndEq</a></h3>
				<pre>func (o *<a href="#Node">Node</a>) AddDofAndEq(ukey <a href="/pkg/builtin/#string">string</a>, eqnum <a href="/pkg/builtin/#int">int</a>) (nexteq <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
AddDof adds a new dof to thisnode; ignores it if it exists already
</p>
<pre>nexteq -- is the next equation number == eqnum + 1;
          returns eqnum if dof exists already
</pre>

				
				
				
			
				
				<h3 id="Node.GetDof">func (*Node) <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=1755:1794#L61">GetDof</a></h3>
				<pre>func (o *<a href="#Node">Node</a>) GetDof(ukey <a href="/pkg/builtin/#string">string</a>) *<a href="#Dof">Dof</a></pre>
				<p>
GetDof returns the Dof structure for given Dof name (ukey)
</p>
<pre>Note: returns nil if not found
</pre>

				
				
				
			
				
				<h3 id="Node.GetEq">func (*Node) <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=1983:2031#L72">GetEq</a></h3>
				<pre>func (o *<a href="#Node">Node</a>) GetEq(ukey <a href="/pkg/builtin/#string">string</a>) (eqNumber <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
GetEq returns the equation number for given Dof name (ukey)
</p>
<pre>Note: returns -1 if not found
</pre>

				
				
				
			
				
				<h3 id="Node.GetKeys">func (*Node) <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=2174:2207#L82">GetKeys</a></h3>
				<pre>func (o *<a href="#Node">Node</a>) GetKeys() []<a href="/pkg/builtin/#string">string</a></pre>
				<p>
GetKeys returns a slice of keys from all dofs
</p>

				
				
				
			
				
				<h3 id="Node.SetEq">func (*Node) <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=1593:1640#L55">SetEq</a></h3>
				<pre>func (o *<a href="#Node">Node</a>) SetEq(ukey <a href="/pkg/builtin/#string">string</a>, eqNumber <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
SetEq numbers a specific Dof with the equation number in the current (stage) global system
</p>

				
				
				
			
				
				<h3 id="Node.String">func (*Node) <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=902:932#L27">String</a></h3>
				<pre>func (o *<a href="#Node">Node</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
String returns the string representation of this node
</p>

				
				
				
			
		
			
			
			<h2 id="PtNaturalBc">type <a href="https://github.com/cpmech/gofem/blob/master/fem/ptnatbcs.go?s=380:581#L4">PtNaturalBc</a></h2>
			<pre>type PtNaturalBc struct {
    Key   <a href="/pkg/builtin/#string">string</a>    <span class="comment">// key such as fux, fpl, etc...</span>
    Eq    <a href="/pkg/builtin/#int">int</a>       <span class="comment">// equation</span>
    X     []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// location</span>
    Fcn   <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>  <span class="comment">// function</span>
    Extra <a href="/pkg/builtin/#string">string</a>    <span class="comment">// extra information</span>
}</pre>
			<p>
PtNaturalBc holds information on point natural boundary conditions such as
prescribed forces or fluxes) at nodes
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="PtNaturalBcs">type <a href="https://github.com/cpmech/gofem/blob/master/fem/ptnatbcs.go?s=627:792#L13">PtNaturalBcs</a></h2>
			<pre>type PtNaturalBcs struct {
    Eq2idx map[<a href="/pkg/builtin/#int">int</a>]<a href="/pkg/builtin/#int">int</a>    <span class="comment">// maps eq number to indices in Bcs</span>
    Bcs    []*<a href="#PtNaturalBc">PtNaturalBc</a> <span class="comment">//active boundary conditions such as prescribed forces</span>
}</pre>
			<p>
PointLoads is a set of prescribed forces
</p>


			

			

			
			
			

			

			
				
				<h3 id="PtNaturalBcs.AddToRhs">func (PtNaturalBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/ptnatbcs.go?s=1008:1063#L25">AddToRhs</a></h3>
				<pre>func (o <a href="#PtNaturalBcs">PtNaturalBcs</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, t <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
AddToRhs adds the boundary conditions terms to the augmented fb vector
</p>

				
				
				
			
				
				<h3 id="PtNaturalBcs.List">func (*PtNaturalBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/ptnatbcs.go?s=1703:1752#L51">List</a></h3>
				<pre>func (o *<a href="#PtNaturalBcs">PtNaturalBcs</a>) List(t <a href="/pkg/builtin/#float64">float64</a>) (l <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
List returns a simple list logging bcs at time t
</p>

				
				
				
			
				
				<h3 id="PtNaturalBcs.Reset">func (*PtNaturalBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/ptnatbcs.go?s=835:865#L19">Reset</a></h3>
				<pre>func (o *<a href="#PtNaturalBcs">PtNaturalBcs</a>) Reset()</pre>
				<p>
Reset initialises internal structures
</p>

				
				
				
			
				
				<h3 id="PtNaturalBcs.Set">func (*PtNaturalBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/ptnatbcs.go?s=1183:1275#L32">Set</a></h3>
				<pre>func (o *<a href="#PtNaturalBcs">PtNaturalBcs</a>) Set(key <a href="/pkg/builtin/#string">string</a>, nod *<a href="#Node">Node</a>, fcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (setisok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Set sets new point natural boundary condition data
</p>

				
				
				
			
		
			
			
			<h2 id="RichardsonExtrap">type <a href="https://github.com/cpmech/gofem/blob/master/fem/s_richardson.go?s=446:1149#L8">RichardsonExtrap</a></h2>
			<pre>type RichardsonExtrap struct {

    <span class="comment">// variables after big step</span>
    Y_big []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// primary variables</span>

    <span class="comment">// time loop</span>
    Δt    <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// time step</span>
    Δtcpy <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// copy of Δt for divergence control</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
RichardsonExtrap solves FEM problem implicitely and with Richardson&#39;s extrapolation
</p>


			

			

			
			
			

			

			
				
				<h3 id="RichardsonExtrap.Init">func (*RichardsonExtrap) <a href="https://github.com/cpmech/gofem/blob/master/fem/s_richardson.go?s=1396:1429#L48">Init</a></h3>
				<pre>func (o *<a href="#RichardsonExtrap">RichardsonExtrap</a>) Init()</pre>
				
				
				
				
			
				
				<h3 id="RichardsonExtrap.Run">func (*RichardsonExtrap) <a href="https://github.com/cpmech/gofem/blob/master/fem/s_richardson.go?s=1740:1851#L69">Run</a></h3>
				<pre>func (o *<a href="#RichardsonExtrap">RichardsonExtrap</a>) Run(tf <a href="/pkg/builtin/#float64">float64</a>, dtFunc, dtoFunc <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, verbose <a href="/pkg/builtin/#bool">bool</a>, dbgKb <a href="#DebugKb_t">DebugKb_t</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
				
			
		
			
			
			<h2 id="Rjoint">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=2395:5092#L45">Rjoint</a></h2>
			<pre>type Rjoint struct {

    <span class="comment">// basic data</span>
    Sim  *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Simulation">Simulation</a> <span class="comment">// simulation</span>
    Edat *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#ElemData">ElemData</a>   <span class="comment">// element data; stored in allocator to be used in Connect</span>
    Cell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>       <span class="comment">// the cell structure</span>
    Ny   <a href="/pkg/builtin/#int">int</a>             <span class="comment">// total number of dofs == rod.Nu + sld.Nu</span>
    Ndim <a href="/pkg/builtin/#int">int</a>             <span class="comment">// space dimension</span>

    <span class="comment">// essential</span>
    Rod *<a href="#Rod">Rod</a>          <span class="comment">// rod element</span>
    Sld *<a href="#ElemU">ElemU</a>        <span class="comment">// solid element</span>
    Mdl *<a href="/pkg/github.com/cpmech/gofem/mdl/sld/">sld</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/sld/#RjointM1">RjointM1</a> <span class="comment">// material model</span>

    <span class="comment">// shape functions evaluations and extrapolator matrices</span>
    Nmat [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [sldNn][rodNn] shape functions of solids @ [N]odes of rod element</span>
    Pmat [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [sldNn][rodNp] shape functions of solids @ integration [P]oints of rod element (for Coulomb model)</span>
    Emat [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [sldNn][sldNp] solid&#39;s extrapolation matrix (for Coulomb model)</span>

    <span class="comment">// variables for Coulomb model</span>
    Coulomb <a href="/pkg/builtin/#bool">bool</a> <span class="comment">// use Coulomb model</span>

    <span class="comment">// auxiliary variables</span>
    ΔuC [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [rodNn][ndim] relative displ. increment of solid @ nodes of rod; Eq (30)</span>
    Δw  []<a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// [ndim] relative velocity; Eq (32)</span>

    <span class="comment">// temporary Jacobian matrices. see Eq. (57)</span>
    Krr [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [rodNu][rodNu] Eq. (58)</span>
    Krs [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [rodNu][sldNu] Eq. (59)</span>
    Ksr [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [sldNu][rodNu] Eq. (60)</span>
    Kss [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [sldNu][sldNu] Eq. (61)</span>

    <span class="comment">// internal values</span>
    States    []*<a href="/pkg/github.com/cpmech/gofem/mdl/sld/">sld</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/sld/#OnedState">OnedState</a> <span class="comment">// [nip] internal states</span>
    StatesBkp []*<a href="/pkg/github.com/cpmech/gofem/mdl/sld/">sld</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/sld/#OnedState">OnedState</a> <span class="comment">// [nip] backup internal states</span>
    StatesAux []*<a href="/pkg/github.com/cpmech/gofem/mdl/sld/">sld</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/sld/#OnedState">OnedState</a> <span class="comment">// [nip] backup internal states</span>

    <span class="comment">// extra variables for consistent tangent operator</span>
    Ncns   <a href="/pkg/builtin/#bool">bool</a>            <span class="comment">// use non-consistent model</span>
    T1     [][]<a href="/pkg/builtin/#float64">float64</a>     <span class="comment">// [rodNp][nsig] tensor (e1 dy e1)</span>
    T2     [][]<a href="/pkg/builtin/#float64">float64</a>     <span class="comment">// [rodNp][nsig] tensor (e2 dy e2)</span>
    DσNoDu [][][][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [sldNn][nsig][sldNn][ndim] ∂σSldNod/∂uSldNod : derivatives of σ @ nodes of solid w.r.t displacements of solid</span>
    DσDun  [][]<a href="/pkg/builtin/#float64">float64</a>     <span class="comment">// [nsig][ndim] ∂σIp/∂us : derivatives of σ @ ip of solid w.r.t displacements of solid</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Rjoint implements the rod-joint (interface/link) element for reinforced solids.
</p>
<pre>The following convention is considered:
 n or N   -- means [N]odes
 p or P   -- means integration [P]oints
 nn or Nn -- number of nodes
 np or Np -- number of integration [P]points
 ndim     -- space dimension
 nsig     -- number of stress/strain components == 2 * ndim
 rod      -- means rod element
 rodH     -- rod shape structure
 rodNn    -- rod number of nodes
 rodNp    -- rod number of integration points
 rodS     -- rod shape functions
 sld      -- means solid element
 sldH     -- rod shape structure
 sldNn    -- solid number of nodes
 sldNp    -- solid number of integration points
 sldS     -- solid shape functions
 rodYn    -- rod&#39;s (real) coordinates of node
 rodYp    -- rod&#39;s (real) coordinates of integration point
 r or R   -- means natural coordinates in the solids&#39; system
 z or Z   -- means natural coordinates in the rod&#39;s system
 s or S   -- parametric coordinate along rod
 rodRn    -- natural coordinates or rod&#39;s nodes w.r.t solid&#39;s system
 rodRp    -- natural coordinates of rod&#39;s integration point w.r.t to solid&#39;s system
 Nmat     -- solid shape functions evaluated at rod nodes
 Pmat     -- solid shape functions evaluated at rod integration points
References:
 [1] Durand R, Farias MM, Pedroso DM. Modelling the strengthening of solids with
     incompatible line finite elements. Submitted.
 [2] Durand R, Farias MM, Pedroso DM. Computing intersections between non-compatible
     curves and finite elements. Computational Mechanics, 56(3):463-475; 2015
     <a href="http://dx.doi.org/10.1007/s00466-015-1181-y">http://dx.doi.org/10.1007/s00466-015-1181-y</a>
 [3] Durand R and Farias MM. A local extrapolation method for finite elements.
     Advances in Engineering Software, 67:1-9; 2014
     <a href="http://dx.doi.org/10.1016/j.advengsoft.2013.07.002">http://dx.doi.org/10.1016/j.advengsoft.2013.07.002</a>
</pre>


			

			

			
			
			

			

			
				
				<h3 id="Rjoint.AddToKb">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=11966:12047#L395">AddToKb</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="Rjoint.AddToRhs">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=10641:10707#L336">AddToRhs</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="Rjoint.BackupIvs">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=19974:20022#L740">BackupIvs</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) BackupIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
BackupIvs create copy of internal variables
</p>

				
				
				
			
				
				<h3 id="Rjoint.Connect">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=5826:5902#L130">Connect</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) Connect(cid2elem []<a href="#Elem">Elem</a>, c *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>) (nnzK <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Connect connects rod/solid elements in this Rjoint
</p>

				
				
				
			
				
				<h3 id="Rjoint.Decode">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=20830:20878#L780">Decode</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) Decode(dec <a href="#Decoder">Decoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="Rjoint.Encode">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=20710:20758#L775">Encode</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) Encode(enc <a href="#Encoder">Encoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="Rjoint.Id">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=5724:5749#L127">Id</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="Rjoint.InterpStarVars">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=10529:10587#L331">InterpStarVars</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
InterpStarVars interpolates star variables to integration points
</p>

				
				
				
			
				
				<h3 id="Rjoint.Ipoints">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=19384:19431#L721">Ipoints</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) Ipoints() (coords [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Ipoints returns the real coordinates of integration points [nip][ndim]
</p>

				
				
				
			
				
				<h3 id="Rjoint.OutIpCoords">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=21030:21076#L789">OutIpCoords</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) OutIpCoords() (C [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
OutIpCoords returns the coordinates of integration points
</p>

				
				
				
			
				
				<h3 id="Rjoint.OutIpKeys">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=21160:21197#L794">OutIpKeys</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) OutIpKeys() []<a href="/pkg/builtin/#string">string</a></pre>
				<p>
OutIpKeys returns the integration points&#39; keys
</p>

				
				
				
			
				
				<h3 id="Rjoint.OutIpVals">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=21309:21361#L799">OutIpVals</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) OutIpVals(M *<a href="#IpsMap">IpsMap</a>, sol *<a href="#Solution">Solution</a>)</pre>
				<p>
OutIpVals returns the integration points&#39; values corresponding to keys
</p>

				
				
				
			
				
				<h3 id="Rjoint.RestoreIvs">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=20228:20277#L754">RestoreIvs</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) RestoreIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
RestoreIvs restore internal variables from copies
</p>

				
				
				
			
				
				<h3 id="Rjoint.SetEleConds">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=10369:10447#L326">SetEleConds</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEleConds set element conditions
</p>

				
				
				
			
				
				<h3 id="Rjoint.SetEqs">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=10248:10317#L321">SetEqs</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEqs set equations
</p>

				
				
				
			
				
				<h3 id="Rjoint.SetIniIvs">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=19527:19606#L726">SetIniIvs</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) SetIniIvs(sol *<a href="#Solution">Solution</a>, ivs map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetIniIvs sets initial ivs for given values in sol and ivs map
</p>

				
				
				
			
				
				<h3 id="Rjoint.Update">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=16671:16721#L601">Update</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) Update(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Update perform (tangent) update
</p>

				
				
				
			
				
				<h3 id="Rjoint.Ureset">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=20506:20556#L768">Ureset</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) Ureset(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Ureset fixes internal variables after u (displacements) have been zeroed
</p>

				
				
				
			
		
			
			
			<h2 id="Rod">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=455:1354#L8">Rod</a></h2>
			<pre>type Rod struct {

    <span class="comment">// basic data</span>
    Cell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>   <span class="comment">// the cell structure</span>
    X    [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// matrix of nodal coordinates [ndim][nnode]</span>
    Nu   <a href="/pkg/builtin/#int">int</a>         <span class="comment">// total number of unknowns == 2 * nsn</span>
    Ndim <a href="/pkg/builtin/#int">int</a>         <span class="comment">// space dimension</span>

    <span class="comment">// variables for dynamics</span>
    Gfcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// gravity function</span>

    <span class="comment">// integration points</span>
    IpsElem []<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Ipoint">Ipoint</a> <span class="comment">// integration points of element</span>

    <span class="comment">// vectors and matrices</span>
    K [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// element K matrix</span>
    M [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// element M matrix</span>

    <span class="comment">// problem variables</span>
    Umap []<a href="/pkg/builtin/#int">int</a> <span class="comment">// assembly map (location array/element equations)</span>

    <span class="comment">// material model and internal variables</span>
    Mdl       <a href="/pkg/github.com/cpmech/gofem/mdl/sld/">sld</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/sld/#OneD">OneD</a>
    States    []*<a href="/pkg/github.com/cpmech/gofem/mdl/sld/">sld</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/sld/#OnedState">OnedState</a>
    StatesBkp []*<a href="/pkg/github.com/cpmech/gofem/mdl/sld/">sld</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/sld/#OnedState">OnedState</a>
    StatesAux []*<a href="/pkg/github.com/cpmech/gofem/mdl/sld/">sld</a>.<a href="/pkg/github.com/cpmech/gofem/mdl/sld/#OnedState">OnedState</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Rod represents a structural rod element (for only axial loads)
</p>


			

			

			
			
			

			

			
				
				<h3 id="Rod.AddToKb">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=4412:4490#L173">AddToKb</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AddToKb adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="Rod.AddToRhs">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=3745:3808#L142">AddToRhs</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AddToRhs adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="Rod.BackupIvs">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=7445:7490#L303">BackupIvs</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) BackupIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
BackupIvs create copy of internal variables
</p>

				
				
				
			
				
				<h3 id="Rod.Decode">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=8289:8334#L343">Decode</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) Decode(dec <a href="#Decoder">Decoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="Rod.Encode">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=8172:8217#L338">Encode</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) Encode(enc <a href="#Encoder">Encoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="Rod.Id">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=3095:3117#L114">Id</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="Rod.InterpStarVars">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=3467:3522#L129">InterpStarVars</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
InterpStarVars interpolates star variables to integration points
</p>

				
				
				
			
				
				<h3 id="Rod.Ipoints">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=6377:6421#L263">Ipoints</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) Ipoints() (coords [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Ipoints returns the real coordinates of integration points [nip][ndim]
</p>

				
				
				
			
				
				<h3 id="Rod.OutIpCoords">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=8486:8529#L352">OutIpCoords</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) OutIpCoords() (C [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
OutIpCoords returns the coordinates of integration points
</p>

				
				
				
			
				
				<h3 id="Rod.OutIpKeys">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=8713:8747#L361">OutIpKeys</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) OutIpKeys() []<a href="/pkg/builtin/#string">string</a></pre>
				<p>
OutIpKeys returns the integration points&#39; keys
</p>

				
				
				
			
				
				<h3 id="Rod.OutIpVals">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=8851:8900#L366">OutIpVals</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) OutIpVals(M *<a href="#IpsMap">IpsMap</a>, sol *<a href="#Solution">Solution</a>)</pre>
				<p>
OutIpVals returns the integration points&#39; values corresponding to keys
</p>

				
				
				
			
				
				<h3 id="Rod.RestoreIvs">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=7696:7742#L317">RestoreIvs</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) RestoreIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
RestoreIvs restore internal variables from copies
</p>

				
				
				
			
				
				<h3 id="Rod.SetEleConds">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=3574:3649#L134">SetEleConds</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEleConds set element conditions
</p>

				
				
				
			
				
				<h3 id="Rod.SetEqs">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=3164:3230#L117">SetEqs</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEqs set equations
</p>

				
				
				
			
				
				<h3 id="Rod.SetIniIvs">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=6633:6709#L272">SetIniIvs</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) SetIniIvs(sol *<a href="#Solution">Solution</a>, ivs map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetIniIvs sets initial ivs for given values in sol and ivs map
</p>

				
				
				
			
				
				<h3 id="Rod.SetIvs">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=7324:7384#L298">SetIvs</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) SetIvs(zvars map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetIvs set secondary variables; e.g. during initialisation via files
</p>

				
				
				
			
				
				<h3 id="Rod.Update">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=5529:5576#L225">Update</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) Update(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Update perform (tangent) update
</p>

				
				
				
			
				
				<h3 id="Rod.Ureset">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=7971:8018#L331">Ureset</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) Ureset(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Ureset fixes internal variables after u (displacements) have been zeroed
</p>

				
				
				
			
		
			
			
			<h2 id="Solution">type <a href="https://github.com/cpmech/gofem/blob/master/fem/domain.go?s=545:1545#L14">Solution</a></h2>
			<pre>type Solution struct {

    <span class="comment">// current state</span>
    T      <a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// current time</span>
    Y      []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// DOFs (solution variables); e.g. y = {u, p}</span>
    Dydt   []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// dy/dt</span>
    D2ydt2 []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// d²y/dt²</span>

    <span class="comment">// auxiliary</span>
    Dt  <a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// current time increment</span>
    ΔY  []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// total increment (for nonlinear solver)</span>
    Psi []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// t1 star vars; e.g. ψ* = β1.p + β2.dpdt</span>
    Zet []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// t2 star vars; e.g. ζ* = α1.u + α2.v + α3.a</span>
    Chi []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// t2 star vars; e.g. χ* = α4.u + α5.v + α6.a</span>
    L   []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// Lagrange multipliers</span>

    <span class="comment">// extrapolated values</span>
    Ext map[<a href="/pkg/builtin/#int">int</a>][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [optional] extrapolated values. nodeId =&gt; values (e.g. σ)</span>
    Cnt map[<a href="/pkg/builtin/#int">int</a>]<a href="/pkg/builtin/#int">int</a>       <span class="comment">// [optional] counter for number of additions each node of Ext</span>

    <span class="comment">// problem definition and constants</span>
    Steady  <a href="/pkg/builtin/#bool">bool</a>      <span class="comment">// [from Sim] steady simulation</span>
    Axisym  <a href="/pkg/builtin/#bool">bool</a>      <span class="comment">// [from Sim] axisymmetric</span>
    Pstress <a href="/pkg/builtin/#bool">bool</a>      <span class="comment">// [from Sim] plane-stress</span>
    DynCfs  *<a href="#DynCoefs">DynCoefs</a> <span class="comment">// [from FEM] coefficients for dynamics/transient simulations</span>
}</pre>
			<p>
Solution holds the solution data @ nodes.
</p>
<pre>      / u \         / u \
      |   | =&gt; y =  |   |
yb =  | p |         \ p / (ny x 1)
      |   |
      \ λ / (nyb x 1)
</pre>


			

			

			
			
			

			

			
				
				<h3 id="Solution.Reset">func (*Solution) <a href="https://github.com/cpmech/gofem/blob/master/fem/domain.go?s=16006:16043#L545">Reset</a></h3>
				<pre>func (o *<a href="#Solution">Solution</a>) Reset(steady <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Reset clear values
</p>

				
				
				
			
		
			
			
			<h2 id="SolverImplicit">type <a href="https://github.com/cpmech/gofem/blob/master/fem/s_implicit.go?s=454:531#L8">SolverImplicit</a></h2>
			<pre>type SolverImplicit struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
SolverImplicit solves FEM problem using an implicit procedure (with Newthon-Raphson method)
</p>


			

			

			
			
			

			

			
				
				<h3 id="SolverImplicit.Run">func (*SolverImplicit) <a href="https://github.com/cpmech/gofem/blob/master/fem/s_implicit.go?s=760:869#L25">Run</a></h3>
				<pre>func (o *<a href="#SolverImplicit">SolverImplicit</a>) Run(tf <a href="/pkg/builtin/#float64">float64</a>, dtFunc, dtoFunc <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, verbose <a href="/pkg/builtin/#bool">bool</a>, dbgKb <a href="#DebugKb_t">DebugKb_t</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
				
			
		
			
			
			<h2 id="SolverLinearImplicit">type <a href="https://github.com/cpmech/gofem/blob/master/fem/s_linimp.go?s=465:543#L7">SolverLinearImplicit</a></h2>
			<pre>type SolverLinearImplicit struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
SolverLinearImplicit solves **linear** FEM problem using an implicit procedure
(with Newthon-Raphson method)
</p>


			

			

			
			
			

			

			
				
				<h3 id="SolverLinearImplicit.Run">func (*SolverLinearImplicit) <a href="https://github.com/cpmech/gofem/blob/master/fem/s_linimp.go?s=885:1002#L27">Run</a></h3>
				<pre>func (o *<a href="#SolverLinearImplicit">SolverLinearImplicit</a>) Run(tf <a href="/pkg/builtin/#float64">float64</a>, dtFunc, dtoFunc <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, verbose <a href="/pkg/builtin/#bool">bool</a>, notused <a href="#DebugKb_t">DebugKb_t</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
				
			
		
			
			
			<h2 id="Summary">type <a href="https://github.com/cpmech/gofem/blob/master/fem/summary.go?s=353:722#L8">Summary</a></h2>
			<pre>type Summary struct {

    <span class="comment">// main data</span>
    Dirout   <a href="/pkg/builtin/#string">string</a>       <span class="comment">// directory where results are stored</span>
    Fnkey    <a href="/pkg/builtin/#string">string</a>       <span class="comment">// filename key of simulation</span>
    Nproc    <a href="/pkg/builtin/#int">int</a>          <span class="comment">// number of processors</span>
    OutTimes []<a href="/pkg/builtin/#float64">float64</a>    <span class="comment">// [nOutTimes] output times</span>
    Resids   <a href="/pkg/github.com/cpmech/gosl/utl/">utl</a>.<a href="/pkg/github.com/cpmech/gosl/utl/#DblSlist">DblSlist</a> <span class="comment">// residuals (if Stat is on; includes all stages)</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Summary records summary of outputs
</p>


			

			

			
			
			

			

			
				
				<h3 id="Summary.Read">func (*Summary) <a href="https://github.com/cpmech/gofem/blob/master/fem/summary.go?s=1726:1788#L67">Read</a></h3>
				<pre>func (o *<a href="#Summary">Summary</a>) Read(dir, fnkey, enctype <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Read reads summary back
</p>

				
				
				
			
				
				<h3 id="Summary.Save">func (Summary) <a href="https://github.com/cpmech/gofem/blob/master/fem/summary.go?s=1181:1276#L39">Save</a></h3>
				<pre>func (o <a href="#Summary">Summary</a>) Save(dirout, fnkey, enctype <a href="/pkg/builtin/#string">string</a>, nproc, proc <a href="/pkg/builtin/#int">int</a>, verbose <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SaveSums saves summary to disc
</p>

				
				
				
			
				
				<h3 id="Summary.SaveDomains">func (*Summary) <a href="https://github.com/cpmech/gofem/blob/master/fem/summary.go?s=794:879#L22">SaveDomains</a></h3>
				<pre>func (o *<a href="#Summary">Summary</a>) SaveDomains(time <a href="/pkg/builtin/#float64">float64</a>, doms []*<a href="#Domain">Domain</a>, verbose <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SaveDomains save the results from all domains (nodes and elements)
</p>

				
				
				
			
		
			
			
			<h2 id="T_iteration">type <a href="https://github.com/cpmech/gofem/blob/master/fem/testing.go?s=370:507#L8">T_iteration</a></h2>
			<pre>type T_iteration struct {
    It     <a href="/pkg/builtin/#int">int</a>     <span class="comment">// iteration number</span>
    ResRel <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// relative residual</span>
    Resid  <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// absolute residual</span>
}</pre>
			<p>
T_iteration testing: iteration results
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="T_results">type <a href="https://github.com/cpmech/gofem/blob/master/fem/testing.go?s=539:1117#L15">T_results</a></h2>
			<pre>type T_results struct {
    Status     <a href="/pkg/builtin/#string">string</a>        <span class="comment">// status message</span>
    LoadFactor <a href="/pkg/builtin/#float64">float64</a>       <span class="comment">// load factor</span>
    Iterations []<a href="#T_iteration">T_iteration</a> <span class="comment">// iterations data</span>
    Kmats      [][][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nele][nu][nu] all stiffness matrices</span>
    Disp       [][]<a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// [nnod][ndim] displacements at nodes</span>
    DispMult   <a href="/pkg/builtin/#float64">float64</a>       <span class="comment">// displacements multiplier</span>
    Note       <a href="/pkg/builtin/#string">string</a>        <span class="comment">// note about number of integration points</span>
    Stresses   [][][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nele][nip][nsig] all stresses @ all ips</span>

}</pre>
			<p>
T_results testing: results
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="T_results_set">type <a href="https://github.com/cpmech/gofem/blob/master/fem/testing.go?s=1167:1198#L30">T_results_set</a></h2>
			<pre>type T_results_set []*<a href="#T_results">T_results</a></pre>
			<p>
T_results_set is a set of comparison results
</p>


			

			

			
			
			

			

			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	
	<table class="dir">
	<tr>
	<th>Name</th>
	<th>&nbsp;&nbsp;&nbsp;&nbsp;</th>
	<th style="text-align: left; width: auto">Synopsis</th>
	</tr>
	
		<tr>
		<td><a href="..">..</a></td>
		</tr>
	
	
		
			<tr>
			<td class="name"><a href="cmp/">cmp</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto"></td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="data/">data</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto"></td>
			</tr>
		
	
	</table>

	

</div><!-- page -->
<div id="footer">
<br /><br />
<hr>
<pre class="copyright">
Copyright (c) 2015, Dorival Pedroso and Raul Durand
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of gofem nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

</pre><!-- copyright -->
</div><!-- footer -->
</body>
</html>
