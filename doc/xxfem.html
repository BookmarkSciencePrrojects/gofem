<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Gofem &ndash; package fem</title>
<link type="text/css" rel="stylesheet" href="static/style.css">
<script type="text/javascript" src="static/godocs.js"></script>
<style type="text/css"></style>
</head>
<body>
<div id="page"><h1>Gofem &ndash; <b>fem</b> &ndash; finite element method</h1>
<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script type='text/javascript'>
	document.ANALYSIS_DATA = ;
	document.CALLGRAPH = ;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/cpmech/gofem/fem"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				
			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#BuildCoordsMatrix">func BuildCoordsMatrix(c *inp.Cell, msh *inp.Mesh) (x [][]float64)</a></dd>
			
				
				<dd><a href="#DerivSig">func DerivSig(DσDun [][]float64, n, ndim int, G, D [][]float64)</a></dd>
			
				
				<dd><a href="#End">func End()</a></dd>
			
				
				<dd><a href="#FlowKeys">func FlowKeys() []string</a></dd>
			
				
				<dd><a href="#GetAndInitPorousModel">func GetAndInitPorousModel(matname string) *mporous.Model</a></dd>
			
				
				<dd><a href="#GetAndInitSolidModel">func GetAndInitSolidModel(matname string, ndim int) (msolid.Model, fun.Prms)</a></dd>
			
				
				<dd><a href="#GetIntegrationPoints">func GetIntegrationPoints(nip, nipf int, cellType string) (ipsElem, ipsFace []*shp.Ipoint)</a></dd>
			
				
				<dd><a href="#GetIsEssenKeyMap">func GetIsEssenKeyMap() map[string]bool</a></dd>
			
				
				<dd><a href="#GetSeepFaceFlags">func GetSeepFaceFlags(extra string) (Macaulay bool, BetRamp, Kappa float64)</a></dd>
			
				
				<dd><a href="#GetSolidFlags">func GetSolidFlags(extra string) (useB, debug bool, thickness float64)</a></dd>
			
				
				<dd><a href="#GetVertsWithCond">func GetVertsWithCond(fconds []*FaceCond, conds ...string) (verts []int)</a></dd>
			
				
				<dd><a href="#IpAddToKt">func IpAddToKt(Kt [][]float64, nne, ndim int, coef float64, G, D [][]float64)</a></dd>
			
				
				<dd><a href="#IpBmatrix">func IpBmatrix(B [][]float64, ndim, nne int, G [][]float64, radius float64, S []float64)</a></dd>
			
				
				<dd><a href="#IpBmatrix_sparse">func IpBmatrix_sparse(B *la.Triplet, ndim, nne int, G [][]float64, radius float64, S []float64)</a></dd>
			
				
				<dd><a href="#IpStrains">func IpStrains(εs []float64, nne, ndim int, u []float64, Umap []int, G [][]float64)</a></dd>
			
				
				<dd><a href="#IpStrainsAndInc">func IpStrainsAndInc(εs, Δεs []float64, nne, ndim int, u, Δu []float64, Umap []int, G [][]float64)</a></dd>
			
				
				<dd><a href="#IpStrainsAndIncB">func IpStrainsAndIncB(εs, Δεs []float64, nσ, nu int, B [][]float64, u, Δu []float64, Umap []int)</a></dd>
			
				
				<dd><a href="#Ivs2sigmas">func Ivs2sigmas(σ []float64, i int, ivs map[string][]float64)</a></dd>
			
				
				<dd><a href="#LogErr">func LogErr(err error, msg string) (stop bool)</a></dd>
			
				
				<dd><a href="#LogErrCond">func LogErrCond(condition bool, msg string, prm ...interface{}) (stop bool)</a></dd>
			
				
				<dd><a href="#Run">func Run() (runisok bool)</a></dd>
			
				
				<dd><a href="#Start">func Start(simfilepath string, erasefiles, verbose bool) (startisok bool)</a></dd>
			
				
				<dd><a href="#Stop">func Stop() bool</a></dd>
			
				
				<dd><a href="#StressKeys">func StressKeys() []string</a></dd>
			
				
				<dd><a href="#TestingCompareResultsU">func TestingCompareResultsU(tst *testing.T, simfname, cmpfname string, tolK, tolu, tols float64, skipK, verbose bool)</a></dd>
			
			
				
				<dd><a href="#Beam">type Beam</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.AddToKb">func (o Beam) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.AddToRhs">func (o Beam) AddToRhs(fb []float64, sol *Solution) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.Decode">func (o Beam) Decode(dec Decoder) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.Encode">func (o Beam) Encode(enc Encoder) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.Id">func (o Beam) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.InterpStarVars">func (o *Beam) InterpStarVars(sol *Solution) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.OutIpsData">func (o Beam) OutIpsData() (data []*OutIpData)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.SetEleConds">func (o *Beam) SetEleConds(key string, f fun.Func, extra string) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.SetEqs">func (o *Beam) SetEqs(eqs [][]int, mixedform_eqs []int) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.Update">func (o *Beam) Update(sol *Solution) (ok bool)</a></dd>
				
			
				
				<dd><a href="#Decoder">type Decoder</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GetDecoder">func GetDecoder(r goio.Reader) Decoder</a></dd>
				
				
			
				
				<dd><a href="#Dof">type Dof</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Dof.String">func (o *Dof) String() string</a></dd>
				
			
				
				<dd><a href="#Domain">type Domain</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewDomain">func NewDomain(reg *inp.Region, distr bool) *Domain</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.In">func (o *Domain) In(sum *Summary, tidx int, allInOne bool) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.Out">func (o *Domain) Out(tidx int) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.ReadIvs">func (o *Domain) ReadIvs(dir, fnkey string, tidx, proc int) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.ReadSol">func (o *Domain) ReadSol(dir, fnkey string, tidx int) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.SaveIvs">func (o Domain) SaveIvs(tidx int) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.SaveSol">func (o Domain) SaveSol(tidx int) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.SetGeoSt">func (o *Domain) SetGeoSt(stg *inp.Stage) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.SetHydroSt">func (o *Domain) SetHydroSt(stg *inp.Stage) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.SetIniStress">func (o *Domain) SetIniStress(stg *inp.Stage) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.SetStage">func (o *Domain) SetStage(idxstg int, stg *inp.Stage, distr bool) (setstageisok bool)</a></dd>
				
			
				
				<dd><a href="#DynCoefs">type DynCoefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#DynCoefs.CalcAlphas">func (o *DynCoefs) CalcAlphas(Δt float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DynCoefs.CalcBetas">func (o *DynCoefs) CalcBetas(Δt float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DynCoefs.CalcBoth">func (o *DynCoefs) CalcBoth(Δt float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DynCoefs.Init">func (o *DynCoefs) Init(dat *inp.SolverData) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DynCoefs.Print">func (o *DynCoefs) Print()</a></dd>
				
			
				
				<dd><a href="#Elem">type Elem</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewElem">func NewElem(edat *inp.ElemData, cid int, msh *inp.Mesh, faceConds []*FaceCond) Elem</a></dd>
				
				
			
				
				<dd><a href="#ElemConnector">type ElemConnector</a></dd>
				
				
			
				
				<dd><a href="#ElemIntvars">type ElemIntvars</a></dd>
				
				
			
				
				<dd><a href="#ElemP">type ElemP</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.AddToKb">func (o ElemP) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.AddToRhs">func (o ElemP) AddToRhs(fb []float64, sol *Solution) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.BackupIvs">func (o *ElemP) BackupIvs(aux bool) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.Decode">func (o ElemP) Decode(dec Decoder) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.Encode">func (o ElemP) Encode(enc Encoder) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.Id">func (o ElemP) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.InterpStarVars">func (o *ElemP) InterpStarVars(sol *Solution) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.Ipoints">func (o ElemP) Ipoints() (coords [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.OutIpsData">func (o ElemP) OutIpsData() (data []*OutIpData)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.RestoreIvs">func (o *ElemP) RestoreIvs(aux bool) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.SetEleConds">func (o *ElemP) SetEleConds(key string, f fun.Func, extra string) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.SetEqs">func (o *ElemP) SetEqs(eqs [][]int, mixedform_eqs []int) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.SetIniIvs">func (o *ElemP) SetIniIvs(sol *Solution, ignored map[string][]float64) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.Update">func (o *ElemP) Update(sol *Solution) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.Ureset">func (o *ElemP) Ureset(sol *Solution) (ok bool)</a></dd>
				
			
				
				<dd><a href="#ElemPhi">type ElemPhi</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.AddToKb">func (o *ElemPhi) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.AddToRhs">func (o *ElemPhi) AddToRhs(fb []float64, sol *Solution) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.Decode">func (o *ElemPhi) Decode(dec Decoder) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.Encode">func (o *ElemPhi) Encode(enc Encoder) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.Id">func (o *ElemPhi) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.InterpStarVars">func (o *ElemPhi) InterpStarVars(sol *Solution) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.OutIpsData">func (o *ElemPhi) OutIpsData() (data []*OutIpData)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.SetEleConds">func (o *ElemPhi) SetEleConds(key string, f fun.Func, extra string) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.SetEqs">func (o *ElemPhi) SetEqs(eqs [][]int, mixedform_eqs []int) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.Update">func (o *ElemPhi) Update(sol *Solution) (ok bool)</a></dd>
				
			
				
				<dd><a href="#ElemU">type ElemU</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.AddToKb">func (o *ElemU) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.AddToRhs">func (o *ElemU) AddToRhs(fb []float64, sol *Solution) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.BackupIvs">func (o *ElemU) BackupIvs(aux bool) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.Decode">func (o ElemU) Decode(dec Decoder) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.Encode">func (o ElemU) Encode(enc Encoder) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.Id">func (o ElemU) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.InterpStarVars">func (o *ElemU) InterpStarVars(sol *Solution) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.Ipoints">func (o ElemU) Ipoints() (coords [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.OutIpsData">func (o ElemU) OutIpsData() (data []*OutIpData)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.RestoreIvs">func (o *ElemU) RestoreIvs(aux bool) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.SetEleConds">func (o *ElemU) SetEleConds(key string, f fun.Func, extra string) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.SetEqs">func (o *ElemU) SetEqs(eqs [][]int, mixedform_eqs []int) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.SetIniIvs">func (o *ElemU) SetIniIvs(sol *Solution, ivs map[string][]float64) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.Update">func (o *ElemU) Update(sol *Solution) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.Ureset">func (o *ElemU) Ureset(sol *Solution) (ok bool)</a></dd>
				
			
				
				<dd><a href="#ElemUP">type ElemUP</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.AddToKb">func (o ElemUP) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.AddToRhs">func (o ElemUP) AddToRhs(fb []float64, sol *Solution) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.BackupIvs">func (o *ElemUP) BackupIvs(aux bool) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.Decode">func (o ElemUP) Decode(dec Decoder) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.Encode">func (o ElemUP) Encode(enc Encoder) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.Id">func (o ElemUP) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.InterpStarVars">func (o *ElemUP) InterpStarVars(sol *Solution) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.Ipoints">func (o ElemUP) Ipoints() (coords [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.OutIpsData">func (o ElemUP) OutIpsData() (data []*OutIpData)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.RestoreIvs">func (o *ElemUP) RestoreIvs(aux bool) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.SetEleConds">func (o *ElemUP) SetEleConds(key string, f fun.Func, extra string) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.SetEqs">func (o *ElemUP) SetEqs(eqs [][]int, mixedform_eqs []int) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.SetIniIvs">func (o *ElemUP) SetIniIvs(sol *Solution, ivs map[string][]float64) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.Update">func (o *ElemUP) Update(sol *Solution) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.Ureset">func (o *ElemUP) Ureset(sol *Solution) (ok bool)</a></dd>
				
			
				
				<dd><a href="#Encoder">type Encoder</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GetEncoder">func GetEncoder(w goio.Writer) Encoder</a></dd>
				
				
			
				
				<dd><a href="#EssentialBc">type EssentialBc</a></dd>
				
				
			
				
				<dd><a href="#EssentialBcs">type EssentialBcs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EssentialBcs.AddToRhs">func (o EssentialBcs) AddToRhs(fb []float64, sol *Solution)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EssentialBcs.Build">func (o *EssentialBcs) Build(ny int) (nλ, nnzA int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EssentialBcs.List">func (o *EssentialBcs) List(t float64) (l string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EssentialBcs.Reset">func (o *EssentialBcs) Reset()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EssentialBcs.Set">func (o *EssentialBcs) Set(key string, nodes []*Node, fcn fun.Func, extra string) (setisok bool)</a></dd>
				
			
				
				<dd><a href="#FaceCond">type FaceCond</a></dd>
				
				
			
				
				<dd><a href="#GeoLayer">type GeoLayer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#GeoLayer.Calc">func (o GeoLayer) Calc(z float64) (*geostate, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GeoLayer.Start">func (o *GeoLayer) Start(prev *geostate)</a></dd>
				
			
				
				<dd><a href="#GeoLayers">type GeoLayers</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#GeoLayers.Len">func (o GeoLayers) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GeoLayers.Less">func (o GeoLayers) Less(i, j int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GeoLayers.String">func (o GeoLayers) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GeoLayers.Swap">func (o GeoLayers) Swap(i, j int)</a></dd>
				
			
				
				<dd><a href="#HydroStatic">type HydroStatic</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#HydroStatic.Calc">func (o HydroStatic) Calc(z float64) (pl, ρL float64, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#HydroStatic.Init">func (o *HydroStatic) Init()</a></dd>
				
			
				
				<dd><a href="#Info">type Info</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GetElemInfo">func GetElemInfo(cellType, elemType string, faceConds []*FaceCond) *Info</a></dd>
				
				
			
				
				<dd><a href="#NaturalBc">type NaturalBc</a></dd>
				
				
			
				
				<dd><a href="#Node">type Node</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewNode">func NewNode(v *inp.Vert) *Node</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.AddDofAndEq">func (o *Node) AddDofAndEq(ukey string, eqnum int) (nexteq int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.GetDof">func (o *Node) GetDof(ukey string) *Dof</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.GetEq">func (o *Node) GetEq(ukey string) (eqNumber int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.GetKeys">func (o *Node) GetKeys() []string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.SetEq">func (o *Node) SetEq(ukey string, eqNumber int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.String">func (o *Node) String() string</a></dd>
				
			
				
				<dd><a href="#OutIpData">type OutIpData</a></dd>
				
				
			
				
				<dd><a href="#PtNaturalBc">type PtNaturalBc</a></dd>
				
				
			
				
				<dd><a href="#PtNaturalBcs">type PtNaturalBcs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PtNaturalBcs.AddToRhs">func (o PtNaturalBcs) AddToRhs(fb []float64, t float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PtNaturalBcs.List">func (o *PtNaturalBcs) List(t float64) (l string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PtNaturalBcs.Reset">func (o *PtNaturalBcs) Reset()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PtNaturalBcs.Set">func (o *PtNaturalBcs) Set(key string, nod *Node, fcn fun.Func, extra string) (setisok bool)</a></dd>
				
			
				
				<dd><a href="#RichardsonExtrap">type RichardsonExtrap</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RichardsonExtrap.Init">func (o *RichardsonExtrap) Init(d *Domain, Dt fun.Func)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RichardsonExtrap.Run">func (o *RichardsonExtrap) Run(d *Domain, s *Summary, DtOut fun.Func, time *float64, tf, tout float64, tidx *int) (ok bool)</a></dd>
				
			
				
				<dd><a href="#Rjoint">type Rjoint</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.AddToKb">func (o *Rjoint) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.AddToRhs">func (o *Rjoint) AddToRhs(fb []float64, sol *Solution) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.BackupIvs">func (o *Rjoint) BackupIvs(aux bool) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.Connect">func (o *Rjoint) Connect(cid2elem []Elem, c *inp.Cell) (nnzK int, ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.Decode">func (o Rjoint) Decode(dec Decoder) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.Encode">func (o Rjoint) Encode(enc Encoder) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.Id">func (o Rjoint) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.InterpStarVars">func (o *Rjoint) InterpStarVars(sol *Solution) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.Ipoints">func (o Rjoint) Ipoints() (coords [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.OutIpsData">func (o Rjoint) OutIpsData() (data []*OutIpData)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.RestoreIvs">func (o *Rjoint) RestoreIvs(aux bool) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.SetEleConds">func (o *Rjoint) SetEleConds(key string, f fun.Func, extra string) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.SetEqs">func (o *Rjoint) SetEqs(eqs [][]int, mixedform_eqs []int) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.SetIniIvs">func (o *Rjoint) SetIniIvs(sol *Solution, ivs map[string][]float64) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.Update">func (o *Rjoint) Update(sol *Solution) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.Ureset">func (o *Rjoint) Ureset(sol *Solution) (ok bool)</a></dd>
				
			
				
				<dd><a href="#Rod">type Rod</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.AddToKb">func (o Rod) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.AddToRhs">func (o Rod) AddToRhs(fb []float64, sol *Solution) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.BackupIvs">func (o *Rod) BackupIvs(aux bool) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.Decode">func (o Rod) Decode(dec Decoder) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.Encode">func (o Rod) Encode(enc Encoder) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.Id">func (o Rod) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.InterpStarVars">func (o *Rod) InterpStarVars(sol *Solution) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.Ipoints">func (o Rod) Ipoints() (coords [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.OutIpsData">func (o Rod) OutIpsData() (data []*OutIpData)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.RestoreIvs">func (o *Rod) RestoreIvs(aux bool) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.SetEleConds">func (o *Rod) SetEleConds(key string, f fun.Func, extra string) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.SetEqs">func (o *Rod) SetEqs(eqs [][]int, mixedform_eqs []int) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.SetIniIvs">func (o *Rod) SetIniIvs(sol *Solution, ivs map[string][]float64) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.SetIvs">func (o *Rod) SetIvs(zvars map[string][]float64) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.Update">func (o *Rod) Update(sol *Solution) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.Ureset">func (o *Rod) Ureset(sol *Solution) (ok bool)</a></dd>
				
			
				
				<dd><a href="#Solution">type Solution</a></dd>
				
				
			
				
				<dd><a href="#Summary">type Summary</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ReadSum">func ReadSum(dir, fnkey string) (o *Summary)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Summary.Save">func (o Summary) Save() (ok bool)</a></dd>
				
			
				
				<dd><a href="#T_iteration">type T_iteration</a></dd>
				
				
			
				
				<dd><a href="#T_results">type T_results</a></dd>
				
				
			
				
				<dd><a href="#T_results_set">type T_results_set</a></dd>
				
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/github.com/cpmech/gofem/fem/auxiliary.go">auxiliary.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/auxsolid.go">auxsolid.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/domain.go">domain.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/dyncoefs.go">dyncoefs.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_beam.go">e_beam.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_p.go">e_p.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_phi.go">e_phi.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_rjoint.go">e_rjoint.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_rod.go">e_rod.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_u.go">e_u.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_up.go">e_up.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/element.go">element.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/errorhandler.go">errorhandler.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/essenbcs.go">essenbcs.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/fileio.go">fileio.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/geost.go">geost.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/hydrost.go">hydrost.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/inistress.go">inistress.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/keycodes.go">keycodes.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/matmodels.go">matmodels.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/naturalbcs.go">naturalbcs.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/node.go">node.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/ptnatbcs.go">ptnatbcs.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/richardson.go">richardson.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/solver.go">solver.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/summary.go">summary.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/testing.go">testing.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		<div id="pkg-callgraph" class="toggle" style="display: none">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
		</div> <!-- .expanded -->
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
			<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls&mdash;perhaps dynamically.
			</p>
			<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
			<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
			<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
			<!-- Zero means show all package entry points. -->
			<ul style="margin-left: 0.5in" id="callgraph-0" class="treeview"></ul>
		</div>
		</div> <!-- #pkg-callgraph -->

		
			<h2 id="pkg-constants">Constants</h2>
			
				<pre>const <span id="SQ2">SQ2</span> = <a href="/pkg/math/">math</a>.<a href="/pkg/math/#Sqrt2">Sqrt2</a></pre>
				
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<pre>var <span id="Global">Global</span> struct {

    <span class="comment">// constants</span>
    LogPrefix <a href="/pkg/builtin/#string">string</a> <span class="comment">// extra string to prefix log file</span>

    <span class="comment">// multiprocessing data</span>
    Rank     <a href="/pkg/builtin/#int">int</a>   <span class="comment">// my rank in distributed cluster</span>
    Nproc    <a href="/pkg/builtin/#int">int</a>   <span class="comment">// number of processors</span>
    Root     <a href="/pkg/builtin/#bool">bool</a>  <span class="comment">// am I root? (i.e. myrank == 0)</span>
    Distr    <a href="/pkg/builtin/#bool">bool</a>  <span class="comment">// distributed simulation with more than one mpi processor</span>
    Verbose  <a href="/pkg/builtin/#bool">bool</a>  <span class="comment">// verbose == root</span>
    WspcStop []<a href="/pkg/builtin/#int">int</a> <span class="comment">// stop flags [nprocs]</span>
    WspcInum []<a href="/pkg/builtin/#int">int</a> <span class="comment">// workspace of integer numbers [nprocs]</span>

    <span class="comment">// simulation, materials, meshes and convenience variables</span>
    Sim    *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Simulation">Simulation</a> <span class="comment">// simulation data</span>
    Ndim   <a href="/pkg/builtin/#int">int</a>             <span class="comment">// space dimension</span>
    Dirout <a href="/pkg/builtin/#string">string</a>          <span class="comment">// directory for output of results</span>
    Fnkey  <a href="/pkg/builtin/#string">string</a>          <span class="comment">// filename key; e.g. mysim.sim =&gt; mysim</span>
    Enc    <a href="/pkg/builtin/#string">string</a>          <span class="comment">// encoder; e.g. &#34;gob&#34; or &#34;json&#34;</span>
    Stat   <a href="/pkg/builtin/#bool">bool</a>            <span class="comment">// save residuals in summary</span>
    LogBcs <a href="/pkg/builtin/#bool">bool</a>            <span class="comment">// log essential and ptnatural boundary conditions</span>
    Debug  <a href="/pkg/builtin/#bool">bool</a>            <span class="comment">// debug flag</span>

    <span class="comment">// auxiliar structures</span>
    DynCoefs *<a href="#DynCoefs">DynCoefs</a>    <span class="comment">// dynamic coefficients</span>
    HydroSt  *<a href="#HydroStatic">HydroStatic</a> <span class="comment">// computes hydrostatic states</span>

    <span class="comment">// for debugging</span>
    DebugKb func(d *<a href="#Domain">Domain</a>, it <a href="/pkg/builtin/#int">int</a>) <span class="comment">// debug Kb callback function</span>
}</pre>
				<p>
Global holds global data
</p>

			
		
		
			
			
			<h2 id="BuildCoordsMatrix">func <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=4322:4388#L99">BuildCoordsMatrix</a></h2>
			<pre>func BuildCoordsMatrix(c *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>, msh *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Mesh">Mesh</a>) (x [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
BuildCoordsMatrix returns the coordinate matrix of a particular Cell
</p>

			
			

		
			
			
			<h2 id="DerivSig">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=4943:5007#L74">DerivSig</a></h2>
			<pre>func DerivSig(DσDun [][]<a href="/pkg/builtin/#float64">float64</a>, n, ndim <a href="/pkg/builtin/#int">int</a>, G, D [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
DerivSig returns the derivative of σ (Mandel) with respect to displacement at nodes
</p>
<pre>Note: DσDun = ∂σ/∂un  [nσ][ndim]
</pre>

			
			

		
			
			
			<h2 id="End">func <a href="https://github.com/cpmech/gofem/blob/master/fem/solver.go?s=1739:1749#L47">End</a></h2>
			<pre>func End()</pre>
			<p>
End must be called and the end to flush log file
</p>

			
			

		
			
			
			<h2 id="FlowKeys">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=9575:9599#L216">FlowKeys</a></h2>
			<pre>func FlowKeys() []<a href="/pkg/builtin/#string">string</a></pre>
			
			
			

		
			
			
			<h2 id="GetAndInitPorousModel">func <a href="https://github.com/cpmech/gofem/blob/master/fem/matmodels.go?s=505:562#L9">GetAndInitPorousModel</a></h2>
			<pre>func GetAndInitPorousModel(matname <a href="/pkg/builtin/#string">string</a>) *<a href="/pkg/github.com/cpmech/gofem/mporous/">mporous</a>.<a href="/pkg/github.com/cpmech/gofem/mporous/#Model">Model</a></pre>
			<p>
GetAndInitPorousModel get porous model from material name
It returns nil on errors, after logging
</p>

			
			

		
			
			
			<h2 id="GetAndInitSolidModel">func <a href="https://github.com/cpmech/gofem/blob/master/fem/matmodels.go?s=1787:1863#L53">GetAndInitSolidModel</a></h2>
			<pre>func GetAndInitSolidModel(matname <a href="/pkg/builtin/#string">string</a>, ndim <a href="/pkg/builtin/#int">int</a>) (<a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#Model">Model</a>, <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Prms">Prms</a>)</pre>
			
			
			

		
			
			
			<h2 id="GetIntegrationPoints">func <a href="https://github.com/cpmech/gofem/blob/master/fem/keycodes.go?s=271:361#L4">GetIntegrationPoints</a></h2>
			<pre>func GetIntegrationPoints(nip, nipf <a href="/pkg/builtin/#int">int</a>, cellType <a href="/pkg/builtin/#string">string</a>) (ipsElem, ipsFace []*<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Ipoint">Ipoint</a>)</pre>
			
			
			

		
			
			
			<h2 id="GetIsEssenKeyMap">func <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=4148:4187#L131">GetIsEssenKeyMap</a></h2>
			<pre>func GetIsEssenKeyMap() map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
GetFirstYandCmap returns the initial &#34;yandc&#34; map with additional keys that EssentialBcs can handle
</p>
<pre>rigid  -- define rigid element constraints
incsup -- inclined support constraints
hst    -- set hydrostatic pressures
</pre>

			
			

		
			
			
			<h2 id="GetSeepFaceFlags">func <a href="https://github.com/cpmech/gofem/blob/master/fem/keycodes.go?s=1524:1599#L56">GetSeepFaceFlags</a></h2>
			<pre>func GetSeepFaceFlags(extra <a href="/pkg/builtin/#string">string</a>) (Macaulay <a href="/pkg/builtin/#bool">bool</a>, BetRamp, Kappa <a href="/pkg/builtin/#float64">float64</a>)</pre>
			
			
			

		
			
			
			<h2 id="GetSolidFlags">func <a href="https://github.com/cpmech/gofem/blob/master/fem/keycodes.go?s=863:933#L22">GetSolidFlags</a></h2>
			<pre>func GetSolidFlags(extra <a href="/pkg/builtin/#string">string</a>) (useB, debug <a href="/pkg/builtin/#bool">bool</a>, thickness <a href="/pkg/builtin/#float64">float64</a>)</pre>
			
			
			

		
			
			
			<h2 id="GetVertsWithCond">func <a href="https://github.com/cpmech/gofem/blob/master/fem/domain.go?s=1819:1891#L42">GetVertsWithCond</a></h2>
			<pre>func GetVertsWithCond(fconds []*<a href="#FaceCond">FaceCond</a>, conds ...<a href="/pkg/builtin/#string">string</a>) (verts []<a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
GetVertsWithCond gets all vertices with any of the given conditions
</p>
<pre>&#34;seepH&#34; =&gt; localVerts={1,2,3}
</pre>

			
			

		
			
			
			<h2 id="IpAddToKt">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=294:371#L6">IpAddToKt</a></h2>
			<pre>func IpAddToKt(Kt [][]<a href="/pkg/builtin/#float64">float64</a>, nne, ndim <a href="/pkg/builtin/#int">int</a>, coef <a href="/pkg/builtin/#float64">float64</a>, G, D [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			
			
			

		
			
			
			<h2 id="IpBmatrix">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=7076:7164#L106">IpBmatrix</a></h2>
			<pre>func IpBmatrix(B [][]<a href="/pkg/builtin/#float64">float64</a>, ndim, nne <a href="/pkg/builtin/#int">int</a>, G [][]<a href="/pkg/builtin/#float64">float64</a>, radius <a href="/pkg/builtin/#float64">float64</a>, S []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			
			
			

		
			
			
			<h2 id="IpBmatrix_sparse">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=8116:8211#L149">IpBmatrix_sparse</a></h2>
			<pre>func IpBmatrix_sparse(B *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, ndim, nne <a href="/pkg/builtin/#int">int</a>, G [][]<a href="/pkg/builtin/#float64">float64</a>, radius <a href="/pkg/builtin/#float64">float64</a>, S []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			
			
			

		
			
			
			<h2 id="IpStrains">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=3773:3857#L33">IpStrains</a></h2>
			<pre>func IpStrains(εs []<a href="/pkg/builtin/#float64">float64</a>, nne, ndim <a href="/pkg/builtin/#int">int</a>, u []<a href="/pkg/builtin/#float64">float64</a>, Umap []<a href="/pkg/builtin/#int">int</a>, G [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			
			
			

		
			
			
			<h2 id="IpStrainsAndInc">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=4212:4314#L51">IpStrainsAndInc</a></h2>
			<pre>func IpStrainsAndInc(εs, Δεs []<a href="/pkg/builtin/#float64">float64</a>, nne, ndim <a href="/pkg/builtin/#int">int</a>, u, Δu []<a href="/pkg/builtin/#float64">float64</a>, Umap []<a href="/pkg/builtin/#int">int</a>, G [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			
			
			

		
			
			
			<h2 id="IpStrainsAndIncB">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=7848:7949#L139">IpStrainsAndIncB</a></h2>
			<pre>func IpStrainsAndIncB(εs, Δεs []<a href="/pkg/builtin/#float64">float64</a>, nσ, nu <a href="/pkg/builtin/#int">int</a>, B [][]<a href="/pkg/builtin/#float64">float64</a>, u, Δu []<a href="/pkg/builtin/#float64">float64</a>, Umap []<a href="/pkg/builtin/#int">int</a>)</pre>
			
			
			

		
			
			
			<h2 id="Ivs2sigmas">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=9051:9113#L186">Ivs2sigmas</a></h2>
			<pre>func Ivs2sigmas(σ []<a href="/pkg/builtin/#float64">float64</a>, i <a href="/pkg/builtin/#int">int</a>, ivs map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Ivs2sigmas converts ivs map to σ values [nsig]
</p>
<pre>σ -- [ndim] stresses
i -- index of integration point
</pre>

			
			

		
			
			
			<h2 id="LogErr">func <a href="https://github.com/cpmech/gofem/blob/master/fem/errorhandler.go?s=299:345#L5">LogErr</a></h2>
			<pre>func LogErr(err <a href="/pkg/builtin/#error">error</a>, msg <a href="/pkg/builtin/#string">string</a>) (stop <a href="/pkg/builtin/#bool">bool</a>)</pre>
			
			
			

		
			
			
			<h2 id="LogErrCond">func <a href="https://github.com/cpmech/gofem/blob/master/fem/errorhandler.go?s=501:576#L15">LogErrCond</a></h2>
			<pre>func LogErrCond(condition <a href="/pkg/builtin/#bool">bool</a>, msg <a href="/pkg/builtin/#string">string</a>, prm ...interface{}) (stop <a href="/pkg/builtin/#bool">bool</a>)</pre>
			
			
			

		
			
			
			<h2 id="Run">func <a href="https://github.com/cpmech/gofem/blob/master/fem/solver.go?s=3132:3157#L106">Run</a></h2>
			<pre>func Run() (runisok <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
Run runs FE simulation
</p>

			
			

		
			
			
			<h2 id="Start">func <a href="https://github.com/cpmech/gofem/blob/master/fem/solver.go?s=1820:1893#L52">Start</a></h2>
			<pre>func Start(simfilepath <a href="/pkg/builtin/#string">string</a>, erasefiles, verbose <a href="/pkg/builtin/#bool">bool</a>) (startisok <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
Start initialises &#39;global&#39; and starts logging
</p>

			
			

		
			
			
			<h2 id="Stop">func <a href="https://github.com/cpmech/gofem/blob/master/fem/errorhandler.go?s=724:740#L25">Stop</a></h2>
			<pre>func Stop() <a href="/pkg/builtin/#bool">bool</a></pre>
			
			
			

		
			
			
			<h2 id="StressKeys">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=9418:9444#L209">StressKeys</a></h2>
			<pre>func StressKeys() []<a href="/pkg/builtin/#string">string</a></pre>
			
			
			

		
			
			
			<h2 id="TestingCompareResultsU">func <a href="https://github.com/cpmech/gofem/blob/master/fem/testing.go?s=1257:1374#L32">TestingCompareResultsU</a></h2>
			<pre>func TestingCompareResultsU(tst *<a href="/pkg/testing/">testing</a>.<a href="/pkg/testing/#T">T</a>, simfname, cmpfname <a href="/pkg/builtin/#string">string</a>, tolK, tolu, tols <a href="/pkg/builtin/#float64">float64</a>, skipK, verbose <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
testing_compare_results_u compares results with u-formulation
</p>

			
			

		
		
			
			
			<h2 id="Beam">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=381:1608#L7">Beam</a></h2>
			<pre>type Beam struct {

    <span class="comment">// basic data</span>
    Cid <a href="/pkg/builtin/#int">int</a>         <span class="comment">// cell/element id</span>
    X   [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// matrix of nodal coordinates [ndim][nnode]</span>
    Nu  <a href="/pkg/builtin/#int">int</a>         <span class="comment">// total number of unknowns == 2 * nsn</span>

    <span class="comment">// parameters</span>
    E   <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// Young&#39;s modulus</span>
    A   <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// cross-sectional area</span>
    Izz <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// Inertia zz</span>

    <span class="comment">// variables for dynamics</span>
    Rho  <a href="/pkg/builtin/#float64">float64</a>  <span class="comment">// density of solids</span>
    Gfcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// gravity function</span>

    <span class="comment">// vectors and matrices</span>
    T   [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// global-to-local transformation matrix [nnode*ndim][nnode*ndim]</span>
    Kl  [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// local K matrix</span>
    K   [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// global K matrix</span>
    Ml  [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// local M matrices</span>
    M   [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// global M matrices</span>
    Rus []<a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// residual: Rus = fi - fx</span>

    <span class="comment">// problem variables</span>
    Umap []<a href="/pkg/builtin/#int">int</a>    <span class="comment">// assembly map (location array/element equations)</span>
    Hasq <a href="/pkg/builtin/#bool">bool</a>     <span class="comment">// has distributed loads</span>
    QnL  <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// distributed normal load functions: left</span>
    QnR  <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// distributed normal load functions: right</span>
    Qt   <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// distributed tangential load</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Beam represents a structural beam element (Euler-Bernoulli, linear elastic)
</p>


			

			

			
			
			

			

			
				
				<h3 id="Beam.AddToKb">func (Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=7220:7296#L300">AddToKb</a></h3>
				<pre>func (o <a href="#Beam">Beam</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="Beam.AddToRhs">func (Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=6143:6204#L255">AddToRhs</a></h3>
				<pre>func (o <a href="#Beam">Beam</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="Beam.Decode">func (Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=7826:7869#L329">Decode</a></h3>
				<pre>func (o <a href="#Beam">Beam</a>) Decode(dec <a href="#Decoder">Decoder</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="Beam.Encode">func (Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=7727:7770#L324">Encode</a></h3>
				<pre>func (o <a href="#Beam">Beam</a>) Encode(enc <a href="#Encoder">Encoder</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="Beam.Id">func (Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=4987:5009#L198">Id</a></h3>
				<pre>func (o <a href="#Beam">Beam</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="Beam.InterpStarVars">func (*Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=5903:5957#L240">InterpStarVars</a></h3>
				<pre>func (o *<a href="#Beam">Beam</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
InterpStarVars interpolates star variables to integration points
</p>

				
				
				
			
				
				<h3 id="Beam.OutIpsData">func (Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=7954:8000#L334">OutIpsData</a></h3>
				<pre>func (o <a href="#Beam">Beam</a>) OutIpsData() (data []*<a href="#OutIpData">OutIpData</a>)</pre>
				<p>
OutIpsData returns data from all integration points for output
</p>

				
				
				
			
				
				<h3 id="Beam.SetEleConds">func (*Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=5385:5459#L214">SetEleConds</a></h3>
				<pre>func (o *<a href="#Beam">Beam</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetEleConds set element conditions
</p>

				
				
				
			
				
				<h3 id="Beam.SetEqs">func (*Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=5097:5162#L201">SetEqs</a></h3>
				<pre>func (o *<a href="#Beam">Beam</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetEqs set equations [2][?]. Format of eqs == format of info.Dofs
</p>

				
				
				
			
				
				<h3 id="Beam.Update">func (*Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=7625:7671#L319">Update</a></h3>
				<pre>func (o *<a href="#Beam">Beam</a>) Update(sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Update perform (tangent) update
</p>

				
				
				
			
		
			
			
			<h2 id="Decoder">type <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=448:503#L14">Decoder</a></h2>
			<pre>type Decoder interface {
    Decode(e interface{}) <a href="/pkg/builtin/#error">error</a>
}</pre>
			<p>
Decoder defines decoders; e.g. gob or json
</p>


			

			

			
			
			

			
				
				<h3 id="GetDecoder">func <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=705:743#L27">GetDecoder</a></h3>
				<pre>func GetDecoder(r <a href="/pkg/io/">goio</a>.<a href="/pkg/io/#Reader">Reader</a>) <a href="#Decoder">Decoder</a></pre>
				<p>
GetDecoder returns a new decoder
</p>

				
				
			

			
		
			
			
			<h2 id="Dof">type <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=335:432#L4">Dof</a></h2>
			<pre>type Dof struct {
    Key <a href="/pkg/builtin/#string">string</a> <span class="comment">// primary variable key. e.g. &#34;ux&#34;</span>
    Eq  <a href="/pkg/builtin/#int">int</a>    <span class="comment">// equation number</span>
}</pre>
			<p>
Dof holds information about a degree-of-freedom == solution variable
</p>


			

			

			
			
			

			

			
				
				<h3 id="Dof.String">func (*Dof) <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=490:519#L10">String</a></h3>
				<pre>func (o *<a href="#Dof">Dof</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
String returns the string representation of this Dof
</p>

				
				
				
			
		
			
			
			<h2 id="Domain">type <a href="https://github.com/cpmech/gofem/blob/master/fem/domain.go?s=3145:5577#L88">Domain</a></h2>
			<pre>type Domain struct {

    <span class="comment">// init: region, mesh, linear solver</span>
    Reg    *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Region">Region</a> <span class="comment">// region data</span>
    Msh    *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Mesh">Mesh</a>   <span class="comment">// mesh data</span>
    LinSol <a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#LinSol">LinSol</a>   <span class="comment">// linear solver</span>

    <span class="comment">// stage: auxiliary maps for setting boundary conditions</span>
    FaceConds map[<a href="/pkg/builtin/#int">int</a>][]*<a href="#FaceCond">FaceCond</a> <span class="comment">// maps cell id to its face boundary conditions</span>

    <span class="comment">// stage: nodes (active) and elements (active AND in this processor)</span>
    Nodes  []*<a href="#Node">Node</a> <span class="comment">// active nodes (for each stage)</span>
    Elems  []<a href="#Elem">Elem</a>  <span class="comment">// [procNcells] only active elements in this processor (for each stage)</span>
    MyCids []<a href="/pkg/builtin/#int">int</a>   <span class="comment">// [procNcells] the ids of cells in this processor</span>

    <span class="comment">// stage: auxiliary maps for dofs and equation types</span>
    F2Y      map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#string">string</a> <span class="comment">// converts f-keys to y-keys; e.g.: &#34;ux&#34; =&gt; &#34;fx&#34;</span>
    YandC    map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#bool">bool</a>   <span class="comment">// y and constraints keys; e.g. &#34;ux&#34;, &#34;pl&#34;, &#34;H&#34;, &#34;incsup&#34;, &#34;rigid&#34;</span>
    Dof2Tnum map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#int">int</a>    <span class="comment">// {t1,t2}-types: dof =&gt; t_number; e.g. &#34;ux&#34; =&gt; 2, &#34;pl&#34; =&gt; 1</span>

    <span class="comment">// stage: auxiliary maps for nodes and elements</span>
    Vid2node   []*<a href="#Node">Node</a> <span class="comment">// [nverts] VertexId =&gt; index in Nodes. Inactive vertices are &#39;nil&#39;</span>
    Cid2elem   []<a href="#Elem">Elem</a>  <span class="comment">// [ncells] CellId =&gt; index in Elems. Cells in other processors or inactive are &#39;nil&#39;</span>
    Cid2active []<a href="/pkg/builtin/#bool">bool</a>  <span class="comment">// [ncells] CellId =&gt; whether cell is active or not in ANY processor</span>

    <span class="comment">// stage: subsets of elements</span>
    ElemIntvars []<a href="#ElemIntvars">ElemIntvars</a>   <span class="comment">// elements with internal vars in this processor</span>
    ElemConnect []<a href="#ElemConnector">ElemConnector</a> <span class="comment">// connector elements in this processor</span>

    <span class="comment">// stage: coefficients and prescribed forces</span>
    EssenBcs <a href="#EssentialBcs">EssentialBcs</a> <span class="comment">// constraints (Lagrange multipliers)</span>
    PtNatBcs <a href="#PtNaturalBcs">PtNaturalBcs</a> <span class="comment">// point loads such as prescribed forces at nodes</span>

    <span class="comment">// stage: t1 and t2 variables</span>
    T1eqs []<a href="/pkg/builtin/#int">int</a> <span class="comment">// first t-derivative variables; e.g.:  dp/dt vars (subset of ykeys)</span>
    T2eqs []<a href="/pkg/builtin/#int">int</a> <span class="comment">// second t-derivative variables; e.g.: d²u/dt² vars (subset of ykeys)</span>

    <span class="comment">// stage: dimensions</span>
    NnzKb <a href="/pkg/builtin/#int">int</a> <span class="comment">// number of nonzeros in Kb matrix</span>
    Ny    <a href="/pkg/builtin/#int">int</a> <span class="comment">// total number of dofs, except λ</span>
    Nlam  <a href="/pkg/builtin/#int">int</a> <span class="comment">// total number of Lagrange multipliers</span>
    NnzA  <a href="/pkg/builtin/#int">int</a> <span class="comment">// number of nonzeros in A (constraints) matrix</span>
    Nyb   <a href="/pkg/builtin/#int">int</a> <span class="comment">// total number of equations: ny + nλ</span>

    <span class="comment">// stage: solution and linear solver</span>
    Sol      *<a href="#Solution">Solution</a>   <span class="comment">// solution state</span>
    Kb       *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a> <span class="comment">// Jacobian == dRdy</span>
    Fb       []<a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// residual == -fb</span>
    Wb       []<a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// workspace</span>
    InitLSol <a href="/pkg/builtin/#bool">bool</a>        <span class="comment">// flag telling that linear solver needs to be initialised prior to any further call</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Domain holds all Nodes and Elements active during a stage in addition to the Solution at nodes.
Only elements in this processor are recorded here; however information from
all cells might be recorded as well.
</p>


			

			

			
			
			

			
				
				<h3 id="NewDomain">func <a href="https://github.com/cpmech/gofem/blob/master/fem/domain.go?s=5613:5664#L144">NewDomain</a></h3>
				<pre>func NewDomain(reg *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Region">Region</a>, distr <a href="/pkg/builtin/#bool">bool</a>) *<a href="#Domain">Domain</a></pre>
				<p>
NewDomain returns a new domain
</p>

				
				
			

			
				
				<h3 id="Domain.In">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=3934:4002#L167">In</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) In(sum *<a href="#Summary">Summary</a>, tidx <a href="/pkg/builtin/#int">int</a>, allInOne <a href="/pkg/builtin/#bool">bool</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
In performes the inverse operation from Out
</p>
<pre>allInOne -- indicates that all results must be read into the root processor only
            For example when plotting or generating VTU files (or testing)

If allInOne is false, each processor will read its part as described by Summary.
Thus, recoreving the state as in the previous simulation.
</pre>

				
				
				
			
				
				<h3 id="Domain.Out">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=3462:3502#L152">Out</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) Out(tidx <a href="/pkg/builtin/#int">int</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Out performs output of Solution and Internal values to files
</p>

				
				
				
			
				
				<h3 id="Domain.ReadIvs">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=2796:2865#L120">ReadIvs</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) ReadIvs(dir, fnkey <a href="/pkg/builtin/#string">string</a>, tidx, proc <a href="/pkg/builtin/#int">int</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
ReadIvs reads elements&#39;s internal values from a file which name is set with tidx (time output index)
</p>

				
				
				
			
				
				<h3 id="Domain.ReadSol">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=1567:1630#L66">ReadSol</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) ReadSol(dir, fnkey <a href="/pkg/builtin/#string">string</a>, tidx <a href="/pkg/builtin/#int">int</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
ReadSol reads Solution from a file which name is set with tidx (time output index)
</p>

				
				
				
			
				
				<h3 id="Domain.SaveIvs">func (Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=2280:2323#L98">SaveIvs</a></h3>
				<pre>func (o <a href="#Domain">Domain</a>) SaveIvs(tidx <a href="/pkg/builtin/#int">int</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SaveIvs saves elements&#39;s internal values to a file which name is set with tidx (time output index)
</p>

				
				
				
			
				
				<h3 id="Domain.SaveSol">func (Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=917:960#L35">SaveSol</a></h3>
				<pre>func (o <a href="#Domain">Domain</a>) SaveSol(tidx <a href="/pkg/builtin/#int">int</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SaveSol saves Solution to a file which name is set with tidx (time output index)
</p>

				
				
				
			
				
				<h3 id="Domain.SetGeoSt">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/geost.go?s=3499:3550#L106">SetGeoSt</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) SetGeoSt(stg *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Stage">Stage</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetGeoSt sets the initial state to a hydrostatic condition
</p>

				
				
				
			
				
				<h3 id="Domain.SetHydroSt">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/hydrost.go?s=2326:2379#L82">SetHydroSt</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) SetHydroSt(stg *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Stage">Stage</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetHydroSt sets the initial state to a hydrostatic condition
</p>

				
				
				
			
				
				<h3 id="Domain.SetIniStress">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/inistress.go?s=332:387#L5">SetIniStress</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) SetIniStress(stg *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Stage">Stage</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetIniStress sets the initial state with initial stresses
</p>

				
				
				
			
				
				<h3 id="Domain.SetStage">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/domain.go?s=6087:6172#L158">SetStage</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) SetStage(idxstg <a href="/pkg/builtin/#int">int</a>, stg *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Stage">Stage</a>, distr <a href="/pkg/builtin/#bool">bool</a>) (setstageisok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetStage set nodes, equation numbers and auxiliary data for given stage
</p>

				
				
				
			
		
			
			
			<h2 id="DynCoefs">type <a href="https://github.com/cpmech/gofem/blob/master/fem/dyncoefs.go?s=677:880#L11">DynCoefs</a></h2>
			<pre>type DynCoefs struct {
    HHT <a href="/pkg/builtin/#bool">bool</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
DynCoefs calculates θ-method, Newmark&#39;s or HHT coefficients.
</p>
<pre>Notes:
 θ1  -- Newmark parameter (gamma)  [0 &lt;= θ1 &lt;= 1]
 θ2  -- Newmark parameter (2*beta) [0 &lt;= θ2 &lt;= 1]
 HHT -- use Hilber-Hughes-Taylor method ?
 α   -- Hilber-Hughes-Taylor parameter [-1/3 &lt;= α &lt;= 0]
 if HHT==True, θ1 and θ2 are automatically calculated for unconditional stability
</pre>


			

			

			
			
			

			

			
				
				<h3 id="DynCoefs.CalcAlphas">func (*DynCoefs) <a href="https://github.com/cpmech/gofem/blob/master/fem/dyncoefs.go?s=2119:2173#L91">CalcAlphas</a></h3>
				<pre>func (o *<a href="#DynCoefs">DynCoefs</a>) CalcAlphas(Δt <a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
CalcAlphas computes only alphas
</p>

				
				
				
			
				
				<h3 id="DynCoefs.CalcBetas">func (*DynCoefs) <a href="https://github.com/cpmech/gofem/blob/master/fem/dyncoefs.go?s=1845:1898#L75">CalcBetas</a></h3>
				<pre>func (o *<a href="#DynCoefs">DynCoefs</a>) CalcBetas(Δt <a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
CalcBetas computes only betas
</p>

				
				
				
			
				
				<h3 id="DynCoefs.CalcBoth">func (*DynCoefs) <a href="https://github.com/cpmech/gofem/blob/master/fem/dyncoefs.go?s=1668:1720#L65">CalcBoth</a></h3>
				<pre>func (o *<a href="#DynCoefs">DynCoefs</a>) CalcBoth(Δt <a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
CalcBoth computes betas and alphas
</p>

				
				
				
			
				
				<h3 id="DynCoefs.Init">func (*DynCoefs) <a href="https://github.com/cpmech/gofem/blob/master/fem/dyncoefs.go?s=917:971#L26">Init</a></h3>
				<pre>func (o *<a href="#DynCoefs">DynCoefs</a>) Init(dat *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#SolverData">SolverData</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Init initialises this structure
</p>

				
				
				
			
				
				<h3 id="DynCoefs.Print">func (*DynCoefs) <a href="https://github.com/cpmech/gofem/blob/master/fem/dyncoefs.go?s=2602:2628#L115">Print</a></h3>
				<pre>func (o *<a href="#DynCoefs">DynCoefs</a>) Print()</pre>
				<p>
Print prints coefficients
</p>

				
				
				
			
		
			
			
			<h2 id="Elem">type <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=705:1765#L12">Elem</a></h2>
			<pre>type Elem interface {

    <span class="comment">// information and initialisation</span>
    Id() <a href="/pkg/builtin/#int">int</a>                                           <span class="comment">// returns the cell Id</span>
    SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (ok <a href="/pkg/builtin/#bool">bool</a>) <span class="comment">// set equations</span>

    <span class="comment">// conditions (natural BCs and element&#39;s)</span>
    SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (ok <a href="/pkg/builtin/#bool">bool</a>) <span class="comment">// set element conditions</span>

    <span class="comment">// called for each time step</span>
    InterpStarVars(sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>) <span class="comment">// interpolate star variables to integration points</span>

    <span class="comment">// called for each iteration</span>
    AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)                <span class="comment">// adds -R to global residual vector fb</span>
    AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (ok <a href="/pkg/builtin/#bool">bool</a>) <span class="comment">// adds element K to global Jacobian matrix Kb</span>
    Update(sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)                                <span class="comment">// perform (tangent) update</span>

    <span class="comment">// reading and writing of element data</span>
    Encode(enc <a href="#Encoder">Encoder</a>) (ok <a href="/pkg/builtin/#bool">bool</a>) <span class="comment">// encodes internal variables</span>
    Decode(dec <a href="#Decoder">Decoder</a>) (ok <a href="/pkg/builtin/#bool">bool</a>) <span class="comment">// decodes internal variables</span>

    <span class="comment">// output</span>
    OutIpsData() (data []*<a href="#OutIpData">OutIpData</a>) <span class="comment">// returns data from all integration points for output</span>
}</pre>
			<p>
Elem defines what elements must calculate
</p>


			

			

			
			
			

			
				
				<h3 id="NewElem">func <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=3815:3899#L83">NewElem</a></h3>
				<pre>func NewElem(edat *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#ElemData">ElemData</a>, cid <a href="/pkg/builtin/#int">int</a>, msh *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Mesh">Mesh</a>, faceConds []*<a href="#FaceCond">FaceCond</a>) <a href="#Elem">Elem</a></pre>
				<p>
NewElem returns a new element from its type; e.g. &#34;p&#34;, &#34;u&#34; or &#34;up&#34;
</p>

				
				
			

			
		
			
			
			<h2 id="ElemConnector">type <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=1845:2092#L38">ElemConnector</a></h2>
			<pre>type ElemConnector interface {
    Id() <a href="/pkg/builtin/#int">int</a>                                                  <span class="comment">// returns the cell Id</span>
    Connect(cid2elem []<a href="#Elem">Elem</a>, c *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>) (nnzK <a href="/pkg/builtin/#int">int</a>, ok <a href="/pkg/builtin/#bool">bool</a>) <span class="comment">// connect multiple elements; e.g.: connect rod/solid elements in Rjoints</span>
}</pre>
			<p>
ElemConnector defines connector elements; elements that depend upon others
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="ElemIntvars">type <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=2156:2766#L44">ElemIntvars</a></h2>
			<pre>type ElemIntvars interface {
    Ipoints() (coords [][]<a href="/pkg/builtin/#float64">float64</a>)                               <span class="comment">// returns the real coordinates of integration points [nip][ndim]</span>
    SetIniIvs(sol *<a href="#Solution">Solution</a>, ivs map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>) (ok <a href="/pkg/builtin/#bool">bool</a>) <span class="comment">// sets initial ivs for given values in sol and ivs map</span>
    BackupIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)                                <span class="comment">// create copy of internal variables</span>
    RestoreIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)                               <span class="comment">// restore internal variables from copies</span>
    Ureset(sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)                              <span class="comment">// fixes internal variables after u (displacements) have been zeroed</span>
}</pre>
			<p>
ElemIntvars defines elements with {z,q} internal variables
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="ElemP">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=727:3356#L15">ElemP</a></h2>
			<pre>type ElemP struct {

    <span class="comment">// basic data</span>
    Cid <a href="/pkg/builtin/#int">int</a>         <span class="comment">// cell/element id</span>
    X   [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// matrix of nodal coordinates [ndim][nnode]</span>
    Shp *<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Shape">Shape</a>  <span class="comment">// shape structure</span>
    Np  <a href="/pkg/builtin/#int">int</a>         <span class="comment">// total number of unknowns == number of vertices</span>

    <span class="comment">// integration points</span>
    IpsElem []*<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Ipoint">Ipoint</a> <span class="comment">// integration points of element</span>
    IpsFace []*<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Ipoint">Ipoint</a> <span class="comment">// integration points corresponding to faces</span>

    <span class="comment">// material model</span>
    Mdl *<a href="/pkg/github.com/cpmech/gofem/mporous/">mporous</a>.<a href="/pkg/github.com/cpmech/gofem/mporous/#Model">Model</a> <span class="comment">// model</span>

    <span class="comment">// problem variables</span>
    Pmap []<a href="/pkg/builtin/#int">int</a> <span class="comment">// assembly map (location array/element equations)</span>

    <span class="comment">// internal variables</span>
    States    []*<a href="/pkg/github.com/cpmech/gofem/mporous/">mporous</a>.<a href="/pkg/github.com/cpmech/gofem/mporous/#State">State</a>
    StatesBkp []*<a href="/pkg/github.com/cpmech/gofem/mporous/">mporous</a>.<a href="/pkg/github.com/cpmech/gofem/mporous/#State">State</a>
    StatesAux []*<a href="/pkg/github.com/cpmech/gofem/mporous/">mporous</a>.<a href="/pkg/github.com/cpmech/gofem/mporous/#State">State</a>

    <span class="comment">// gravity</span>
    Gfcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// gravity function</span>

    <span class="comment">// natural boundary conditions</span>
    NatBcs []*<a href="#NaturalBc">NaturalBc</a> <span class="comment">// natural boundary conditions</span>

    Emat     [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nverts][nips] extrapolator matrix</span>
    DoExtrap <a href="/pkg/builtin/#bool">bool</a>        <span class="comment">// do extrapolation of ρl and Cpl =&gt; for use with flux and seepage conditions</span>

    <span class="comment">// seepage face</span>
    Nf         <a href="/pkg/builtin/#int">int</a>   <span class="comment">// number of fl variables</span>
    HasSeep    <a href="/pkg/builtin/#bool">bool</a>  <span class="comment">// indicates if this element has seepage faces</span>
    Vid2seepId []<a href="/pkg/builtin/#int">int</a> <span class="comment">// [nverts] maps local vertex id to index in Fmap</span>
    SeepId2vid []<a href="/pkg/builtin/#int">int</a> <span class="comment">// [nf] maps seepage face variable id to local vertex id</span>
    Fmap       []<a href="/pkg/builtin/#int">int</a> <span class="comment">// [nf] map of &#34;fl&#34; variables (seepage face)</span>
    Macaulay   <a href="/pkg/builtin/#bool">bool</a>  <span class="comment">// use discrete ramp function instead of smooth ramp</span>

    Hst   []<a href="/pkg/builtin/#bool">bool</a>      <span class="comment">// [nf] set hydrostatic plmax</span>
    Plmax [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nf][nipsFace] specified plmax (not corrected by multiplier)</span>

    Kpp [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [np][np] Kpp := dRpl/dpl consistent tangent matrix</span>
    Kpf [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [np][nf] Kpf := dRpl/dfl consistent tangent matrix</span>
    Kfp [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nf][np] Kfp := dRfl/dpl consistent tangent matrix</span>
    Kff [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nf][nf] Kff := dRfl/dfl consistent tangent matrix</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
ElemP implements an element for transient seepage analyses [1]
</p>
<pre>References:
 [1] Pedroso DM (2015) A solution to transient seepage in unsaturated porous media.
     Computer Methods in Applied Mechanics and Engineering, 285 791-816,
     <a href="http://dx.doi.org/10.1016/j.cma.2014.12.009">http://dx.doi.org/10.1016/j.cma.2014.12.009</a>
</pre>


			

			

			
			
			

			

			
				
				<h3 id="ElemP.AddToKb">func (ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=9355:9432#L326">AddToKb</a></h3>
				<pre>func (o <a href="#ElemP">ElemP</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
AddToKb adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="ElemP.AddToRhs">func (ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=7913:7975#L265">AddToRhs</a></h3>
				<pre>func (o <a href="#ElemP">ElemP</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
AddToRhs adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="ElemP.BackupIvs">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=14416:14461#L545">BackupIvs</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) BackupIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
BackupIvs creates copy of internal variables
</p>

				
				
				
			
				
				<h3 id="ElemP.Decode">func (ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=15304:15348#L585">Decode</a></h3>
				<pre>func (o <a href="#ElemP">ElemP</a>) Decode(dec <a href="#Decoder">Decoder</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemP.Encode">func (ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=15169:15213#L580">Encode</a></h3>
				<pre>func (o <a href="#ElemP">ElemP</a>) Encode(enc <a href="#Encoder">Encoder</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemP.Id">func (ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=6884:6907#L220">Id</a></h3>
				<pre>func (o <a href="#ElemP">ElemP</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="ElemP.InterpStarVars">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=7456:7511#L245">InterpStarVars</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
InterpStarVars interpolates star variables to integration points
</p>

				
				
				
			
				
				<h3 id="ElemP.Ipoints">func (ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=12352:12397#L456">Ipoints</a></h3>
				<pre>func (o <a href="#ElemP">ElemP</a>) Ipoints() (coords [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Ipoints returns the real coordinates of integration points [nip][ndim]
</p>

				
				
				
			
				
				<h3 id="ElemP.OutIpsData">func (ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=15505:15552#L593">OutIpsData</a></h3>
				<pre>func (o <a href="#ElemP">ElemP</a>) OutIpsData() (data []*<a href="#OutIpData">OutIpData</a>)</pre>
				<p>
OutIpsData returns data from all integration points for output
</p>

				
				
				
			
				
				<h3 id="ElemP.RestoreIvs">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=14678:14724#L559">RestoreIvs</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) RestoreIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
RestoreIvs restores internal variables from copies
</p>

				
				
				
			
				
				<h3 id="ElemP.SetEleConds">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=7250:7325#L237">SetEleConds</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetEleConds sets element conditions
</p>

				
				
				
			
				
				<h3 id="ElemP.SetEqs">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=6951:7017#L223">SetEqs</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetEqs sets equations
</p>

				
				
				
			
				
				<h3 id="ElemP.SetIniIvs">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=12609:12689#L465">SetIniIvs</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) SetIniIvs(sol *<a href="#Solution">Solution</a>, ignored map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetIniIvs sets initial ivs for given values in sol and ivs map
</p>

				
				
				
			
				
				<h3 id="ElemP.Update">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=11590:11637#L426">Update</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) Update(sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Update performs (tangent) update
</p>

				
				
				
			
				
				<h3 id="ElemP.Ureset">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=14963:15010#L573">Ureset</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) Ureset(sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Ureset fixes internal variables after u (displacements) have been zeroed
</p>

				
				
				
			
		
			
			
			<h2 id="ElemPhi">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=499:1078#L9">ElemPhi</a></h2>
			<pre>type ElemPhi struct {

    <span class="comment">// basic data</span>
    Cid <a href="/pkg/builtin/#int">int</a>         <span class="comment">// cell/element id</span>
    X   [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [ndim][nnode] matrix of nodal coordinates</span>
    Shp *<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Shape">Shape</a>  <span class="comment">// shape structure</span>
    Nu  <a href="/pkg/builtin/#int">int</a>         <span class="comment">// total number of unknowns == number of vertices</span>

    <span class="comment">// integration points</span>
    IpsElem []*<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Ipoint">Ipoint</a> <span class="comment">// [nip] integration points of element</span>

    <span class="comment">// scratchpad. computed @ each ip</span>
    K [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nu][nu] consistent tangent matrix</span>

    <span class="comment">// problem variables</span>
    Umap []<a href="/pkg/builtin/#int">int</a> <span class="comment">// assembly map (location array/element equations)</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
ElemPhi implementes a general element to solve the following equation
</p>
<pre>dφ       ∂φ
-- + v . -- = s(x)
dt       ∂x
</pre>
<p>
Notes: v is a constant vector
</p>


			

			

			
			
			

			

			
				
				<h3 id="ElemPhi.AddToKb">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=4085:4165#L162">AddToKb</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
AddToKb adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="ElemPhi.AddToRhs">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=3227:3292#L125">AddToRhs</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
AddToRhs adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="ElemPhi.Decode">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=5164:5211#L213">Decode</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) Decode(dec <a href="#Decoder">Decoder</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemPhi.Encode">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=5061:5108#L208">Encode</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) Encode(enc <a href="#Encoder">Encoder</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemPhi.Id">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=2334:2360#L86">Id</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="ElemPhi.InterpStarVars">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=2776:2833#L105">InterpStarVars</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
InterpStarVars interpolate star variables to integration points
</p>

				
				
				
			
				
				<h3 id="ElemPhi.OutIpsData">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=5296:5346#L218">OutIpsData</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) OutIpsData() (data []*<a href="#OutIpData">OutIpData</a>)</pre>
				<p>
OutIpsData returns data from all integration points for output
</p>

				
				
				
			
				
				<h3 id="ElemPhi.SetEleConds">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=2613:2690#L100">SetEleConds</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetEleConds set element conditions
</p>

				
				
				
			
				
				<h3 id="ElemPhi.SetEqs">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=2404:2472#L91">SetEqs</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetEqs set equations
</p>

				
				
				
			
				
				<h3 id="ElemPhi.Update">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=4853:4902#L201">Update</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) Update(sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Update perform (tangent) update
</p>

				
				
				
			
		
			
			
			<h2 id="ElemU">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=525:2641#L10">ElemU</a></h2>
			<pre>type ElemU struct {

    <span class="comment">// basic data</span>
    Cid <a href="/pkg/builtin/#int">int</a>         <span class="comment">// cell/element id</span>
    X   [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// matrix of nodal coordinates [ndim][nnode]</span>
    Shp *<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Shape">Shape</a>  <span class="comment">// shape structure</span>
    Nu  <a href="/pkg/builtin/#int">int</a>         <span class="comment">// total number of unknowns</span>

    <span class="comment">// variables for dynamics</span>
    Rho  <a href="/pkg/builtin/#float64">float64</a>  <span class="comment">// density of solids</span>
    Cdam <a href="/pkg/builtin/#float64">float64</a>  <span class="comment">// coefficient for damping</span>
    Gfcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// gravity function</span>

    <span class="comment">// optional data</span>
    UseB      <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// use B matrix</span>
    Thickness <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// thickness (for plane-stress)</span>
    Debug     <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// debugging flag</span>

    <span class="comment">// integration points</span>
    IpsElem []*<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Ipoint">Ipoint</a> <span class="comment">// integration points of element</span>
    IpsFace []*<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Ipoint">Ipoint</a> <span class="comment">// integration points corresponding to faces</span>

    <span class="comment">// material model and internal variables</span>
    Model    <a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#Model">Model</a> <span class="comment">// material model</span>
    MdlSmall <a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#Small">Small</a> <span class="comment">// model specialisation for small strains</span>
    MdlLarge <a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#Large">Large</a> <span class="comment">// model specialisation for large deformations</span>

    <span class="comment">// internal variables</span>
    States    []*<a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#State">State</a> <span class="comment">// [nip] states</span>
    StatesBkp []*<a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#State">State</a> <span class="comment">// [nip] backup states</span>
    StatesAux []*<a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#State">State</a> <span class="comment">// [nip] auxiliary backup states</span>

    <span class="comment">// problem variables</span>
    Umap []<a href="/pkg/builtin/#int">int</a> <span class="comment">// assembly map (location array/element equations)</span>

    <span class="comment">// natural boundary conditions</span>
    NatBcs []*<a href="#NaturalBc">NaturalBc</a>

    K [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nu][nu] consistent tangent (stiffness) matrix</span>
    B [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nsig][nu] B matrix for axisymetric case</span>
    D [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nsig][nsig] constitutive consistent tangent matrix</span>

    Δε []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// incremental strains leading to updated strains</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
ElemU represents a solid element with displacements u as primary variables
</p>


			

			

			
			
			

			

			
				
				<h3 id="ElemU.AddToKb">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=8194:8272#L316">AddToKb</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
AddToKb adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="ElemU.AddToRhs">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=6703:6766#L250">AddToRhs</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
AddToRhs adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="ElemU.BackupIvs">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=11745:11790#L460">BackupIvs</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) BackupIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
BackupIvs create copy of internal variables
</p>

				
				
				
			
				
				<h3 id="ElemU.Decode">func (ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=12775:12819#L506">Decode</a></h3>
				<pre>func (o <a href="#ElemU">ElemU</a>) Decode(dec <a href="#Decoder">Decoder</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemU.Encode">func (ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=12640:12684#L501">Encode</a></h3>
				<pre>func (o <a href="#ElemU">ElemU</a>) Encode(enc <a href="#Encoder">Encoder</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemU.Id">func (ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=5403:5426#L193">Id</a></h3>
				<pre>func (o <a href="#ElemU">ElemU</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="ElemU.InterpStarVars">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=5965:6020#L217">InterpStarVars</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
InterpStarVars interpolates star variables to integration points
</p>

				
				
				
			
				
				<h3 id="ElemU.Ipoints">func (ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=10781:10826#L422">Ipoints</a></h3>
				<pre>func (o <a href="#ElemU">ElemU</a>) Ipoints() (coords [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Ipoints returns the real coordinates of integration points [nip][ndim]
</p>

				
				
				
			
				
				<h3 id="ElemU.OutIpsData">func (ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=12976:13023#L514">OutIpsData</a></h3>
				<pre>func (o <a href="#ElemU">ElemU</a>) OutIpsData() (data []*<a href="#OutIpData">OutIpData</a>)</pre>
				<p>
OutIpsData returns data from all integration points for output
</p>

				
				
				
			
				
				<h3 id="ElemU.RestoreIvs">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=12006:12052#L474">RestoreIvs</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) RestoreIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
RestoreIvs restore internal variables from copies
</p>

				
				
				
			
				
				<h3 id="ElemU.SetEleConds">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=5759:5834#L209">SetEleConds</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetEleConds set element conditions
</p>

				
				
				
			
				
				<h3 id="ElemU.SetEqs">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=5469:5535#L196">SetEqs</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetEqs set equations
</p>

				
				
				
			
				
				<h3 id="ElemU.SetIniIvs">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=11038:11114#L431">SetIniIvs</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) SetIniIvs(sol *<a href="#Solution">Solution</a>, ivs map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetIniIvs sets initial ivs for given values in sol and ivs map
</p>

				
				
				
			
				
				<h3 id="ElemU.Update">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=9716:9763#L385">Update</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) Update(sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Update perform (tangent) update
</p>

				
				
				
			
				
				<h3 id="ElemU.Ureset">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=12291:12338#L488">Ureset</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) Ureset(sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Ureset fixes internal variables after u (displacements) have been zeroed
</p>

				
				
				
			
		
			
			
			<h2 id="ElemUP">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=908:1691#L15">ElemUP</a></h2>
			<pre>type ElemUP struct {

    <span class="comment">// auxiliary</span>
    Fconds []*<a href="#FaceCond">FaceCond</a> <span class="comment">// face conditions; e.g. seepage faces</span>
    CtypeU <a href="/pkg/builtin/#string">string</a>      <span class="comment">// u: cell type</span>
    CtypeP <a href="/pkg/builtin/#string">string</a>      <span class="comment">// p: cell type</span>

    <span class="comment">// underlying elements</span>
    U *<a href="#ElemU">ElemU</a> <span class="comment">// u-element</span>
    P *<a href="#ElemP">ElemP</a> <span class="comment">// p-element</span>

    Kup [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nu][np] Kup := dRus/dpl consistent tangent matrix</span>
    Kpu [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [np][nu] Kpu := dRpl/dus consistent tangent matrix</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
ElemUP represents an element for porous media based on the u-p formulation [1]
</p>
<pre>References:
 [1] Pedroso DM (2015) A consistent u-p formulation for porous media with hysteresis.
     Int Journal for Numerical Methods in Engineering, 101(8) 606-634
     <a href="http://dx.doi.org/10.1002/nme.4808">http://dx.doi.org/10.1002/nme.4808</a>
 [2] Pedroso DM (2015) A solution to transient seepage in unsaturated porous media.
     Computer Methods in Applied Mechanics and Engineering, 285 791-816,
     <a href="http://dx.doi.org/10.1016/j.cma.2014.12.009">http://dx.doi.org/10.1016/j.cma.2014.12.009</a>
</pre>


			

			

			
			
			

			

			
				
				<h3 id="ElemUP.AddToKb">func (ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=9363:9441#L354">AddToKb</a></h3>
				<pre>func (o <a href="#ElemUP">ElemUP</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="ElemUP.AddToRhs">func (ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=6511:6574#L235">AddToRhs</a></h3>
				<pre>func (o <a href="#ElemUP">ElemUP</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="ElemUP.BackupIvs">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=16041:16087#L623">BackupIvs</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) BackupIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
BackupIvs create copy of internal variables
</p>

				
				
				
			
				
				<h3 id="ElemUP.Decode">func (ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=17252:17297#L674">Decode</a></h3>
				<pre>func (o <a href="#ElemUP">ElemUP</a>) Decode(dec <a href="#Decoder">Decoder</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemUP.Encode">func (ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=17105:17150#L666">Encode</a></h3>
				<pre>func (o <a href="#ElemUP">ElemUP</a>) Encode(enc <a href="#Encoder">Encoder</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemUP.Id">func (ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=4292:4316#L141">Id</a></h3>
				<pre>func (o <a href="#ElemUP">ElemUP</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="ElemUP.InterpStarVars">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=5477:5533#L189">InterpStarVars</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
InterpStarVars interpolates star variables to integration points
</p>

				
				
				
			
				
				<h3 id="ElemUP.Ipoints">func (ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=14647:14693#L564">Ipoints</a></h3>
				<pre>func (o <a href="#ElemUP">ElemUP</a>) Ipoints() (coords [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Ipoints returns the real coordinates of integration points [nip][ndim]
</p>

				
				
				
			
				
				<h3 id="ElemUP.OutIpsData">func (ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=17428:17476#L682">OutIpsData</a></h3>
				<pre>func (o <a href="#ElemUP">ElemUP</a>) OutIpsData() (data []*<a href="#OutIpData">OutIpData</a>)</pre>
				<p>
OutIpsData returns data from all integration points for output
</p>

				
				
				
			
				
				<h3 id="ElemUP.RestoreIvs">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=16211:16258#L631">RestoreIvs</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) RestoreIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
RestoreIvs restore internal variables from copies
</p>

				
				
				
			
				
				<h3 id="ElemUP.SetEleConds">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=5238:5314#L181">SetEleConds</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetEleConds set element conditions
</p>

				
				
				
			
				
				<h3 id="ElemUP.SetEqs">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=4362:4429#L144">SetEqs</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetEqs set equations
</p>

				
				
				
			
				
				<h3 id="ElemUP.SetIniIvs">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=14913:14990#L573">SetIniIvs</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) SetIniIvs(sol *<a href="#Solution">Solution</a>, ivs map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetIniIvs sets initial ivs for given values in sol and ivs map
</p>

				
				
				
			
				
				<h3 id="ElemUP.Update">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=14357:14405#L554">Update</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) Update(sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Update perform (tangent) update
</p>

				
				
				
			
				
				<h3 id="ElemUP.Ureset">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=16407:16455#L639">Ureset</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) Ureset(sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Ureset fixes internal variables after u (displacements) have been zeroed
</p>

				
				
				
			
		
			
			
			<h2 id="Encoder">type <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=345:400#L9">Encoder</a></h2>
			<pre>type Encoder interface {
    Encode(e interface{}) <a href="/pkg/builtin/#error">error</a>
}</pre>
			<p>
Encoder defines encoders; e.g. gob or json
</p>


			

			

			
			
			

			
				
				<h3 id="GetEncoder">func <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=541:579#L19">GetEncoder</a></h3>
				<pre>func GetEncoder(w <a href="/pkg/io/">goio</a>.<a href="/pkg/io/#Writer">Writer</a>) <a href="#Encoder">Encoder</a></pre>
				<p>
GetEncoder returns a new encoder
</p>

				
				
			

			
		
			
			
			<h2 id="EssentialBc">type <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=901:1135#L22">EssentialBc</a></h2>
			<pre>type EssentialBc struct {
    Key   <a href="/pkg/builtin/#string">string</a>    <span class="comment">// ux, uy, rigid, incsup</span>
    Eqs   []<a href="/pkg/builtin/#int">int</a>     <span class="comment">// equations</span>
    ValsA []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// values for matrix A</span>
    Fcn   <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>  <span class="comment">// function that implements the &#34;c&#34; in A * y = c</span>
    Inact <a href="/pkg/builtin/#bool">bool</a>      <span class="comment">// inactive</span>
}</pre>
			<p>
EssentialBc holds information about essential bounday conditions such as constrained nodes.
Lagrange multipliers are used to implement both single- and multi-point constraints.
</p>
<pre>In general, essential bcs / constraints are defined by means of:

    A * y = c

The resulting Kb matrix will then have the following form:
    _       _
   |  K  At  | / δy \   / -R - At*λ \
   |         | |    | = |           |
   |_ A   0 _| \ δλ /   \  c - A*y  /
       Kb       δyb          fb
</pre>


			

			

			
			
			

			

			
		
			
			
			<h2 id="EssentialBcs">type <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=1298:1694#L32">EssentialBcs</a></h2>
			<pre>type EssentialBcs struct {
    Eq2idx map[<a href="/pkg/builtin/#int">int</a>][]<a href="/pkg/builtin/#int">int</a>  <span class="comment">// maps eq number to indices in BcsTmp</span>
    Bcs    []*<a href="#EssentialBc">EssentialBc</a> <span class="comment">// active essential bcs / constraints</span>
    A      <a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>     <span class="comment">// matrix of coefficients &#39;A&#39;</span>
    Am     *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#CCMatrix">CCMatrix</a>   <span class="comment">// compressed form of A matrix</span>

    <span class="comment">// temporary</span>
    BcsTmp eqbcpairs <span class="comment">// temporary essential bcs / constraints, including inactive ones. maps the first equation number to bcs</span>
}</pre>
			<p>
EssentialBcs implements a structure to record the definition of essential bcs / constraints.
Each constraint will have a unique Lagrange multiplier index.
</p>


			

			

			
			
			

			

			
				
				<h3 id="EssentialBcs.AddToRhs">func (EssentialBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=2863:2922#L88">AddToRhs</a></h3>
				<pre>func (o <a href="#EssentialBcs">EssentialBcs</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>)</pre>
				<p>
AddtoRhs adds the essential bcs / constraints terms to the augmented fb vector
</p>

				
				
				
			
				
				<h3 id="EssentialBcs.Build">func (*EssentialBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=2110:2162#L52">Build</a></h3>
				<pre>func (o *<a href="#EssentialBcs">EssentialBcs</a>) Build(ny <a href="/pkg/builtin/#int">int</a>) (nλ, nnzA <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Build builds this structure and its iternal data
</p>
<pre>nλ -- is the number of essential bcs / constraints == number of Lagrange multipliers
nnzA -- is the number of non-zeros in matrix &#39;A&#39;
</pre>

				
				
				
			
				
				<h3 id="EssentialBcs.List">func (*EssentialBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=7126:7175#L250">List</a></h3>
				<pre>func (o *<a href="#EssentialBcs">EssentialBcs</a>) List(t <a href="/pkg/builtin/#float64">float64</a>) (l <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
List returns a simple list logging bcs at time t
</p>

				
				
				
			
				
				<h3 id="EssentialBcs.Reset">func (*EssentialBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=1782:1812#L43">Reset</a></h3>
				<pre>func (o *<a href="#EssentialBcs">EssentialBcs</a>) Reset()</pre>
				<p>
Reset initialises this structure. It also performs a reset of internal structures.
</p>

				
				
				
			
				
				<h3 id="EssentialBcs.Set">func (*EssentialBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=4610:4706#L140">Set</a></h3>
				<pre>func (o *<a href="#EssentialBcs">EssentialBcs</a>) Set(key <a href="/pkg/builtin/#string">string</a>, nodes []*<a href="#Node">Node</a>, fcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (setisok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Set sets a constraint if it does NOT exist yet.
</p>
<pre>key   -- can be Dof key such as &#34;ux&#34;, &#34;uy&#34; or constraint type such as &#34;mpc&#34; or &#34;rigid&#34;
extra -- is a keycode-style data. e.g. &#34;!type:incsup2d !alp:30&#34;
Notes: 1) the default for key is single point constraint; e.g. &#34;ux&#34;, &#34;uy&#34;, ...
       2) hydraulic head can be set with key == &#34;H&#34;
</pre>

				
				
				
			
		
			
			
			<h2 id="FaceCond">type <a href="https://github.com/cpmech/gofem/blob/master/fem/domain.go?s=1329:1712#L31">FaceCond</a></h2>
			<pre>type FaceCond struct {
    FaceId      <a href="/pkg/builtin/#int">int</a>      <span class="comment">// msh: cell&#39;s face local id</span>
    LocalVerts  []<a href="/pkg/builtin/#int">int</a>    <span class="comment">// msh: cell&#39;s face local vertices ids (sorted)</span>
    GlobalVerts []<a href="/pkg/builtin/#int">int</a>    <span class="comment">// msh: global vertices ids (sorted)</span>
    Cond        <a href="/pkg/builtin/#string">string</a>   <span class="comment">// sim: condition; e.g. &#34;qn&#34; or &#34;seepH&#34;</span>
    Func        <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// sim: function to compute boundary condition</span>
    Extra       <a href="/pkg/builtin/#string">string</a>   <span class="comment">// sim: extra information</span>
}</pre>
			

			

			

			
			
			

			

			
		
			
			
			<h2 id="GeoLayer">type <a href="https://github.com/cpmech/gofem/blob/master/fem/geost.go?s=1151:1916#L29">GeoLayer</a></h2>
			<pre>type GeoLayer struct {
    Tags  []<a href="/pkg/builtin/#int">int</a>   <span class="comment">// tags of cells within this layer</span>
    Zmin  <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// coordinate (elevation) at bottom of layer</span>
    Zmax  <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// coordinate (elevation) at top of layer</span>
    Nodes []*<a href="#Node">Node</a> <span class="comment">// nodes in layer</span>
    Elems []<a href="#Elem">Elem</a>  <span class="comment">// elements in layer</span>
    Cl    <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// liquid compressibility</span>
    RhoS0 <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// initial density of solids</span>

    K0    <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// earth-pressure at rest</span>
    Dpl   <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// liquid pressure added by this layer</span>
    DsigV <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// absolute value of vertical stress increment added by this layer</span>

    Jac <a href="/pkg/github.com/cpmech/gosl/ode/">ode</a>.<a href="/pkg/github.com/cpmech/gosl/ode/#Cb_jac">Cb_jac</a> <span class="comment">// Jacobian for ode solver</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
GeoLayer holds information of one soil layer. It computes pressures (σVabs, pl) and
densities (ρL, ρ) based on the following model (fully liquid saturated)
</p>
<pre>ρL  = ρL0 + Cl・pl   thus   dρL/dpl = Cl
sl  = 1
ρ   = nf・sl・ρL + (1 - nf)・ρS
ns  = 1 - nf

Z(z) = zmax + T・(z - zmax)   with 0 ≤ T ≤ 1
dZ   = (z - zmax)・dT
dpl  = ρL(pl)・g・(-dZ)
dpl  = ρL(pl)・g・(zmax - z)・dT
dσV  = ρ(pl)・g・(zmax - z)・dT
Δz   = zmax - z

        / dpl/dT \   / ρL(pl)・g・Δz  \
dY/dT = | dρL/dT | = | Cl・dpl/dT     |
        | dρ/dT  |   | nf・sl・dρL/dT |
        \ dσV/dT /   \ ρ(pl)・g・Δz   /
</pre>


			

			

			
			
			

			

			
				
				<h3 id="GeoLayer.Calc">func (GeoLayer) <a href="https://github.com/cpmech/gofem/blob/master/fem/geost.go?s=2744:2796#L76">Calc</a></h3>
				<pre>func (o <a href="#GeoLayer">GeoLayer</a>) Calc(z <a href="/pkg/builtin/#float64">float64</a>) (*geostate, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Calc computes state @ level z
</p>

				
				
				
			
				
				<h3 id="GeoLayer.Start">func (*GeoLayer) <a href="https://github.com/cpmech/gofem/blob/master/fem/geost.go?s=2030:2070#L49">Start</a></h3>
				<pre>func (o *<a href="#GeoLayer">GeoLayer</a>) Start(prev *geostate)</pre>
				<p>
Start starts ODE solver for computing state variables in Calc
</p>
<pre>prev -- previous state @ top of this layer
</pre>

				
				
				
			
		
			
			
			<h2 id="GeoLayers">type <a href="https://github.com/cpmech/gofem/blob/master/fem/geost.go?s=3120:3146#L88">GeoLayers</a></h2>
			<pre>type GeoLayers []*<a href="#GeoLayer">GeoLayer</a></pre>
			<p>
GeoLayers is a set of Layer
</p>


			

			

			
			
			

			

			
				
				<h3 id="GeoLayers.Len">func (GeoLayers) <a href="https://github.com/cpmech/gofem/blob/master/fem/geost.go?s=3176:3204#L91">Len</a></h3>
				<pre>func (o <a href="#GeoLayers">GeoLayers</a>) Len() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Len the length of Layers
</p>

				
				
				
			
				
				<h3 id="GeoLayers.Less">func (GeoLayers) <a href="https://github.com/cpmech/gofem/blob/master/fem/geost.go?s=3363:3401#L101">Less</a></h3>
				<pre>func (o <a href="#GeoLayers">GeoLayers</a>) Less(i, j <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Less compares Layers: sort from top to bottom
</p>

				
				
				
			
				
				<h3 id="GeoLayers.String">func (GeoLayers) <a href="https://github.com/cpmech/gofem/blob/master/fem/geost.go?s=8388:8422#L296">String</a></h3>
				<pre>func (o <a href="#GeoLayers">GeoLayers</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
String prints a json formatted string with GeoLayers&#39; content
</p>

				
				
				
			
				
				<h3 id="GeoLayers.Swap">func (GeoLayers) <a href="https://github.com/cpmech/gofem/blob/master/fem/geost.go?s=3250:3283#L96">Swap</a></h3>
				<pre>func (o <a href="#GeoLayers">GeoLayers</a>) Swap(i, j <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Swap swaps two Layers
</p>

				
				
				
			
		
			
			
			<h2 id="HydroStatic">type <a href="https://github.com/cpmech/gofem/blob/master/fem/hydrost.go?s=829:975#L22">HydroStatic</a></h2>
			<pre>type HydroStatic struct {
    Cl <a href="/pkg/builtin/#float64">float64</a>

    Jac <a href="/pkg/github.com/cpmech/gosl/ode/">ode</a>.<a href="/pkg/github.com/cpmech/gosl/ode/#Cb_jac">Cb_jac</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
HydroStatic computes water pressure (pl) and intrinsic liquid density (ρL)
based on the following model
</p>
<pre>ρL = ρL0 + Cl・pl   thus   dρL/dpl = Cl

Z(z) = zmax + T・(z - zmax)   with 0 ≤ T ≤ 1
dZ   = (z - zmax)・dT
dpl  = ρL(pl)・g・(-dZ)
dpl  = ρL(pl)・g・(zmax - z)・dT
Δz   = zmax - z

        / dpl/dT \   / ρL(pl)・g・Δz \
dY/dT = |        | = |               |
        \ dρL/dT /   \ Cl・dpl/dT    /
</pre>


			

			

			
			
			

			

			
				
				<h3 id="HydroStatic.Calc">func (HydroStatic) <a href="https://github.com/cpmech/gofem/blob/master/fem/hydrost.go?s=1944:2009#L70">Calc</a></h3>
				<pre>func (o <a href="#HydroStatic">HydroStatic</a>) Calc(z <a href="/pkg/builtin/#float64">float64</a>) (pl, ρL <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Calc computes pressure and density
</p>

				
				
				
			
				
				<h3 id="HydroStatic.Init">func (*HydroStatic) <a href="https://github.com/cpmech/gofem/blob/master/fem/hydrost.go?s=1012:1040#L33">Init</a></h3>
				<pre>func (o *<a href="#HydroStatic">HydroStatic</a>) Init()</pre>
				<p>
Init initialises this structure
</p>

				
				
				
			
		
			
			
			<h2 id="Info">type <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=2833:3281#L53">Info</a></h2>
			<pre>type Info struct {

    <span class="comment">// essential</span>
    Dofs [][]<a href="/pkg/builtin/#string">string</a>        <span class="comment">// solution variables PER NODE. ex for 2 nodes: [[&#34;ux&#34;, &#34;uy&#34;, &#34;rz&#34;], [&#34;ux&#34;, &#34;uy&#34;, &#34;rz&#34;]]</span>
    Y2F  map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#string">string</a> <span class="comment">// maps &#34;y&#34; keys to &#34;f&#34; keys. ex: &#34;ux&#34; =&gt; &#34;fx&#34;, &#34;pl&#34; =&gt; &#34;ql&#34;</span>

    <span class="comment">// internal Dofs; e.g. for mixed formulations</span>
    NintDofs <a href="/pkg/builtin/#int">int</a> <span class="comment">// number of internal dofs</span>

    <span class="comment">// t1 and t2 variables (time-derivatives of first and second order)</span>
    T1vars []<a href="/pkg/builtin/#string">string</a> <span class="comment">// &#34;pl&#34;</span>
    T2vars []<a href="/pkg/builtin/#string">string</a> <span class="comment">// &#34;ux&#34;, &#34;uy&#34;</span>
}</pre>
			<p>
Info holds all information required to set a simulation stage
</p>


			

			

			
			
			

			
				
				<h3 id="GetElemInfo">func <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=3399:3471#L70">GetElemInfo</a></h3>
				<pre>func GetElemInfo(cellType, elemType <a href="/pkg/builtin/#string">string</a>, faceConds []*<a href="#FaceCond">FaceCond</a>) *<a href="#Info">Info</a></pre>
				<p>
GetElemInfo returns information about elements/formulations
</p>
<pre>cellType -- e.g. &#34;qua8&#34;
elemType -- e.g. &#34;u&#34;
</pre>

				
				
			

			
		
			
			
			<h2 id="NaturalBc">type <a href="https://github.com/cpmech/gofem/blob/master/fem/naturalbcs.go?s=348:559#L1">NaturalBc</a></h2>
			<pre>type NaturalBc struct {
    Key     <a href="/pkg/builtin/#string">string</a>   <span class="comment">// key such as qn, qn0, ql, seepH, seepP, etc...</span>
    IdxFace <a href="/pkg/builtin/#int">int</a>      <span class="comment">// local index of face</span>
    Fcn     <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// function callback</span>
    Extra   <a href="/pkg/builtin/#string">string</a>   <span class="comment">// extra information</span>
}</pre>
			<p>
NaturalBc holds information on natural boundary conditioins such as
distributed loads or fluxes acting on surfaces
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Node">type <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=630:747#L16">Node</a></h2>
			<pre>type Node struct {
    Dofs []*<a href="#Dof">Dof</a>    <span class="comment">// degrees-of-freedom == solution variables</span>
    Vert *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Vert">Vert</a> <span class="comment">// pointer to Vertex</span>
}</pre>
			<p>
Node holds node dofs information
</p>


			

			

			
			
			

			
				
				<h3 id="NewNode">func <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=781:812#L22">NewNode</a></h3>
				<pre>func NewNode(v *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Vert">Vert</a>) *<a href="#Node">Node</a></pre>
				<p>
NewNode allocates a new Node
</p>

				
				
			

			
				
				<h3 id="Node.AddDofAndEq">func (*Node) <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=1241:1304#L40">AddDofAndEq</a></h3>
				<pre>func (o *<a href="#Node">Node</a>) AddDofAndEq(ukey <a href="/pkg/builtin/#string">string</a>, eqnum <a href="/pkg/builtin/#int">int</a>) (nexteq <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
AddDof adds a new dof to thisnode; ignores it if it exists already
</p>
<pre>nexteq -- is the next equation number == eqnum + 1;
          returns eqnum if dof exists already
</pre>

				
				
				
			
				
				<h3 id="Node.GetDof">func (*Node) <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=1755:1794#L61">GetDof</a></h3>
				<pre>func (o *<a href="#Node">Node</a>) GetDof(ukey <a href="/pkg/builtin/#string">string</a>) *<a href="#Dof">Dof</a></pre>
				<p>
GetDof returns the Dof structure for given Dof name (ukey)
</p>
<pre>Note: returns nil if not found
</pre>

				
				
				
			
				
				<h3 id="Node.GetEq">func (*Node) <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=1983:2031#L72">GetEq</a></h3>
				<pre>func (o *<a href="#Node">Node</a>) GetEq(ukey <a href="/pkg/builtin/#string">string</a>) (eqNumber <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
GetEq returns the equation number for given Dof name (ukey)
</p>
<pre>Note: returns -1 if not found
</pre>

				
				
				
			
				
				<h3 id="Node.GetKeys">func (*Node) <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=2174:2207#L82">GetKeys</a></h3>
				<pre>func (o *<a href="#Node">Node</a>) GetKeys() []<a href="/pkg/builtin/#string">string</a></pre>
				<p>
GetKeys returns a slice of keys from all dofs
</p>

				
				
				
			
				
				<h3 id="Node.SetEq">func (*Node) <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=1593:1640#L55">SetEq</a></h3>
				<pre>func (o *<a href="#Node">Node</a>) SetEq(ukey <a href="/pkg/builtin/#string">string</a>, eqNumber <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
SetEq numbers a specific Dof with the equation number in the current (stage) global system
</p>

				
				
				
			
				
				<h3 id="Node.String">func (*Node) <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=902:932#L27">String</a></h3>
				<pre>func (o *<a href="#Node">Node</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
String returns the string representation of this node
</p>

				
				
				
			
		
			
			
			<h2 id="OutIpData">type <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=398:658#L5">OutIpData</a></h2>
			<pre>type OutIpData struct {
    Eid  <a href="/pkg/builtin/#int">int</a>                                    <span class="comment">// id of element that owns this ip</span>
    X    []<a href="/pkg/builtin/#float64">float64</a>                              <span class="comment">// coordinates</span>
    Calc func(sol *<a href="#Solution">Solution</a>) map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nkeys] function to calculate secondary values</span>
}</pre>
			<p>
OutIpData is an auxiliary structure to transfer data from integration points (IP) to output routines.
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="PtNaturalBc">type <a href="https://github.com/cpmech/gofem/blob/master/fem/ptnatbcs.go?s=380:581#L4">PtNaturalBc</a></h2>
			<pre>type PtNaturalBc struct {
    Key   <a href="/pkg/builtin/#string">string</a>    <span class="comment">// key such as fux, fpl, etc...</span>
    Eq    <a href="/pkg/builtin/#int">int</a>       <span class="comment">// equation</span>
    X     []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// location</span>
    Fcn   <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>  <span class="comment">// function</span>
    Extra <a href="/pkg/builtin/#string">string</a>    <span class="comment">// extra information</span>
}</pre>
			<p>
PtNaturalBc holds information on point natural boundary conditions such as
prescribed forces or fluxes) at nodes
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="PtNaturalBcs">type <a href="https://github.com/cpmech/gofem/blob/master/fem/ptnatbcs.go?s=627:792#L13">PtNaturalBcs</a></h2>
			<pre>type PtNaturalBcs struct {
    Eq2idx map[<a href="/pkg/builtin/#int">int</a>]<a href="/pkg/builtin/#int">int</a>    <span class="comment">// maps eq number to indices in Bcs</span>
    Bcs    []*<a href="#PtNaturalBc">PtNaturalBc</a> <span class="comment">//active boundary conditions such as prescribed forces</span>
}</pre>
			<p>
PointLoads is a set of prescribed forces
</p>


			

			

			
			
			

			

			
				
				<h3 id="PtNaturalBcs.AddToRhs">func (PtNaturalBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/ptnatbcs.go?s=1008:1063#L25">AddToRhs</a></h3>
				<pre>func (o <a href="#PtNaturalBcs">PtNaturalBcs</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, t <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
AddToRhs adds the boundary conditions terms to the augmented fb vector
</p>

				
				
				
			
				
				<h3 id="PtNaturalBcs.List">func (*PtNaturalBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/ptnatbcs.go?s=1703:1752#L51">List</a></h3>
				<pre>func (o *<a href="#PtNaturalBcs">PtNaturalBcs</a>) List(t <a href="/pkg/builtin/#float64">float64</a>) (l <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
List returns a simple list logging bcs at time t
</p>

				
				
				
			
				
				<h3 id="PtNaturalBcs.Reset">func (*PtNaturalBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/ptnatbcs.go?s=835:865#L19">Reset</a></h3>
				<pre>func (o *<a href="#PtNaturalBcs">PtNaturalBcs</a>) Reset()</pre>
				<p>
Reset initialises internal structures
</p>

				
				
				
			
				
				<h3 id="PtNaturalBcs.Set">func (*PtNaturalBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/ptnatbcs.go?s=1183:1275#L32">Set</a></h3>
				<pre>func (o *<a href="#PtNaturalBcs">PtNaturalBcs</a>) Set(key <a href="/pkg/builtin/#string">string</a>, nod *<a href="#Node">Node</a>, fcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (setisok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Set sets new point natural boundary condition data
</p>

				
				
				
			
		
			
			
			<h2 id="RichardsonExtrap">type <a href="https://github.com/cpmech/gofem/blob/master/fem/richardson.go?s=306:951#L6">RichardsonExtrap</a></h2>
			<pre>type RichardsonExtrap struct {

    <span class="comment">// variables after big step</span>
    Y_big []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// primary variables</span>

    <span class="comment">// time loop</span>
    Δt    <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// time step</span>
    Δtcpy <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// copy of Δt for divergence control</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			
			
			

			

			
				
				<h3 id="RichardsonExtrap.Init">func (*RichardsonExtrap) <a href="https://github.com/cpmech/gofem/blob/master/fem/richardson.go?s=953:1008#L29">Init</a></h3>
				<pre>func (o *<a href="#RichardsonExtrap">RichardsonExtrap</a>) Init(d *<a href="#Domain">Domain</a>, Dt <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>)</pre>
				
				
				
				
			
				
				<h3 id="RichardsonExtrap.Run">func (*RichardsonExtrap) <a href="https://github.com/cpmech/gofem/blob/master/fem/richardson.go?s=1325:1448#L52">Run</a></h3>
				<pre>func (o *<a href="#RichardsonExtrap">RichardsonExtrap</a>) Run(d *<a href="#Domain">Domain</a>, s *<a href="#Summary">Summary</a>, DtOut <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, time *<a href="/pkg/builtin/#float64">float64</a>, tf, tout <a href="/pkg/builtin/#float64">float64</a>, tidx *<a href="/pkg/builtin/#int">int</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				
				
				
				
			
		
			
			
			<h2 id="Rjoint">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=2311:4601#L42">Rjoint</a></h2>
			<pre>type Rjoint struct {

    <span class="comment">// basic data</span>
    Edat *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#ElemData">ElemData</a> <span class="comment">// element data; stored in allocator to be used in Connect</span>
    Cid  <a href="/pkg/builtin/#int">int</a>           <span class="comment">// cell/element id</span>
    Ny   <a href="/pkg/builtin/#int">int</a>           <span class="comment">// total number of dofs == rod.Nu + sld.Nu</span>

    <span class="comment">// essential</span>
    Rod *<a href="#Rod">Rod</a>            <span class="comment">// rod element</span>
    Sld *<a href="#ElemU">ElemU</a>          <span class="comment">// solid element</span>
    Mdl <a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#RjointM1">RjointM1</a> <span class="comment">// material model</span>

    <span class="comment">// shape functions evaluations and extrapolator matrices</span>
    Nmat [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [sldNn][rodNn] shape functions of solids @ [N]odes of rod element</span>
    Pmat [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [sldNn][rodNp] shape functions of solids @ integration [P]oints of rod element (for Coulomb model)</span>
    Emat [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [sldNn][sldNp] solid&#39;s extrapolation matrix (for Coulomb model)</span>

    <span class="comment">// variables for Coulomb model</span>
    Coulomb <a href="/pkg/builtin/#bool">bool</a> <span class="comment">// use Coulomb model</span>

    <span class="comment">// auxiliary variables</span>
    ΔuC [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [rodNn][ndim] relative displ. increment of solid @ nodes of rod; Eq (30)</span>
    Δw  []<a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// [ndim] relative velocity; Eq (32)</span>

    <span class="comment">// temporary Jacobian matrices. see Eq. (57)</span>
    Krr [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [rodNu][rodNu] Eq. (58)</span>
    Krs [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [rodNu][sldNu] Eq. (59)</span>
    Ksr [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [sldNu][rodNu] Eq. (60)</span>
    Kss [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [sldNu][sldNu] Eq. (61)</span>

    <span class="comment">// internal values</span>
    States    []*<a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#OnedState">OnedState</a> <span class="comment">// [nip] internal states</span>
    StatesBkp []*<a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#OnedState">OnedState</a> <span class="comment">// [nip] backup internal states</span>
    StatesAux []*<a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#OnedState">OnedState</a> <span class="comment">// [nip] backup internal states</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Rjoint implements the rod-joint (interface/link) element for reinforced solids.
</p>
<pre>The following convention is considered:
 n or N   -- means [N]odes
 p or P   -- means integratioin [P]oints
 nn or Nn -- number of nodes
 np or Np -- number of integration [P]points
 ndim     -- space dimension
 nsig     -- number of stress/strain components == 2 * ndim
 rod      -- means rod element
 rodH     -- rod shape structure
 rodNn    -- rod number of nodes
 rodNp    -- rod number of integration points
 rodS     -- rod shape functions
 sld      -- means solid element
 sldH     -- rod shape structure
 sldNn    -- solid number of nodes
 sldNp    -- solid number of integration points
 sldS     -- solid shape functions
 rodYn    -- rod&#39;s (real) coordinates of node
 rodYp    -- rod&#39;s (real) coordinates of integration point
 r or R   -- means natural coordinates in the solids&#39; system
 z or Z   -- means natural coordinates in the rod&#39;s system
 s or S   -- parametric coordinate along rod
 rodRn    -- natural coordinates or rod&#39;s nodes w.r.t solid&#39;s system
 rodRp    -- natural coordinates of rod&#39;s integration point w.r.t to solid&#39;s system
 Nmat     -- solid shape functions evaluated at rod nodes
 Pmat     -- solid shape functions evaluated at rod integration points
References:
 [1] R Durand, MM Farias, DM Pedroso. Modelling the strengthening of solids with
     incompatible line finite elements, Computers and Structures (2014). Submitted.
 [2] R Durand, MM Farias, DM Pedroso, Computing intersections between non-compatible
     curves and finite elements, Computational Mechanics (2014). Submitted.
 [3] R Durand, MM Farias. A local extrapolation method for finite elements,
     Advances in Engineering Software 67 (2014) 1-9.
     <a href="http://dx.doi.org/10.1016/j.advengsoft.2013.07.002">http://dx.doi.org/10.1016/j.advengsoft.2013.07.002</a>
</pre>


			

			

			
			
			

			

			
				
				<h3 id="Rjoint.AddToKb">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=11399:11478#L380">AddToKb</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="Rjoint.AddToRhs">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=10084:10148#L322">AddToRhs</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="Rjoint.BackupIvs">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=18006:18052#L664">BackupIvs</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) BackupIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
BackupIvs create copy of internal variables
</p>

				
				
				
			
				
				<h3 id="Rjoint.Connect">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=5195:5269#L118">Connect</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) Connect(cid2elem []<a href="#Elem">Elem</a>, c *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>) (nnzK <a href="/pkg/builtin/#int">int</a>, ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Connect connects rod/solid elements in this Rjoint
</p>

				
				
				
			
				
				<h3 id="Rjoint.Decode">func (Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=18897:18942#L704">Decode</a></h3>
				<pre>func (o <a href="#Rjoint">Rjoint</a>) Decode(dec <a href="#Decoder">Decoder</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="Rjoint.Encode">func (Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=18761:18806#L699">Encode</a></h3>
				<pre>func (o <a href="#Rjoint">Rjoint</a>) Encode(enc <a href="#Encoder">Encoder</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="Rjoint.Id">func (Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=5098:5122#L115">Id</a></h3>
				<pre>func (o <a href="#Rjoint">Rjoint</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="Rjoint.InterpStarVars">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=9969:10025#L317">InterpStarVars</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
InterpStarVars interpolates star variables to integration points
</p>

				
				
				
			
				
				<h3 id="Rjoint.Ipoints">func (Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=17407:17453#L645">Ipoints</a></h3>
				<pre>func (o <a href="#Rjoint">Rjoint</a>) Ipoints() (coords [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Ipoints returns the real coordinates of integration points [nip][ndim]
</p>

				
				
				
			
				
				<h3 id="Rjoint.OutIpsData">func (Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=19099:19147#L712">OutIpsData</a></h3>
				<pre>func (o <a href="#Rjoint">Rjoint</a>) OutIpsData() (data []*<a href="#OutIpData">OutIpData</a>)</pre>
				<p>
OutIpsData returns data from all integration points for output
</p>

				
				
				
			
				
				<h3 id="Rjoint.RestoreIvs">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=18268:18315#L678">RestoreIvs</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) RestoreIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
RestoreIvs restore internal variables from copies
</p>

				
				
				
			
				
				<h3 id="Rjoint.SetEleConds">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=9806:9882#L312">SetEleConds</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetEleConds set element conditions
</p>

				
				
				
			
				
				<h3 id="Rjoint.SetEqs">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=9682:9749#L307">SetEqs</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetEqs set equations
</p>

				
				
				
			
				
				<h3 id="Rjoint.SetIniIvs">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=17549:17626#L650">SetIniIvs</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) SetIniIvs(sol *<a href="#Solution">Solution</a>, ivs map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetIniIvs sets initial ivs for given values in sol and ivs map
</p>

				
				
				
			
				
				<h3 id="Rjoint.Update">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=14716:14764#L527">Update</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) Update(sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Update perform (tangent) update
</p>

				
				
				
			
				
				<h3 id="Rjoint.Ureset">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=18554:18602#L692">Ureset</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) Ureset(sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Ureset fixes internal variables after u (displacements) have been zeroed
</p>

				
				
				
			
		
			
			
			<h2 id="Rod">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=453:1498#L8">Rod</a></h2>
			<pre>type Rod struct {

    <span class="comment">// basic data</span>
    Cid <a href="/pkg/builtin/#int">int</a>         <span class="comment">// cell/element id</span>
    X   [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// matrix of nodal coordinates [ndim][nnode]</span>
    Shp *<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Shape">Shape</a>  <span class="comment">// shape structure</span>
    Nu  <a href="/pkg/builtin/#int">int</a>         <span class="comment">// total number of unknowns == 2 * nsn</span>

    <span class="comment">// parameters</span>
    A <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// cross-sectional area</span>

    <span class="comment">// variables for dynamics</span>
    Rho  <a href="/pkg/builtin/#float64">float64</a>  <span class="comment">// density of solids</span>
    Gfcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// gravity function</span>

    <span class="comment">// integration points</span>
    IpsElem []*<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Ipoint">Ipoint</a> <span class="comment">// integration points of element</span>

    <span class="comment">// vectors and matrices</span>
    K   [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// global K matrix</span>
    M   [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// global M matrices</span>
    Rus []<a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// residual: Rus = fi - fx</span>

    <span class="comment">// problem variables</span>
    Umap []<a href="/pkg/builtin/#int">int</a> <span class="comment">// assembly map (location array/element equations)</span>

    <span class="comment">// material model and internal variables</span>
    Model     <a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#OnedSolid">OnedSolid</a>
    States    []*<a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#OnedState">OnedState</a>
    StatesBkp []*<a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#OnedState">OnedState</a>
    StatesAux []*<a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#OnedState">OnedState</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Rod represents a structural rod element (for only axial loads)
</p>


			

			

			
			
			

			

			
				
				<h3 id="Rod.AddToKb">func (Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=5115:5190#L212">AddToKb</a></h3>
				<pre>func (o <a href="#Rod">Rod</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="Rod.AddToRhs">func (Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=4488:4548#L182">AddToRhs</a></h3>
				<pre>func (o <a href="#Rod">Rod</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="Rod.BackupIvs">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=8067:8110#L339">BackupIvs</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) BackupIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
BackupIvs create copy of internal variables
</p>

				
				
				
			
				
				<h3 id="Rod.Decode">func (Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=8946:8988#L379">Decode</a></h3>
				<pre>func (o <a href="#Rod">Rod</a>) Decode(dec <a href="#Decoder">Decoder</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="Rod.Encode">func (Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=8813:8855#L374">Encode</a></h3>
				<pre>func (o <a href="#Rod">Rod</a>) Encode(enc <a href="#Encoder">Encoder</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="Rod.Id">func (Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=3752:3773#L146">Id</a></h3>
				<pre>func (o <a href="#Rod">Rod</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="Rod.InterpStarVars">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=4134:4187#L162">InterpStarVars</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
InterpStarVars interpolates star variables to integration points
</p>

				
				
				
			
				
				<h3 id="Rod.Ipoints">func (Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=6985:7028#L299">Ipoints</a></h3>
				<pre>func (o <a href="#Rod">Rod</a>) Ipoints() (coords [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Ipoints returns the real coordinates of integration points [nip][ndim]
</p>

				
				
				
			
				
				<h3 id="Rod.OutIpsData">func (Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=9145:9190#L387">OutIpsData</a></h3>
				<pre>func (o <a href="#Rod">Rod</a>) OutIpsData() (data []*<a href="#OutIpData">OutIpData</a>)</pre>
				<p>
OutIpsData returns data from all integration points for output
</p>

				
				
				
			
				
				<h3 id="Rod.RestoreIvs">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=8326:8370#L353">RestoreIvs</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) RestoreIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
RestoreIvs restore internal variables from copies
</p>

				
				
				
			
				
				<h3 id="Rod.SetEleConds">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=4323:4396#L174">SetEleConds</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetEleConds set element conditions
</p>

				
				
				
			
				
				<h3 id="Rod.SetEqs">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=3816:3880#L149">SetEqs</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetEqs set equations
</p>

				
				
				
			
				
				<h3 id="Rod.SetIniIvs">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=7240:7314#L308">SetIniIvs</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) SetIniIvs(sol *<a href="#Solution">Solution</a>, ivs map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetIniIvs sets initial ivs for given values in sol and ivs map
</p>

				
				
				
			
				
				<h3 id="Rod.SetIvs">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=7943:8001#L334">SetIvs</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) SetIvs(zvars map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetIvs set secondary variables; e.g. during initialisation via files
</p>

				
				
				
			
				
				<h3 id="Rod.Update">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=6157:6202#L262">Update</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) Update(sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Update perform (tangent) update
</p>

				
				
				
			
				
				<h3 id="Rod.Ureset">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=8609:8654#L367">Ureset</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) Ureset(sol *<a href="#Solution">Solution</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Ureset fixes internal variables after u (displacements) have been zeroed
</p>

				
				
				
			
		
			
			
			<h2 id="Solution">type <a href="https://github.com/cpmech/gofem/blob/master/fem/domain.go?s=2432:2925#L69">Solution</a></h2>
			<pre>type Solution struct {

    <span class="comment">// state</span>
    T      <a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// current time</span>
    Y      []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// DOFs (solution variables); e.g. y = {u, p}</span>
    Dydt   []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// dy/dt</span>
    D2ydt2 []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// d²y/dt²</span>

    <span class="comment">// auxiliary</span>
    ΔY  []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// total increment (for nonlinear solver)</span>
    Psi []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// t1 star vars; e.g. ψ* = β1.p + β2.dpdt</span>
    Zet []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// t2 star vars; e.g. ζ* = α1.u + α2.v + α3.a</span>
    Chi []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// t2 star vars; e.g. χ* = α4.u + α5.v + α6.a</span>
    L   []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// Lagrange multipliers</span>
}</pre>
			<p>
Solution holds the solution data @ nodes.
</p>
<pre>      / u \         / u \
      |   | =&gt; y =  |   |
yb =  | p |         \ p / (ny x 1)
      |   |
      \ λ / (nyb x 1)
</pre>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Summary">type <a href="https://github.com/cpmech/gofem/blob/master/fem/summary.go?s=323:684#L7">Summary</a></h2>
			<pre>type Summary struct {
    Nproc    <a href="/pkg/builtin/#int">int</a>          <span class="comment">// number of processors used in last last run; equal to 1 if not distributed</span>
    OutTimes []<a href="/pkg/builtin/#float64">float64</a>    <span class="comment">// [nOutTimes] output times</span>
    Resids   <a href="/pkg/github.com/cpmech/gosl/utl/">utl</a>.<a href="/pkg/github.com/cpmech/gosl/utl/#DblSlist">DblSlist</a> <span class="comment">// residuals (if Stat is on; includes all stages)</span>
    Dirout   <a href="/pkg/builtin/#string">string</a>       <span class="comment">// directory where results are stored</span>
    Fnkey    <a href="/pkg/builtin/#string">string</a>       <span class="comment">// filename key of simulation</span>
}</pre>
			<p>
Summary records summary of outputs
</p>


			

			

			
			
			

			
				
				<h3 id="ReadSum">func <a href="https://github.com/cpmech/gofem/blob/master/fem/summary.go?s=1251:1295#L44">ReadSum</a></h3>
				<pre>func ReadSum(dir, fnkey <a href="/pkg/builtin/#string">string</a>) (o *<a href="#Summary">Summary</a>)</pre>
				<p>
ReadSum reads summary back
</p>
<pre>Note: returns nil on errors
</pre>

				
				
			

			
				
				<h3 id="Summary.Save">func (Summary) <a href="https://github.com/cpmech/gofem/blob/master/fem/summary.go?s=720:753#L16">Save</a></h3>
				<pre>func (o <a href="#Summary">Summary</a>) Save() (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SaveSums saves summary to disc
</p>

				
				
				
			
		
			
			
			<h2 id="T_iteration">type <a href="https://github.com/cpmech/gofem/blob/master/fem/testing.go?s=439:576#L10">T_iteration</a></h2>
			<pre>type T_iteration struct {
    It     <a href="/pkg/builtin/#int">int</a>     <span class="comment">// iteration number</span>
    ResRel <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// relative residual</span>
    Resid  <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// absolute residual</span>
}</pre>
			<p>
T_iteration testing: iteration results
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="T_results">type <a href="https://github.com/cpmech/gofem/blob/master/fem/testing.go?s=608:1109#L17">T_results</a></h2>
			<pre>type T_results struct {
    Status     <a href="/pkg/builtin/#string">string</a>        <span class="comment">// status message</span>
    LoadFactor <a href="/pkg/builtin/#float64">float64</a>       <span class="comment">// load factor</span>
    Iterations []<a href="#T_iteration">T_iteration</a> <span class="comment">// iterations data</span>
    Kmats      [][][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nele][nu][nu] all stiffness matrices</span>
    Disp       [][]<a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// [nnod][ndim] displacements at nodes</span>
    DispMult   <a href="/pkg/builtin/#float64">float64</a>       <span class="comment">// displacements multiplier</span>
    Note       <a href="/pkg/builtin/#string">string</a>        <span class="comment">// note about number of integration points</span>
    Sigmas     [][][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nele][nip][nsig] all stresses @ all ips 2D:{sx, sy, sxy, sz}</span>
}</pre>
			<p>
T_results testing: results
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="T_results_set">type <a href="https://github.com/cpmech/gofem/blob/master/fem/testing.go?s=1159:1190#L29">T_results_set</a></h2>
			<pre>type T_results_set []*<a href="#T_results">T_results</a></pre>
			<p>
T_results_set is a set of comparison results
</p>


			

			

			
			
			

			

			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	
	<table class="dir">
	<tr>
	<th>Name</th>
	<th>&nbsp;&nbsp;&nbsp;&nbsp;</th>
	<th style="text-align: left; width: auto">Synopsis</th>
	</tr>
	
		<tr>
		<td><a href="..">..</a></td>
		</tr>
	
	
		
			<tr>
			<td class="name"><a href="cmp/">cmp</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto"></td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="data/">data</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto"></td>
			</tr>
		
	
	</table>

	

</div><!-- page -->
<div id="footer">
<br /><br />
<hr>
<pre class="copyright">
Copyright (c) 2015, Dorival Pedroso and Raul Durand
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of gofem nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

</pre><!-- copyright -->
</div><!-- footer -->
</body>
</html>
