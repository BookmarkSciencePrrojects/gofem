<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Gofem &ndash; package fem</title>
<link type="text/css" rel="stylesheet" href="static/style.css">
<script type="text/javascript" src="static/godocs.js"></script>
<style type="text/css"></style>
</head>
<body>
<div id="page"><h1>Gofem &ndash; <b>fem</b> &ndash; finite element method</h1>
<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script type='text/javascript'>
	document.ANALYSIS_DATA = ;
	document.CALLGRAPH = ;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/cpmech/gofem/fem"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
package fem contains elements and solvers for running simulations using the finite element method
</p>

			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
			
				
				<dd><a href="#BuildCoordsMatrix">func BuildCoordsMatrix(cell *inp.Cell, msh *inp.Mesh) (x [][]float64)</a></dd>
			
				
				<dd><a href="#DerivSig">func DerivSig(DσDun [][]float64, n, ndim int, G, D [][]float64)</a></dd>
			
				
				<dd><a href="#FlowKeys">func FlowKeys(ndim int) []string</a></dd>
			
				
				<dd><a href="#GetAndInitPorousModel">func GetAndInitPorousModel(mdb *inp.MatDb, matname, simfnk string) (mdl *mporous.Model, err error)</a></dd>
			
				
				<dd><a href="#GetAndInitSolidModel">func GetAndInitSolidModel(mdb *inp.MatDb, matname, simfnk string, ndim int, pstress bool) (mdl msolid.Model, prms fun.Prms, err error)</a></dd>
			
				
				<dd><a href="#GetContactFaceFlags">func GetContactFaceFlags(extra string) (Macaulay bool, BetRamp, Kappa float64)</a></dd>
			
				
				<dd><a href="#GetIntegrationPoints">func GetIntegrationPoints(nip, nipf int, cellType string) (ipsElem, ipsFace []*shp.Ipoint, err error)</a></dd>
			
				
				<dd><a href="#GetIsEssenKeyMap">func GetIsEssenKeyMap() map[string]bool</a></dd>
			
				
				<dd><a href="#GetSeepFaceFlags">func GetSeepFaceFlags(extra string) (Macaulay bool, BetRamp, Kappa float64)</a></dd>
			
				
				<dd><a href="#GetSolidFlags">func GetSolidFlags(axisym, pstress bool, extra string) (useB, debug bool, thickness float64)</a></dd>
			
				
				<dd><a href="#IpAddToKt">func IpAddToKt(Kt [][]float64, nne, ndim int, coef float64, G, D [][]float64)</a></dd>
			
				
				<dd><a href="#IpBmatrix">func IpBmatrix(B [][]float64, ndim, nne int, G [][]float64, radius float64, S []float64, axisym bool)</a></dd>
			
				
				<dd><a href="#IpBmatrix_sparse">func IpBmatrix_sparse(B *la.Triplet, ndim, nne int, G [][]float64, radius float64, S []float64, axisym bool)</a></dd>
			
				
				<dd><a href="#IpStrains">func IpStrains(εs []float64, nne, ndim int, u []float64, Umap []int, G [][]float64)</a></dd>
			
				
				<dd><a href="#IpStrainsAndInc">func IpStrainsAndInc(εs, Δεs []float64, nne, ndim int, u, Δu []float64, Umap []int, G [][]float64)</a></dd>
			
				
				<dd><a href="#IpStrainsAndIncB">func IpStrainsAndIncB(εs, Δεs []float64, nσ, nu int, B [][]float64, u, Δu []float64, Umap []int)</a></dd>
			
				
				<dd><a href="#Ivs2sigmas">func Ivs2sigmas(σ []float64, i int, ivs map[string][]float64)</a></dd>
			
				
				<dd><a href="#NewDomains">func NewDomains(sim *inp.Simulation, dyncfs *DynCoefs, hydsta *HydroStatic, proc, nproc int, distr bool) (doms []*Domain)</a></dd>
			
				
				<dd><a href="#StressKeys">func StressKeys(ndim int) []string</a></dd>
			
				
				<dd><a href="#TestingCompareResultsU">func TestingCompareResultsU(tst *testing.T, simfilepath, cmpfname, alias string, tolK, tolu, tols float64, skipK, verbose bool)</a></dd>
			
			
				
				<dd><a href="#Beam">type Beam</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.AddToKb">func (o Beam) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.AddToRhs">func (o Beam) AddToRhs(fb []float64, sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.Decode">func (o Beam) Decode(dec Decoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.Encode">func (o Beam) Encode(enc Encoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.Id">func (o Beam) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.InterpStarVars">func (o *Beam) InterpStarVars(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.OutIpsData">func (o Beam) OutIpsData() (data []*OutIpData)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.SetEleConds">func (o *Beam) SetEleConds(key string, f fun.Func, extra string) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.SetEqs">func (o *Beam) SetEqs(eqs [][]int, mixedform_eqs []int) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Beam.Update">func (o *Beam) Update(sol *Solution) (err error)</a></dd>
				
			
				
				<dd><a href="#DebugKb_t">type DebugKb_t</a></dd>
				
				
			
				
				<dd><a href="#Decoder">type Decoder</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GetDecoder">func GetDecoder(r goio.Reader, enctype string) Decoder</a></dd>
				
				
			
				
				<dd><a href="#Dof">type Dof</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Dof.String">func (o *Dof) String() string</a></dd>
				
			
				
				<dd><a href="#Domain">type Domain</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.Clean">func (o *Domain) Clean()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.Read">func (o *Domain) Read(sum *Summary, tidx, proc int, allInOne bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.ReadIvs">func (o *Domain) ReadIvs(dir, fnkey, enctype string, tidx, proc int) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.ReadSol">func (o *Domain) ReadSol(dir, fnkey, enctype string, tidx int) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.Save">func (o *Domain) Save(tidx int, verbose bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.SaveIvs">func (o Domain) SaveIvs(tidx int, verbose bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.SaveSol">func (o Domain) SaveSol(tidx int, verbose bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.SetGeoSt">func (o *Domain) SetGeoSt(stg *inp.Stage) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.SetHydroSt">func (o *Domain) SetHydroSt(stg *inp.Stage) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.SetIniStress">func (o *Domain) SetIniStress(stg *inp.Stage) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.SetIniVals">func (o *Domain) SetIniVals(stgidx int, zeroSol bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.SetInitial">func (o *Domain) SetInitial(stg *inp.Stage) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Domain.SetStage">func (o *Domain) SetStage(stgidx int) (err error)</a></dd>
				
			
				
				<dd><a href="#DynCoefs">type DynCoefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#DynCoefs.CalcAlphas">func (o *DynCoefs) CalcAlphas(Δt float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DynCoefs.CalcBetas">func (o *DynCoefs) CalcBetas(Δt float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DynCoefs.CalcBoth">func (o *DynCoefs) CalcBoth(Δt float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DynCoefs.Init">func (o *DynCoefs) Init(dat *inp.SolverData)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DynCoefs.Print">func (o *DynCoefs) Print()</a></dd>
				
			
				
				<dd><a href="#ElasticRod">type ElasticRod</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ElasticRod.AddToKb">func (o ElasticRod) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElasticRod.AddToRhs">func (o ElasticRod) AddToRhs(fb []float64, sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElasticRod.Decode">func (o ElasticRod) Decode(dec Decoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElasticRod.Encode">func (o ElasticRod) Encode(enc Encoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElasticRod.Id">func (o ElasticRod) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElasticRod.InterpStarVars">func (o *ElasticRod) InterpStarVars(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElasticRod.OutIpsData">func (o ElasticRod) OutIpsData() (data []*OutIpData)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElasticRod.SetEleConds">func (o *ElasticRod) SetEleConds(key string, f fun.Func, extra string) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElasticRod.SetEqs">func (o *ElasticRod) SetEqs(eqs [][]int, mixedform_eqs []int) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElasticRod.Update">func (o *ElasticRod) Update(sol *Solution) (err error)</a></dd>
				
			
				
				<dd><a href="#Elem">type Elem</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewElem">func NewElem(cell *inp.Cell, reg *inp.Region, sim *inp.Simulation) (ele Elem, err error)</a></dd>
				
				
			
				
				<dd><a href="#ElemConnector">type ElemConnector</a></dd>
				
				
			
				
				<dd><a href="#ElemIntvars">type ElemIntvars</a></dd>
				
				
			
				
				<dd><a href="#ElemP">type ElemP</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.AddToKb">func (o ElemP) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.AddToRhs">func (o ElemP) AddToRhs(fb []float64, sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.BackupIvs">func (o *ElemP) BackupIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.Decode">func (o ElemP) Decode(dec Decoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.Encode">func (o ElemP) Encode(enc Encoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.Id">func (o ElemP) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.InterpStarVars">func (o *ElemP) InterpStarVars(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.Ipoints">func (o ElemP) Ipoints() (coords [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.OutIpsData">func (o ElemP) OutIpsData() (data []*OutIpData)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.RestoreIvs">func (o *ElemP) RestoreIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.SetEleConds">func (o *ElemP) SetEleConds(key string, f fun.Func, extra string) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.SetEqs">func (o *ElemP) SetEqs(eqs [][]int, mixedform_eqs []int) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.SetIniIvs">func (o *ElemP) SetIniIvs(sol *Solution, ignored map[string][]float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.Update">func (o *ElemP) Update(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemP.Ureset">func (o *ElemP) Ureset(sol *Solution) (err error)</a></dd>
				
			
				
				<dd><a href="#ElemPhi">type ElemPhi</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.AddToKb">func (o *ElemPhi) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.AddToRhs">func (o *ElemPhi) AddToRhs(fb []float64, sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.Decode">func (o *ElemPhi) Decode(dec Decoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.Encode">func (o *ElemPhi) Encode(enc Encoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.Id">func (o *ElemPhi) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.InterpStarVars">func (o *ElemPhi) InterpStarVars(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.OutIpsData">func (o *ElemPhi) OutIpsData() (data []*OutIpData)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.SetEleConds">func (o *ElemPhi) SetEleConds(key string, f fun.Func, extra string) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.SetEqs">func (o *ElemPhi) SetEqs(eqs [][]int, mixedform_eqs []int) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemPhi.Update">func (o *ElemPhi) Update(sol *Solution) (err error)</a></dd>
				
			
				
				<dd><a href="#ElemU">type ElemU</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.AddToKb">func (o *ElemU) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.AddToRhs">func (o *ElemU) AddToRhs(fb []float64, sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.BackupIvs">func (o *ElemU) BackupIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.Decode">func (o ElemU) Decode(dec Decoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.Encode">func (o ElemU) Encode(enc Encoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.Id">func (o ElemU) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.InterpStarVars">func (o *ElemU) InterpStarVars(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.Ipoints">func (o ElemU) Ipoints() (coords [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.OutIpsData">func (o ElemU) OutIpsData() (data []*OutIpData)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.RestoreIvs">func (o *ElemU) RestoreIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.SetEleConds">func (o *ElemU) SetEleConds(key string, f fun.Func, extra string) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.SetEqs">func (o *ElemU) SetEqs(eqs [][]int, mixedform_eqs []int) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.SetIniIvs">func (o *ElemU) SetIniIvs(sol *Solution, ivs map[string][]float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.Update">func (o *ElemU) Update(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemU.Ureset">func (o *ElemU) Ureset(sol *Solution) (err error)</a></dd>
				
			
				
				<dd><a href="#ElemUP">type ElemUP</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.AddToKb">func (o ElemUP) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.AddToRhs">func (o ElemUP) AddToRhs(fb []float64, sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.BackupIvs">func (o *ElemUP) BackupIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.Decode">func (o ElemUP) Decode(dec Decoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.Encode">func (o ElemUP) Encode(enc Encoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.Id">func (o ElemUP) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.InterpStarVars">func (o *ElemUP) InterpStarVars(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.Ipoints">func (o ElemUP) Ipoints() (coords [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.OutIpsData">func (o ElemUP) OutIpsData() (data []*OutIpData)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.RestoreIvs">func (o *ElemUP) RestoreIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.SetEleConds">func (o *ElemUP) SetEleConds(key string, f fun.Func, extra string) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.SetEqs">func (o *ElemUP) SetEqs(eqs [][]int, mixedform_eqs []int) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.SetIniIvs">func (o *ElemUP) SetIniIvs(sol *Solution, ivs map[string][]float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.Update">func (o *ElemUP) Update(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ElemUP.Ureset">func (o *ElemUP) Ureset(sol *Solution) (err error)</a></dd>
				
			
				
				<dd><a href="#Encoder">type Encoder</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GetEncoder">func GetEncoder(w goio.Writer, enctype string) Encoder</a></dd>
				
				
			
				
				<dd><a href="#EssentialBc">type EssentialBc</a></dd>
				
				
			
				
				<dd><a href="#EssentialBcs">type EssentialBcs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EssentialBcs.AddToRhs">func (o EssentialBcs) AddToRhs(fb []float64, sol *Solution)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EssentialBcs.Build">func (o *EssentialBcs) Build(ny int) (nλ, nnzA int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EssentialBcs.Init">func (o *EssentialBcs) Init(hydfcn *HydroStatic)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EssentialBcs.List">func (o *EssentialBcs) List(t float64) (l string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EssentialBcs.Set">func (o *EssentialBcs) Set(key string, nodes []*Node, fcn fun.Func, extra string) (err error)</a></dd>
				
			
				
				<dd><a href="#FEM">type FEM</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFEM">func NewFEM(simfilepath, alias string, erasePrev, saveSummary, readSummary, allowParallel, verbose bool, goroutineId int) (o *FEM)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FEM.Run">func (o *FEM) Run() (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FEM.SetStage">func (o *FEM) SetStage(stgidx int) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FEM.SolveOneStage">func (o *FEM) SolveOneStage(stgidx int, zerostage bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FEM.ZeroStage">func (o *FEM) ZeroStage(stgidx int, zeroSol bool) (err error)</a></dd>
				
			
				
				<dd><a href="#FEsolver">type FEsolver</a></dd>
				
				
			
				
				<dd><a href="#GeoLayer">type GeoLayer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#GeoLayer.Calc">func (o GeoLayer) Calc(z float64) (*geostate, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GeoLayer.Start">func (o *GeoLayer) Start(prev *geostate, g float64)</a></dd>
				
			
				
				<dd><a href="#GeoLayers">type GeoLayers</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#GeoLayers.Len">func (o GeoLayers) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GeoLayers.Less">func (o GeoLayers) Less(i, j int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GeoLayers.String">func (o GeoLayers) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GeoLayers.Swap">func (o GeoLayers) Swap(i, j int)</a></dd>
				
			
				
				<dd><a href="#HydroStatic">type HydroStatic</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#HydroStatic.Calc">func (o HydroStatic) Calc(z float64) (pl, ρL float64, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#HydroStatic.Init">func (o *HydroStatic) Init(waterLevel, waterRho0, waterBulk, g float64)</a></dd>
				
			
				
				<dd><a href="#Info">type Info</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GetElemInfo">func GetElemInfo(cell *inp.Cell, reg *inp.Region, sim *inp.Simulation) (info *Info, inactive bool, err error)</a></dd>
				
				
			
				
				<dd><a href="#NaturalBc">type NaturalBc</a></dd>
				
				
			
				
				<dd><a href="#Node">type Node</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewNode">func NewNode(v *inp.Vert) *Node</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.AddDofAndEq">func (o *Node) AddDofAndEq(ukey string, eqnum int) (nexteq int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.GetDof">func (o *Node) GetDof(ukey string) *Dof</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.GetEq">func (o *Node) GetEq(ukey string) (eqNumber int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.GetKeys">func (o *Node) GetKeys() []string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.SetEq">func (o *Node) SetEq(ukey string, eqNumber int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.String">func (o *Node) String() string</a></dd>
				
			
				
				<dd><a href="#OutIpData">type OutIpData</a></dd>
				
				
			
				
				<dd><a href="#PtNaturalBc">type PtNaturalBc</a></dd>
				
				
			
				
				<dd><a href="#PtNaturalBcs">type PtNaturalBcs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PtNaturalBcs.AddToRhs">func (o PtNaturalBcs) AddToRhs(fb []float64, t float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PtNaturalBcs.List">func (o *PtNaturalBcs) List(t float64) (l string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PtNaturalBcs.Reset">func (o *PtNaturalBcs) Reset()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PtNaturalBcs.Set">func (o *PtNaturalBcs) Set(key string, nod *Node, fcn fun.Func, extra string) (setisok bool)</a></dd>
				
			
				
				<dd><a href="#RichardsonExtrap">type RichardsonExtrap</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RichardsonExtrap.Init">func (o *RichardsonExtrap) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RichardsonExtrap.Run">func (o *RichardsonExtrap) Run(tf float64, dtFunc, dtoFunc fun.Func, verbose bool, dbgKb DebugKb_t) (err error)</a></dd>
				
			
				
				<dd><a href="#Rjoint">type Rjoint</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.AddToKb">func (o *Rjoint) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.AddToRhs">func (o *Rjoint) AddToRhs(fb []float64, sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.BackupIvs">func (o *Rjoint) BackupIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.Connect">func (o *Rjoint) Connect(cid2elem []Elem, c *inp.Cell) (nnzK int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.Decode">func (o Rjoint) Decode(dec Decoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.Encode">func (o Rjoint) Encode(enc Encoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.Id">func (o Rjoint) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.InterpStarVars">func (o *Rjoint) InterpStarVars(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.Ipoints">func (o Rjoint) Ipoints() (coords [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.OutIpsData">func (o Rjoint) OutIpsData() (data []*OutIpData)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.RestoreIvs">func (o *Rjoint) RestoreIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.SetEleConds">func (o *Rjoint) SetEleConds(key string, f fun.Func, extra string) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.SetEqs">func (o *Rjoint) SetEqs(eqs [][]int, mixedform_eqs []int) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.SetIniIvs">func (o *Rjoint) SetIniIvs(sol *Solution, ivs map[string][]float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.Update">func (o *Rjoint) Update(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rjoint.Ureset">func (o *Rjoint) Ureset(sol *Solution) (err error)</a></dd>
				
			
				
				<dd><a href="#Rod">type Rod</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.AddToKb">func (o Rod) AddToKb(Kb *la.Triplet, sol *Solution, firstIt bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.AddToRhs">func (o Rod) AddToRhs(fb []float64, sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.BackupIvs">func (o *Rod) BackupIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.Decode">func (o Rod) Decode(dec Decoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.Encode">func (o Rod) Encode(enc Encoder) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.Id">func (o Rod) Id() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.InterpStarVars">func (o *Rod) InterpStarVars(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.Ipoints">func (o Rod) Ipoints() (coords [][]float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.OutIpsData">func (o Rod) OutIpsData() (data []*OutIpData)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.RestoreIvs">func (o *Rod) RestoreIvs(aux bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.SetEleConds">func (o *Rod) SetEleConds(key string, f fun.Func, extra string) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.SetEqs">func (o *Rod) SetEqs(eqs [][]int, mixedform_eqs []int) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.SetIniIvs">func (o *Rod) SetIniIvs(sol *Solution, ivs map[string][]float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.SetIvs">func (o *Rod) SetIvs(zvars map[string][]float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.Update">func (o *Rod) Update(sol *Solution) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rod.Ureset">func (o *Rod) Ureset(sol *Solution) (err error)</a></dd>
				
			
				
				<dd><a href="#Solution">type Solution</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Solution.Reset">func (o *Solution) Reset(steady bool)</a></dd>
				
			
				
				<dd><a href="#SolverImplicit">type SolverImplicit</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SolverImplicit.Run">func (o *SolverImplicit) Run(tf float64, dtFunc, dtoFunc fun.Func, verbose bool, dbgKb DebugKb_t) (err error)</a></dd>
				
			
				
				<dd><a href="#Summary">type Summary</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Summary.Read">func (o *Summary) Read(dir, fnkey, enctype string) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Summary.Save">func (o Summary) Save(dirout, fnkey, enctype string, nproc, proc int, verbose bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Summary.SaveDomains">func (o *Summary) SaveDomains(time float64, doms []*Domain, verbose bool) (err error)</a></dd>
				
			
				
				<dd><a href="#T_iteration">type T_iteration</a></dd>
				
				
			
				
				<dd><a href="#T_results">type T_results</a></dd>
				
				
			
				
				<dd><a href="#T_results_set">type T_results_set</a></dd>
				
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/github.com/cpmech/gofem/fem/auxiliary.go">auxiliary.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/auxsolid.go">auxsolid.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/domain.go">domain.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/dyncoefs.go">dyncoefs.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_beam.go">e_beam.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_elastrod.go">e_elastrod.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_p.go">e_p.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_phi.go">e_phi.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_rjoint.go">e_rjoint.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_rod.go">e_rod.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_u.go">e_u.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/e_up.go">e_up.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/element.go">element.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/essenbcs.go">essenbcs.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/fem.go">fem.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/fileio.go">fileio.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/geost.go">geost.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/hydrost.go">hydrost.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/inistress.go">inistress.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/initial.go">initial.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/keycodes.go">keycodes.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/matmodels.go">matmodels.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/naturalbcs.go">naturalbcs.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/node.go">node.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/ptnatbcs.go">ptnatbcs.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/s_implicit.go">s_implicit.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/s_richardson.go">s_richardson.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/summary.go">summary.go</a>
			
				<a href="/src/github.com/cpmech/gofem/fem/testing.go">testing.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		<div id="pkg-callgraph" class="toggle" style="display: none">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
		</div> <!-- .expanded -->
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
			<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls&mdash;perhaps dynamically.
			</p>
			<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
			<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
			<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
			<!-- Zero means show all package entry points. -->
			<ul style="margin-left: 0.5in" id="callgraph-0" class="treeview"></ul>
		</div>
		</div> <!-- #pkg-callgraph -->

		
			<h2 id="pkg-constants">Constants</h2>
			
				<pre>const <span id="SQ2">SQ2</span> = <a href="/pkg/math/">math</a>.<a href="/pkg/math/#Sqrt2">Sqrt2</a></pre>
				
			
		
		
		
			
			
			<h2 id="BuildCoordsMatrix">func <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=4837:4906#L111">BuildCoordsMatrix</a></h2>
			<pre>func BuildCoordsMatrix(cell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>, msh *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Mesh">Mesh</a>) (x [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
BuildCoordsMatrix returns the coordinate matrix of a particular Cell
</p>

			
			

		
			
			
			<h2 id="DerivSig">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=4943:5007#L74">DerivSig</a></h2>
			<pre>func DerivSig(DσDun [][]<a href="/pkg/builtin/#float64">float64</a>, n, ndim <a href="/pkg/builtin/#int">int</a>, G, D [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
DerivSig returns the derivative of σ (Mandel) with respect to displacement at nodes
</p>
<pre>Note: DσDun = ∂σ/∂un  [nσ][ndim]
</pre>

			
			

		
			
			
			<h2 id="FlowKeys">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=9570:9602#L216">FlowKeys</a></h2>
			<pre>func FlowKeys(ndim <a href="/pkg/builtin/#int">int</a>) []<a href="/pkg/builtin/#string">string</a></pre>
			
			
			

		
			
			
			<h2 id="GetAndInitPorousModel">func <a href="https://github.com/cpmech/gofem/blob/master/fem/matmodels.go?s=566:664#L11">GetAndInitPorousModel</a></h2>
			<pre>func GetAndInitPorousModel(mdb *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#MatDb">MatDb</a>, matname, simfnk <a href="/pkg/builtin/#string">string</a>) (mdl *<a href="/pkg/github.com/cpmech/gofem/mporous/">mporous</a>.<a href="/pkg/github.com/cpmech/gofem/mporous/#Model">Model</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
GetAndInitPorousModel get porous model from material name
It returns nil on errors, after logging
</p>

			
			

		
			
			
			<h2 id="GetAndInitSolidModel">func <a href="https://github.com/cpmech/gofem/blob/master/fem/matmodels.go?s=1932:2066#L62">GetAndInitSolidModel</a></h2>
			<pre>func GetAndInitSolidModel(mdb *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#MatDb">MatDb</a>, matname, simfnk <a href="/pkg/builtin/#string">string</a>, ndim <a href="/pkg/builtin/#int">int</a>, pstress <a href="/pkg/builtin/#bool">bool</a>) (mdl <a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#Model">Model</a>, prms <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Prms">Prms</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			
			
			

		
			
			
			<h2 id="GetContactFaceFlags">func <a href="https://github.com/cpmech/gofem/blob/master/fem/keycodes.go?s=2050:2128#L81">GetContactFaceFlags</a></h2>
			<pre>func GetContactFaceFlags(extra <a href="/pkg/builtin/#string">string</a>) (Macaulay <a href="/pkg/builtin/#bool">bool</a>, BetRamp, Kappa <a href="/pkg/builtin/#float64">float64</a>)</pre>
			
			
			

		
			
			
			<h2 id="GetIntegrationPoints">func <a href="https://github.com/cpmech/gofem/blob/master/fem/keycodes.go?s=301:402#L5">GetIntegrationPoints</a></h2>
			<pre>func GetIntegrationPoints(nip, nipf <a href="/pkg/builtin/#int">int</a>, cellType <a href="/pkg/builtin/#string">string</a>) (ipsElem, ipsFace []*<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Ipoint">Ipoint</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			
			
			

		
			
			
			<h2 id="GetIsEssenKeyMap">func <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=4248:4287#L133">GetIsEssenKeyMap</a></h2>
			<pre>func GetIsEssenKeyMap() map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
GetFirstYandCmap returns the initial &#34;yandc&#34; map with additional keys that EssentialBcs can handle
</p>
<pre>rigid  -- define rigid element constraints
incsup -- inclined support constraints
hst    -- set hydrostatic pressures
</pre>

			
			

		
			
			
			<h2 id="GetSeepFaceFlags">func <a href="https://github.com/cpmech/gofem/blob/master/fem/keycodes.go?s=1547:1622#L57">GetSeepFaceFlags</a></h2>
			<pre>func GetSeepFaceFlags(extra <a href="/pkg/builtin/#string">string</a>) (Macaulay <a href="/pkg/builtin/#bool">bool</a>, BetRamp, Kappa <a href="/pkg/builtin/#float64">float64</a>)</pre>
			
			
			

		
			
			
			<h2 id="GetSolidFlags">func <a href="https://github.com/cpmech/gofem/blob/master/fem/keycodes.go?s=896:988#L23">GetSolidFlags</a></h2>
			<pre>func GetSolidFlags(axisym, pstress <a href="/pkg/builtin/#bool">bool</a>, extra <a href="/pkg/builtin/#string">string</a>) (useB, debug <a href="/pkg/builtin/#bool">bool</a>, thickness <a href="/pkg/builtin/#float64">float64</a>)</pre>
			
			
			

		
			
			
			<h2 id="IpAddToKt">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=294:371#L6">IpAddToKt</a></h2>
			<pre>func IpAddToKt(Kt [][]<a href="/pkg/builtin/#float64">float64</a>, nne, ndim <a href="/pkg/builtin/#int">int</a>, coef <a href="/pkg/builtin/#float64">float64</a>, G, D [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			
			
			

		
			
			
			<h2 id="IpBmatrix">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=7076:7177#L106">IpBmatrix</a></h2>
			<pre>func IpBmatrix(B [][]<a href="/pkg/builtin/#float64">float64</a>, ndim, nne <a href="/pkg/builtin/#int">int</a>, G [][]<a href="/pkg/builtin/#float64">float64</a>, radius <a href="/pkg/builtin/#float64">float64</a>, S []<a href="/pkg/builtin/#float64">float64</a>, axisym <a href="/pkg/builtin/#bool">bool</a>)</pre>
			
			
			

		
			
			
			<h2 id="IpBmatrix_sparse">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=8113:8221#L149">IpBmatrix_sparse</a></h2>
			<pre>func IpBmatrix_sparse(B *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, ndim, nne <a href="/pkg/builtin/#int">int</a>, G [][]<a href="/pkg/builtin/#float64">float64</a>, radius <a href="/pkg/builtin/#float64">float64</a>, S []<a href="/pkg/builtin/#float64">float64</a>, axisym <a href="/pkg/builtin/#bool">bool</a>)</pre>
			
			
			

		
			
			
			<h2 id="IpStrains">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=3773:3857#L33">IpStrains</a></h2>
			<pre>func IpStrains(εs []<a href="/pkg/builtin/#float64">float64</a>, nne, ndim <a href="/pkg/builtin/#int">int</a>, u []<a href="/pkg/builtin/#float64">float64</a>, Umap []<a href="/pkg/builtin/#int">int</a>, G [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			
			
			

		
			
			
			<h2 id="IpStrainsAndInc">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=4212:4314#L51">IpStrainsAndInc</a></h2>
			<pre>func IpStrainsAndInc(εs, Δεs []<a href="/pkg/builtin/#float64">float64</a>, nne, ndim <a href="/pkg/builtin/#int">int</a>, u, Δu []<a href="/pkg/builtin/#float64">float64</a>, Umap []<a href="/pkg/builtin/#int">int</a>, G [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			
			
			

		
			
			
			<h2 id="IpStrainsAndIncB">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=7845:7946#L139">IpStrainsAndIncB</a></h2>
			<pre>func IpStrainsAndIncB(εs, Δεs []<a href="/pkg/builtin/#float64">float64</a>, nσ, nu <a href="/pkg/builtin/#int">int</a>, B [][]<a href="/pkg/builtin/#float64">float64</a>, u, Δu []<a href="/pkg/builtin/#float64">float64</a>, Umap []<a href="/pkg/builtin/#int">int</a>)</pre>
			
			
			

		
			
			
			<h2 id="Ivs2sigmas">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=9045:9107#L186">Ivs2sigmas</a></h2>
			<pre>func Ivs2sigmas(σ []<a href="/pkg/builtin/#float64">float64</a>, i <a href="/pkg/builtin/#int">int</a>, ivs map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Ivs2sigmas converts ivs map to σ values [nsig]
</p>
<pre>σ -- [ndim] stresses
i -- index of integration point
</pre>

			
			

		
			
			
			<h2 id="NewDomains">func <a href="https://github.com/cpmech/gofem/blob/master/fem/domain.go?s=4293:4414#L100">NewDomains</a></h2>
			<pre>func NewDomains(sim *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Simulation">Simulation</a>, dyncfs *<a href="#DynCoefs">DynCoefs</a>, hydsta *<a href="#HydroStatic">HydroStatic</a>, proc, nproc <a href="/pkg/builtin/#int">int</a>, distr <a href="/pkg/builtin/#bool">bool</a>) (doms []*<a href="#Domain">Domain</a>)</pre>
			<p>
NewDomains returns domains
</p>

			
			

		
			
			
			<h2 id="StressKeys">func <a href="https://github.com/cpmech/gofem/blob/master/fem/auxsolid.go?s=9412:9446#L209">StressKeys</a></h2>
			<pre>func StressKeys(ndim <a href="/pkg/builtin/#int">int</a>) []<a href="/pkg/builtin/#string">string</a></pre>
			
			
			

		
			
			
			<h2 id="TestingCompareResultsU">func <a href="https://github.com/cpmech/gofem/blob/master/fem/testing.go?s=1257:1384#L32">TestingCompareResultsU</a></h2>
			<pre>func TestingCompareResultsU(tst *<a href="/pkg/testing/">testing</a>.<a href="/pkg/testing/#T">T</a>, simfilepath, cmpfname, alias <a href="/pkg/builtin/#string">string</a>, tolK, tolu, tols <a href="/pkg/builtin/#float64">float64</a>, skipK, verbose <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
testing_compare_results_u compares results with u-formulation
</p>

			
			

		
		
			
			
			<h2 id="Beam">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=411:1681#L8">Beam</a></h2>
			<pre>type Beam struct {

    <span class="comment">// basic data</span>
    Cell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>   <span class="comment">// the cell structure</span>
    X    [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// matrix of nodal coordinates [ndim][nnode]</span>
    Nu   <a href="/pkg/builtin/#int">int</a>         <span class="comment">// total number of unknowns == 2 * nsn</span>
    Ndim <a href="/pkg/builtin/#int">int</a>         <span class="comment">// space dimension</span>

    <span class="comment">// parameters</span>
    E   <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// Young&#39;s modulus</span>
    A   <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// cross-sectional area</span>
    Izz <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// Inertia zz</span>

    <span class="comment">// variables for dynamics</span>
    Rho  <a href="/pkg/builtin/#float64">float64</a>  <span class="comment">// density of solids</span>
    Gfcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// gravity function</span>

    <span class="comment">// vectors and matrices</span>
    T   [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// global-to-local transformation matrix [nnode*ndim][nnode*ndim]</span>
    Kl  [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// local K matrix</span>
    K   [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// global K matrix</span>
    Ml  [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// local M matrices</span>
    M   [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// global M matrices</span>
    Rus []<a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// residual: Rus = fi - fx</span>

    <span class="comment">// problem variables</span>
    Umap []<a href="/pkg/builtin/#int">int</a>    <span class="comment">// assembly map (location array/element equations)</span>
    Hasq <a href="/pkg/builtin/#bool">bool</a>     <span class="comment">// has distributed loads</span>
    QnL  <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// distributed normal load functions: left</span>
    QnR  <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// distributed normal load functions: right</span>
    Qt   <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// distributed tangential load</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Beam represents a structural beam element (Euler-Bernoulli, linear elastic)
</p>


			

			

			
			
			

			

			
				
				<h3 id="Beam.AddToKb">func (Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=7061:7139#L294">AddToKb</a></h3>
				<pre>func (o <a href="#Beam">Beam</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="Beam.AddToRhs">func (Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=6002:6065#L249">AddToRhs</a></h3>
				<pre>func (o <a href="#Beam">Beam</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="Beam.Decode">func (Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=7636:7681#L323">Decode</a></h3>
				<pre>func (o <a href="#Beam">Beam</a>) Decode(dec <a href="#Decoder">Decoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="Beam.Encode">func (Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=7540:7585#L318">Encode</a></h3>
				<pre>func (o <a href="#Beam">Beam</a>) Encode(enc <a href="#Encoder">Encoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="Beam.Id">func (Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=4950:4972#L200">Id</a></h3>
				<pre>func (o <a href="#Beam">Beam</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="Beam.InterpStarVars">func (*Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=5837:5893#L241">InterpStarVars</a></h3>
				<pre>func (o *<a href="#Beam">Beam</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
InterpStarVars interpolates star variables to integration points
</p>

				
				
				
			
				
				<h3 id="Beam.OutIpsData">func (Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=7761:7807#L328">OutIpsData</a></h3>
				<pre>func (o <a href="#Beam">Beam</a>) OutIpsData() (data []*<a href="#OutIpData">OutIpData</a>)</pre>
				<p>
OutIpsData returns data from all integration points for output
</p>

				
				
				
			
				
				<h3 id="Beam.SetEleConds">func (*Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=5344:5420#L216">SetEleConds</a></h3>
				<pre>func (o *<a href="#Beam">Beam</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEleConds set element conditions
</p>

				
				
				
			
				
				<h3 id="Beam.SetEqs">func (*Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=5064:5131#L203">SetEqs</a></h3>
				<pre>func (o *<a href="#Beam">Beam</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEqs set equations [2][?]. Format of eqs == format of info.Dofs
</p>

				
				
				
			
				
				<h3 id="Beam.Update">func (*Beam) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_beam.go?s=7441:7489#L313">Update</a></h3>
				<pre>func (o *<a href="#Beam">Beam</a>) Update(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Update perform (tangent) update
</p>

				
				
				
			
		
			
			
			<h2 id="DebugKb_t">type <a href="https://github.com/cpmech/gofem/blob/master/fem/fem.go?s=514:552#L10">DebugKb_t</a></h2>
			<pre>type DebugKb_t func(d *<a href="#Domain">Domain</a>, it <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
function to debug global Jacobian matrix
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Decoder">type <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=478:533#L15">Decoder</a></h2>
			<pre>type Decoder interface {
    Decode(e interface{}) <a href="/pkg/builtin/#error">error</a>
}</pre>
			<p>
Decoder defines decoders; e.g. gob or json
</p>


			

			

			
			
			

			
				
				<h3 id="GetDecoder">func <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=748:802#L28">GetDecoder</a></h3>
				<pre>func GetDecoder(r <a href="/pkg/io/">goio</a>.<a href="/pkg/io/#Reader">Reader</a>, enctype <a href="/pkg/builtin/#string">string</a>) <a href="#Decoder">Decoder</a></pre>
				<p>
GetDecoder returns a new decoder
</p>

				
				
			

			
		
			
			
			<h2 id="Dof">type <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=335:432#L4">Dof</a></h2>
			<pre>type Dof struct {
    Key <a href="/pkg/builtin/#string">string</a> <span class="comment">// primary variable key. e.g. &#34;ux&#34;</span>
    Eq  <a href="/pkg/builtin/#int">int</a>    <span class="comment">// equation number</span>
}</pre>
			<p>
Dof holds information about a degree-of-freedom == solution variable
</p>


			

			

			
			
			

			

			
				
				<h3 id="Dof.String">func (*Dof) <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=490:519#L10">String</a></h3>
				<pre>func (o *<a href="#Dof">Dof</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
String returns the string representation of this Dof
</p>

				
				
				
			
		
			
			
			<h2 id="Domain">type <a href="https://github.com/cpmech/gofem/blob/master/fem/domain.go?s=1469:4170#L37">Domain</a></h2>
			<pre>type Domain struct {

    <span class="comment">// init: auxiliary variables</span>
    Distr  <a href="/pkg/builtin/#bool">bool</a>            <span class="comment">// distributed/parallel run</span>
    Proc   <a href="/pkg/builtin/#int">int</a>             <span class="comment">// this processor number</span>
    Sim    *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Simulation">Simulation</a> <span class="comment">// [from FEM] input data</span>
    Reg    *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Region">Region</a>     <span class="comment">// region data</span>
    Msh    *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Mesh">Mesh</a>       <span class="comment">// mesh data</span>
    LinSol <a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#LinSol">LinSol</a>       <span class="comment">// linear solver</span>
    DynCfs *<a href="#DynCoefs">DynCoefs</a>       <span class="comment">// [from FEM] coefficients for dynamics/transient simulations</span>
    HydSta *<a href="#HydroStatic">HydroStatic</a>    <span class="comment">// [from FEM] function to compute hydrostatic state</span>

    <span class="comment">// stage: nodes (active) and elements (active AND in this processor)</span>
    Nodes  []*<a href="#Node">Node</a> <span class="comment">// active nodes (for each stage). Note: indices in Nodes do NOT correpond to Ids =&gt; use Vid2node to access Nodes using Ids.</span>
    Elems  []<a href="#Elem">Elem</a>  <span class="comment">// [procNcells] only active elements in this processor (for each stage)</span>
    MyCids []<a href="/pkg/builtin/#int">int</a>   <span class="comment">// [procNcells] the ids of cells in this processor</span>

    <span class="comment">// stage: auxiliary maps for dofs and equation types</span>
    F2Y      map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#string">string</a> <span class="comment">// converts f-keys to y-keys; e.g.: &#34;ux&#34; =&gt; &#34;fx&#34;</span>
    YandC    map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#bool">bool</a>   <span class="comment">// y and constraints keys; e.g. &#34;ux&#34;, &#34;pl&#34;, &#34;H&#34;, &#34;incsup&#34;, &#34;rigid&#34;</span>
    Dof2Tnum map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#int">int</a>    <span class="comment">// {t1,t2}-types: dof =&gt; t_number; e.g. &#34;ux&#34; =&gt; 2, &#34;pl&#34; =&gt; 1</span>

    <span class="comment">// stage: auxiliary maps for nodes and elements</span>
    Vid2node   []*<a href="#Node">Node</a> <span class="comment">// [nverts] VertexId =&gt; index in Nodes. Inactive vertices are &#39;nil&#39;</span>
    Cid2elem   []<a href="#Elem">Elem</a>  <span class="comment">// [ncells] CellId =&gt; index in Elems. Cells in other processors or inactive are &#39;nil&#39;</span>
    Cid2active []<a href="/pkg/builtin/#bool">bool</a>  <span class="comment">// [ncells] CellId =&gt; whether cell is active or not in ANY processor</span>

    <span class="comment">// stage: subsets of elements</span>
    ElemIntvars []<a href="#ElemIntvars">ElemIntvars</a>   <span class="comment">// elements with internal vars in this processor</span>
    ElemConnect []<a href="#ElemConnector">ElemConnector</a> <span class="comment">// connector elements in this processor</span>

    <span class="comment">// stage: coefficients and prescribed forces</span>
    EssenBcs <a href="#EssentialBcs">EssentialBcs</a> <span class="comment">// constraints (Lagrange multipliers)</span>
    PtNatBcs <a href="#PtNaturalBcs">PtNaturalBcs</a> <span class="comment">// point loads such as prescribed forces at nodes</span>

    <span class="comment">// stage: t1 and t2 variables</span>
    T1eqs []<a href="/pkg/builtin/#int">int</a> <span class="comment">// first t-derivative variables; e.g.:  dp/dt vars (subset of ykeys)</span>
    T2eqs []<a href="/pkg/builtin/#int">int</a> <span class="comment">// second t-derivative variables; e.g.: d²u/dt² vars (subset of ykeys)</span>

    <span class="comment">// stage: dimensions</span>
    NnzKb <a href="/pkg/builtin/#int">int</a> <span class="comment">// number of nonzeros in Kb matrix</span>
    Ny    <a href="/pkg/builtin/#int">int</a> <span class="comment">// total number of dofs, except λ</span>
    Nlam  <a href="/pkg/builtin/#int">int</a> <span class="comment">// total number of Lagrange multipliers</span>
    NnzA  <a href="/pkg/builtin/#int">int</a> <span class="comment">// number of nonzeros in A (constraints) matrix</span>
    Nyb   <a href="/pkg/builtin/#int">int</a> <span class="comment">// total number of equations: ny + nλ</span>

    <span class="comment">// stage: solution and linear solver</span>
    Sol      *<a href="#Solution">Solution</a>   <span class="comment">// solution state</span>
    Kb       *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a> <span class="comment">// Jacobian == dRdy</span>
    Fb       []<a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// residual == -fb</span>
    Wb       []<a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// workspace</span>
    InitLSol <a href="/pkg/builtin/#bool">bool</a>        <span class="comment">// flag telling that linear solver needs to be initialised prior to any further call</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Domain holds all Nodes and Elements active during a stage in addition to the Solution at nodes.
Only elements in this processor are recorded here; however information from
all cells might be recorded as well.
</p>


			

			

			
			
			

			

			
				
				<h3 id="Domain.Clean">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/domain.go?s=4215:4239#L95">Clean</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) Clean()</pre>
				<p>
Clean cleans memory allocated by domain
</p>

				
				
				
			
				
				<h3 id="Domain.Read">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=4565:4643#L178">Read</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) Read(sum *<a href="#Summary">Summary</a>, tidx, proc <a href="/pkg/builtin/#int">int</a>, allInOne <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
In performs the inverse operation of Out()
</p>
<pre>allInOne -- indicates that all results must be read into the root processor only
            For example when plotting or generating VTU files (or testing)

If allInOne is false, each processor will read its part as described by Summary.
Thus, recoreving the state as in the previous simulation.
</pre>

				
				
				
			
				
				<h3 id="Domain.ReadIvs">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=3268:3348#L128">ReadIvs</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) ReadIvs(dir, fnkey, enctype <a href="/pkg/builtin/#string">string</a>, tidx, proc <a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadIvs reads elements&#39;s internal values from a file which name is set with tidx (time output index)
</p>

				
				
				
			
				
				<h3 id="Domain.ReadSol">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=1836:1910#L71">ReadSol</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) ReadSol(dir, fnkey, enctype <a href="/pkg/builtin/#string">string</a>, tidx <a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadSol reads Solution from a file which name is set with tidx (time output index)
</p>

				
				
				
			
				
				<h3 id="Domain.Save">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=4042:4099#L162">Save</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) Save(tidx <a href="/pkg/builtin/#int">int</a>, verbose <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Out performs output of Solution and Internal values to files
</p>

				
				
				
			
				
				<h3 id="Domain.SaveIvs">func (Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=2718:2777#L105">SaveIvs</a></h3>
				<pre>func (o <a href="#Domain">Domain</a>) SaveIvs(tidx <a href="/pkg/builtin/#int">int</a>, verbose <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SaveIvs saves elements&#39;s internal values to a file which name is set with tidx (time output index)
</p>

				
				
				
			
				
				<h3 id="Domain.SaveSol">func (Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=981:1040#L36">SaveSol</a></h3>
				<pre>func (o <a href="#Domain">Domain</a>) SaveSol(tidx <a href="/pkg/builtin/#int">int</a>, verbose <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SaveSol saves solution (o.Sol) to a file which name is set with tidx (time output index)
</p>

				
				
				
			
				
				<h3 id="Domain.SetGeoSt">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/geost.go?s=3478:3531#L105">SetGeoSt</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) SetGeoSt(stg *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Stage">Stage</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetGeoSt sets the initial state to a hydrostatic condition
</p>

				
				
				
			
				
				<h3 id="Domain.SetHydroSt">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/hydrost.go?s=2304:2359#L80">SetHydroSt</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) SetHydroSt(stg *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Stage">Stage</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetHydroSt sets the initial state to a hydrostatic condition
</p>

				
				
				
			
				
				<h3 id="Domain.SetIniStress">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/inistress.go?s=354:411#L4">SetIniStress</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) SetIniStress(stg *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Stage">Stage</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetIniStress sets the initial state with initial stresses
</p>

				
				
				
			
				
				<h3 id="Domain.SetIniVals">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/domain.go?s=11851:11916#L385">SetIniVals</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) SetIniVals(stgidx <a href="/pkg/builtin/#int">int</a>, zeroSol <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetIniVals sets/resets initial values (nodes and integration points)
</p>

				
				
				
			
				
				<h3 id="Domain.SetInitial">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/initial.go?s=300:355#L3">SetInitial</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) SetInitial(stg *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Stage">Stage</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetInitial sets the initial state
</p>

				
				
				
			
				
				<h3 id="Domain.SetStage">func (*Domain) <a href="https://github.com/cpmech/gofem/blob/master/fem/domain.go?s=5024:5073#L122">SetStage</a></h3>
				<pre>func (o *<a href="#Domain">Domain</a>) SetStage(stgidx <a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetStage set nodes, equation numbers and auxiliary data for given stage
</p>

				
				
				
			
		
			
			
			<h2 id="DynCoefs">type <a href="https://github.com/cpmech/gofem/blob/master/fem/dyncoefs.go?s=677:880#L11">DynCoefs</a></h2>
			<pre>type DynCoefs struct {
    HHT <a href="/pkg/builtin/#bool">bool</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
DynCoefs calculates θ-method, Newmark&#39;s or HHT coefficients.
</p>
<pre>Notes:
 θ1  -- Newmark parameter (gamma)  [0 &lt;= θ1 &lt;= 1]
 θ2  -- Newmark parameter (2*beta) [0 &lt;= θ2 &lt;= 1]
 HHT -- use Hilber-Hughes-Taylor method ?
 α   -- Hilber-Hughes-Taylor parameter [-1/3 &lt;= α &lt;= 0]
 if HHT==True, θ1 and θ2 are automatically calculated for unconditional stability
</pre>


			

			

			
			
			

			

			
				
				<h3 id="DynCoefs.CalcAlphas">func (*DynCoefs) <a href="https://github.com/cpmech/gofem/blob/master/fem/dyncoefs.go?s=2261:2315#L87">CalcAlphas</a></h3>
				<pre>func (o *<a href="#DynCoefs">DynCoefs</a>) CalcAlphas(Δt <a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
CalcAlphas computes only alphas
</p>

				
				
				
			
				
				<h3 id="DynCoefs.CalcBetas">func (*DynCoefs) <a href="https://github.com/cpmech/gofem/blob/master/fem/dyncoefs.go?s=1959:2012#L72">CalcBetas</a></h3>
				<pre>func (o *<a href="#DynCoefs">DynCoefs</a>) CalcBetas(Δt <a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
CalcBetas computes only betas
</p>

				
				
				
			
				
				<h3 id="DynCoefs.CalcBoth">func (*DynCoefs) <a href="https://github.com/cpmech/gofem/blob/master/fem/dyncoefs.go?s=1782:1834#L62">CalcBoth</a></h3>
				<pre>func (o *<a href="#DynCoefs">DynCoefs</a>) CalcBoth(Δt <a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
CalcBoth computes betas and alphas
</p>

				
				
				
			
				
				<h3 id="DynCoefs.Init">func (*DynCoefs) <a href="https://github.com/cpmech/gofem/blob/master/fem/dyncoefs.go?s=917:961#L26">Init</a></h3>
				<pre>func (o *<a href="#DynCoefs">DynCoefs</a>) Init(dat *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#SolverData">SolverData</a>)</pre>
				<p>
Init initialises this structure
</p>

				
				
				
			
				
				<h3 id="DynCoefs.Print">func (*DynCoefs) <a href="https://github.com/cpmech/gofem/blob/master/fem/dyncoefs.go?s=2781:2807#L110">Print</a></h3>
				<pre>func (o *<a href="#DynCoefs">DynCoefs</a>) Print()</pre>
				<p>
Print prints coefficients
</p>

				
				
				
			
		
			
			
			<h2 id="ElasticRod">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=521:1471#L9">ElasticRod</a></h2>
			<pre>type ElasticRod struct {

    <span class="comment">// basic data</span>
    Cell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>   <span class="comment">// the cell structure</span>
    X    [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// matrix of nodal coordinates [ndim][nnode]</span>
    Nu   <a href="/pkg/builtin/#int">int</a>         <span class="comment">// total number of unknowns == 2 * nsn</span>
    Ndim <a href="/pkg/builtin/#int">int</a>         <span class="comment">// space dimension</span>

    <span class="comment">// parameters and properties</span>
    E <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// Young&#39;s modulus</span>
    A <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// cross-sectional area</span>
    L <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// length of rod</span>

    <span class="comment">// variables for dynamics</span>
    Rho  <a href="/pkg/builtin/#float64">float64</a>  <span class="comment">// density of solids</span>
    Gfcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// gravity function</span>

    <span class="comment">// vectors and matrices</span>
    T [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [ndim][nu] transformation matrix: system aligned to rod =&gt; element system</span>
    K [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nu][nu] element K matrix</span>
    M [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nu][nu] element M matrix</span>

    <span class="comment">// problem variables</span>
    Umap []<a href="/pkg/builtin/#int">int</a> <span class="comment">// assembly map (location array/element equations)</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
ElasticRod represents a structural rod element (for axial loads only) with 2 nodes only and
simply implemented with constant stiffness matrix; i.e. no numerical integration is needed
</p>


			

			

			
			
			

			

			
				
				<h3 id="ElasticRod.AddToKb">func (ElasticRod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=5212:5296#L207">AddToKb</a></h3>
				<pre>func (o <a href="#ElasticRod">ElasticRod</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AddToKb adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="ElasticRod.AddToRhs">func (ElasticRod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=4722:4791#L184">AddToRhs</a></h3>
				<pre>func (o <a href="#ElasticRod">ElasticRod</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AddToRhs adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="ElasticRod.Decode">func (ElasticRod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=5746:5797#L229">Decode</a></h3>
				<pre>func (o <a href="#ElasticRod">ElasticRod</a>) Decode(dec <a href="#Decoder">Decoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElasticRod.Encode">func (ElasticRod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=5644:5695#L224">Encode</a></h3>
				<pre>func (o <a href="#ElasticRod">ElasticRod</a>) Encode(enc <a href="#Encoder">Encoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElasticRod.Id">func (ElasticRod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=3938:3966#L153">Id</a></h3>
				<pre>func (o <a href="#ElasticRod">ElasticRod</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="ElasticRod.InterpStarVars">func (*ElasticRod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=4307:4369#L168">InterpStarVars</a></h3>
				<pre>func (o *<a href="#ElasticRod">ElasticRod</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
InterpStarVars interpolates star variables to integration points
</p>

				
				
				
			
				
				<h3 id="ElasticRod.OutIpsData">func (ElasticRod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=5877:5929#L234">OutIpsData</a></h3>
				<pre>func (o <a href="#ElasticRod">ElasticRod</a>) OutIpsData() (data []*<a href="#OutIpData">OutIpData</a>)</pre>
				<p>
OutIpsData returns data from all integration points for output
</p>

				
				
				
			
				
				<h3 id="ElasticRod.SetEleConds">func (*ElasticRod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=4492:4574#L175">SetEleConds</a></h3>
				<pre>func (o *<a href="#ElasticRod">ElasticRod</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEleConds set element conditions
</p>

				
				
				
			
				
				<h3 id="ElasticRod.SetEqs">func (*ElasticRod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=4013:4086#L156">SetEqs</a></h3>
				<pre>func (o *<a href="#ElasticRod">ElasticRod</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEqs set equations
</p>

				
				
				
			
				
				<h3 id="ElasticRod.Update">func (*ElasticRod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_elastrod.go?s=5436:5490#L217">Update</a></h3>
				<pre>func (o *<a href="#ElasticRod">ElasticRod</a>) Update(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Update perform (tangent) update
</p>

				
				
				
			
		
			
			
			<h2 id="Elem">type <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=735:1813#L13">Elem</a></h2>
			<pre>type Elem interface {

    <span class="comment">// information and initialisation</span>
    Id() <a href="/pkg/builtin/#int">int</a>                                             <span class="comment">// returns the cell Id</span>
    SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>) <span class="comment">// set equations</span>

    <span class="comment">// conditions (natural BCs and element&#39;s)</span>
    SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>) <span class="comment">// set element conditions</span>

    <span class="comment">// called for each time step</span>
    InterpStarVars(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>) <span class="comment">// interpolate star variables to integration points</span>

    <span class="comment">// called for each iteration</span>
    AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)                <span class="comment">// adds -R to global residual vector fb</span>
    AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>) <span class="comment">// adds element K to global Jacobian matrix Kb</span>
    Update(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)                                <span class="comment">// perform (tangent) update</span>

    <span class="comment">// reading and writing of element data</span>
    Encode(enc <a href="#Encoder">Encoder</a>) (err <a href="/pkg/builtin/#error">error</a>) <span class="comment">// encodes internal variables</span>
    Decode(dec <a href="#Decoder">Decoder</a>) (err <a href="/pkg/builtin/#error">error</a>) <span class="comment">// decodes internal variables</span>

    <span class="comment">// output</span>
    OutIpsData() (data []*<a href="#OutIpData">OutIpData</a>) <span class="comment">// returns data from all integration points for output</span>
}</pre>
			<p>
Elem defines what elements must calculate
</p>


			

			

			
			
			

			
				
				<h3 id="NewElem">func <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=4153:4241#L91">NewElem</a></h3>
				<pre>func NewElem(cell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>, reg *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Region">Region</a>, sim *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Simulation">Simulation</a>) (ele <a href="#Elem">Elem</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
NewElem returns a new element from its type; e.g. &#34;p&#34;, &#34;u&#34; or &#34;up&#34;
</p>

				
				
			

			
		
			
			
			<h2 id="ElemConnector">type <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=1893:2144#L39">ElemConnector</a></h2>
			<pre>type ElemConnector interface {
    Id() <a href="/pkg/builtin/#int">int</a>                                                    <span class="comment">// returns the cell Id</span>
    Connect(cid2elem []<a href="#Elem">Elem</a>, c *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>) (nnzK <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>) <span class="comment">// connect multiple elements; e.g.: connect rod/solid elements in Rjoints</span>
}</pre>
			<p>
ElemConnector defines connector elements; elements that depend upon others
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="ElemIntvars">type <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=2208:2828#L45">ElemIntvars</a></h2>
			<pre>type ElemIntvars interface {
    Ipoints() (coords [][]<a href="/pkg/builtin/#float64">float64</a>)                                 <span class="comment">// returns the real coordinates of integration points [nip][ndim]</span>
    SetIniIvs(sol *<a href="#Solution">Solution</a>, ivs map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>) <span class="comment">// sets initial ivs for given values in sol and ivs map</span>
    BackupIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)                                <span class="comment">// create copy of internal variables</span>
    RestoreIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)                               <span class="comment">// restore internal variables from copies</span>
    Ureset(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)                              <span class="comment">// fixes internal variables after u (displacements) have been zeroed</span>
}</pre>
			<p>
ElemIntvars defines elements with {z,q} internal variables
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="ElemP">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=757:3430#L16">ElemP</a></h2>
			<pre>type ElemP struct {

    <span class="comment">// basic data</span>
    Cell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>   <span class="comment">// the cell structure</span>
    X    [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// matrix of nodal coordinates [ndim][nnode]</span>
    Shp  *<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Shape">Shape</a>  <span class="comment">// shape structure</span>
    Np   <a href="/pkg/builtin/#int">int</a>         <span class="comment">// total number of unknowns == number of vertices</span>
    Ndim <a href="/pkg/builtin/#int">int</a>         <span class="comment">// space dimension</span>

    <span class="comment">// integration points</span>
    IpsElem []*<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Ipoint">Ipoint</a> <span class="comment">// integration points of element</span>
    IpsFace []*<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Ipoint">Ipoint</a> <span class="comment">// integration points corresponding to faces</span>

    <span class="comment">// material model</span>
    Mdl *<a href="/pkg/github.com/cpmech/gofem/mporous/">mporous</a>.<a href="/pkg/github.com/cpmech/gofem/mporous/#Model">Model</a> <span class="comment">// model</span>

    <span class="comment">// problem variables</span>
    Pmap []<a href="/pkg/builtin/#int">int</a> <span class="comment">// assembly map (location array/element equations)</span>

    <span class="comment">// internal variables</span>
    States    []*<a href="/pkg/github.com/cpmech/gofem/mporous/">mporous</a>.<a href="/pkg/github.com/cpmech/gofem/mporous/#State">State</a>
    StatesBkp []*<a href="/pkg/github.com/cpmech/gofem/mporous/">mporous</a>.<a href="/pkg/github.com/cpmech/gofem/mporous/#State">State</a>
    StatesAux []*<a href="/pkg/github.com/cpmech/gofem/mporous/">mporous</a>.<a href="/pkg/github.com/cpmech/gofem/mporous/#State">State</a>

    <span class="comment">// gravity</span>
    Gfcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// gravity function</span>

    <span class="comment">// natural boundary conditions</span>
    NatBcs []*<a href="#NaturalBc">NaturalBc</a> <span class="comment">// natural boundary conditions</span>

    Emat     [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nverts][nips] extrapolator matrix</span>
    DoExtrap <a href="/pkg/builtin/#bool">bool</a>        <span class="comment">// do extrapolation of ρl and Cpl =&gt; for use with flux and seepage conditions</span>

    <span class="comment">// seepage face</span>
    Nf         <a href="/pkg/builtin/#int">int</a>   <span class="comment">// number of fl variables</span>
    HasSeep    <a href="/pkg/builtin/#bool">bool</a>  <span class="comment">// indicates if this element has seepage faces</span>
    Vid2seepId []<a href="/pkg/builtin/#int">int</a> <span class="comment">// [nverts] maps local vertex id to index in Fmap</span>
    SeepId2vid []<a href="/pkg/builtin/#int">int</a> <span class="comment">// [nf] maps seepage face variable id to local vertex id</span>
    Fmap       []<a href="/pkg/builtin/#int">int</a> <span class="comment">// [nf] map of &#34;fl&#34; variables (seepage face)</span>
    Macaulay   <a href="/pkg/builtin/#bool">bool</a>  <span class="comment">// use discrete ramp function instead of smooth ramp</span>

    Hst   []<a href="/pkg/builtin/#bool">bool</a>      <span class="comment">// [nf] set hydrostatic plmax</span>
    Plmax [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nf][nipsFace] specified plmax (not corrected by multiplier)</span>

    Kpp [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [np][np] Kpp := dRpl/dpl consistent tangent matrix</span>
    Kpf [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [np][nf] Kpf := dRpl/dfl consistent tangent matrix</span>
    Kfp [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nf][np] Kfp := dRfl/dpl consistent tangent matrix</span>
    Kff [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nf][nf] Kff := dRfl/dfl consistent tangent matrix</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
ElemP implements an element for transient seepage analyses [1]
</p>
<pre>References:
 [1] Pedroso DM (2015) A solution to transient seepage in unsaturated porous media.
     Computer Methods in Applied Mechanics and Engineering, 285 791-816,
     <a href="http://dx.doi.org/10.1016/j.cma.2014.12.009">http://dx.doi.org/10.1016/j.cma.2014.12.009</a>
</pre>


			

			

			
			
			

			

			
				
				<h3 id="ElemP.AddToKb">func (ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=9796:9875#L336">AddToKb</a></h3>
				<pre>func (o <a href="#ElemP">ElemP</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AddToKb adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="ElemP.AddToRhs">func (ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=8360:8424#L274">AddToRhs</a></h3>
				<pre>func (o <a href="#ElemP">ElemP</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AddToRhs adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="ElemP.BackupIvs">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=14819:14866#L559">BackupIvs</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) BackupIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
BackupIvs creates copy of internal variables
</p>

				
				
				
			
				
				<h3 id="ElemP.Decode">func (ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=15671:15717#L599">Decode</a></h3>
				<pre>func (o <a href="#ElemP">ElemP</a>) Decode(dec <a href="#Decoder">Decoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemP.Encode">func (ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=15553:15599#L594">Encode</a></h3>
				<pre>func (o <a href="#ElemP">ElemP</a>) Encode(enc <a href="#Encoder">Encoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemP.Id">func (ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=7343:7366#L228">Id</a></h3>
				<pre>func (o <a href="#ElemP">ElemP</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="ElemP.InterpStarVars">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=7913:7970#L253">InterpStarVars</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
InterpStarVars interpolates star variables to integration points
</p>

				
				
				
			
				
				<h3 id="ElemP.Ipoints">func (ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=12805:12850#L470">Ipoints</a></h3>
				<pre>func (o <a href="#ElemP">ElemP</a>) Ipoints() (coords [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Ipoints returns the real coordinates of integration points [nip][ndim]
</p>

				
				
				
			
				
				<h3 id="ElemP.OutIpsData">func (ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=15874:15921#L608">OutIpsData</a></h3>
				<pre>func (o <a href="#ElemP">ElemP</a>) OutIpsData() (data []*<a href="#OutIpData">OutIpData</a>)</pre>
				<p>
OutIpsData returns data from all integration points for output
</p>

				
				
				
			
				
				<h3 id="ElemP.RestoreIvs">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=15073:15121#L573">RestoreIvs</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) RestoreIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
RestoreIvs restores internal variables from copies
</p>

				
				
				
			
				
				<h3 id="ElemP.SetEleConds">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=7710:7787#L245">SetEleConds</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEleConds sets element conditions
</p>

				
				
				
			
				
				<h3 id="ElemP.SetEqs">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=7414:7482#L231">SetEqs</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEqs sets equations
</p>

				
				
				
			
				
				<h3 id="ElemP.SetIniIvs">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=13057:13139#L479">SetIniIvs</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) SetIniIvs(sol *<a href="#Solution">Solution</a>, ignored map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetIniIvs sets initial ivs for given values in sol and ivs map
</p>

				
				
				
			
				
				<h3 id="ElemP.Update">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=12044:12093#L438">Update</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) Update(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Update performs (tangent) update
</p>

				
				
				
			
				
				<h3 id="ElemP.Ureset">func (*ElemP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_p.go?s=15350:15399#L587">Ureset</a></h3>
				<pre>func (o *<a href="#ElemP">ElemP</a>) Ureset(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Ureset fixes internal variables after u (displacements) have been zeroed
</p>

				
				
				
			
		
			
			
			<h2 id="ElemPhi">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=529:1152#L10">ElemPhi</a></h2>
			<pre>type ElemPhi struct {

    <span class="comment">// basic data</span>
    Cell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>   <span class="comment">// the cell structure</span>
    X    [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [ndim][nnode] matrix of nodal coordinates</span>
    Shp  *<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Shape">Shape</a>  <span class="comment">// shape structure</span>
    Nu   <a href="/pkg/builtin/#int">int</a>         <span class="comment">// total number of unknowns == number of vertices</span>
    Ndim <a href="/pkg/builtin/#int">int</a>         <span class="comment">// space dimension</span>

    <span class="comment">// integration points</span>
    IpsElem []*<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Ipoint">Ipoint</a> <span class="comment">// [nip] integration points of element</span>

    <span class="comment">// scratchpad. computed @ each ip</span>
    K [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nu][nu] consistent tangent matrix</span>

    <span class="comment">// problem variables</span>
    Umap []<a href="/pkg/builtin/#int">int</a> <span class="comment">// assembly map (location array/element equations)</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
ElemPhi implementes a general element to solve the following equation
</p>
<pre>dφ       ∂φ
-- + v . -- = s(x)
dt       ∂x
</pre>
<p>
Notes: v is a constant vector
</p>


			

			

			
			
			

			

			
				
				<h3 id="ElemPhi.AddToKb">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=4269:4351#L165">AddToKb</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AddToKb adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="ElemPhi.AddToRhs">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=3445:3512#L128">AddToRhs</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AddToRhs adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="ElemPhi.Decode">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=5327:5376#L217">Decode</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) Decode(dec <a href="#Decoder">Decoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemPhi.Encode">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=5227:5276#L212">Encode</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) Encode(enc <a href="#Encoder">Encoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemPhi.Id">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=2565:2591#L90">Id</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="ElemPhi.InterpStarVars">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=3004:3063#L107">InterpStarVars</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
InterpStarVars interpolate star variables to integration points
</p>

				
				
				
			
				
				<h3 id="ElemPhi.OutIpsData">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=5456:5506#L222">OutIpsData</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) OutIpsData() (data []*<a href="#OutIpData">OutIpData</a>)</pre>
				<p>
OutIpsData returns data from all integration points for output
</p>

				
				
				
			
				
				<h3 id="ElemPhi.SetEleConds">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=2844:2923#L102">SetEleConds</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEleConds set element conditions
</p>

				
				
				
			
				
				<h3 id="ElemPhi.SetEqs">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=2638:2708#L93">SetEqs</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEqs set equations
</p>

				
				
				
			
				
				<h3 id="ElemPhi.Update">func (*ElemPhi) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_phi.go?s=5022:5073#L205">Update</a></h3>
				<pre>func (o *<a href="#ElemPhi">ElemPhi</a>) Update(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Update perform (tangent) update
</p>

				
				
				
			
		
			
			
			<h2 id="ElemU">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=526:3506#L10">ElemU</a></h2>
			<pre>type ElemU struct {

    <span class="comment">// basic data</span>
    Cell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>   <span class="comment">// the cell structure</span>
    X    [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// matrix of nodal coordinates [ndim][nnode]</span>
    Shp  *<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Shape">Shape</a>  <span class="comment">// shape structure</span>
    Nu   <a href="/pkg/builtin/#int">int</a>         <span class="comment">// total number of unknowns</span>
    Ndim <a href="/pkg/builtin/#int">int</a>         <span class="comment">// space dimension</span>

    <span class="comment">// variables for dynamics</span>
    Rho  <a href="/pkg/builtin/#float64">float64</a>  <span class="comment">// density of solids</span>
    Cdam <a href="/pkg/builtin/#float64">float64</a>  <span class="comment">// coefficient for damping</span>
    Gfcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// gravity function</span>

    <span class="comment">// optional data</span>
    UseB      <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// use B matrix</span>
    Thickness <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// thickness (for plane-stress)</span>
    Debug     <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// debugging flag</span>

    <span class="comment">// integration points</span>
    IpsElem []*<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Ipoint">Ipoint</a> <span class="comment">// integration points of element</span>
    IpsFace []*<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Ipoint">Ipoint</a> <span class="comment">// integration points corresponding to faces</span>

    <span class="comment">// material model and internal variables</span>
    Model    <a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#Model">Model</a> <span class="comment">// material model</span>
    MdlSmall <a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#Small">Small</a> <span class="comment">// model specialisation for small strains</span>
    MdlLarge <a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#Large">Large</a> <span class="comment">// model specialisation for large deformations</span>

    <span class="comment">// internal variables</span>
    States    []*<a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#State">State</a> <span class="comment">// [nip] states</span>
    StatesBkp []*<a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#State">State</a> <span class="comment">// [nip] backup states</span>
    StatesAux []*<a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#State">State</a> <span class="comment">// [nip] auxiliary backup states</span>

    <span class="comment">// problem variables</span>
    Umap []<a href="/pkg/builtin/#int">int</a> <span class="comment">// assembly map (location array/element equations)</span>

    <span class="comment">// natural boundary conditions</span>
    NatBcs []*<a href="#NaturalBc">NaturalBc</a>

    K [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nu][nu] consistent tangent (stiffness) matrix</span>
    B [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nsig][nu] B matrix for axisymetric case</span>
    D [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nsig][nsig] constitutive consistent tangent matrix</span>

    Δε []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// incremental strains leading to updated strains</span>

    <span class="comment">// contact</span>
    Nq            <a href="/pkg/builtin/#int">int</a>   <span class="comment">// number of qb variables</span>
    HasContact    <a href="/pkg/builtin/#bool">bool</a>  <span class="comment">// indicates if this element has contact faces</span>
    Vid2contactId []<a href="/pkg/builtin/#int">int</a> <span class="comment">// [nverts] maps local vertex id to index in Qmap</span>
    ContactId2vid []<a href="/pkg/builtin/#int">int</a> <span class="comment">// [nq] maps contact face variable id to local vertex id</span>
    Qmap          []<a href="/pkg/builtin/#int">int</a> <span class="comment">// [nq] map of &#34;qb&#34; variables (contact face)</span>
    Macaulay      <a href="/pkg/builtin/#bool">bool</a>  <span class="comment">// contact: use discrete ramp function instead of smooth ramp</span>

    <span class="comment">// for contact</span>
    Kuq [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nu][nq] Kuq := dRu/dq consistent tangent matrix</span>
    Kqu [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nq][nu] Kqu := dRq/du consistent tangent matrix</span>
    Kqq [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nq][nq] Kqq := dRq/dq consistent tangent matrix</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
ElemU represents a solid element with displacements u as primary variables
</p>


			

			

			
			
			

			

			
				
				<h3 id="ElemU.AddToKb">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=10434:10514#L377">AddToKb</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AddToKb adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="ElemU.AddToRhs">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=8923:8988#L310">AddToRhs</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AddToRhs adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="ElemU.BackupIvs">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=14326:14373#L543">BackupIvs</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) BackupIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
BackupIvs create copy of internal variables
</p>

				
				
				
			
				
				<h3 id="ElemU.Decode">func (ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=15320:15366#L589">Decode</a></h3>
				<pre>func (o <a href="#ElemU">ElemU</a>) Decode(dec <a href="#Decoder">Decoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemU.Encode">func (ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=15202:15248#L584">Encode</a></h3>
				<pre>func (o <a href="#ElemU">ElemU</a>) Encode(enc <a href="#Encoder">Encoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemU.Id">func (ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=7639:7662#L254">Id</a></h3>
				<pre>func (o <a href="#ElemU">ElemU</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="ElemU.InterpStarVars">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=8276:8333#L282">InterpStarVars</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
InterpStarVars interpolates star variables to integration points
</p>

				
				
				
			
				
				<h3 id="ElemU.Ipoints">func (ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=13404:13449#L506">Ipoints</a></h3>
				<pre>func (o <a href="#ElemU">ElemU</a>) Ipoints() (coords [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Ipoints returns the real coordinates of integration points [nip][ndim]
</p>

				
				
				
			
				
				<h3 id="ElemU.OutIpsData">func (ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=15523:15570#L598">OutIpsData</a></h3>
				<pre>func (o <a href="#ElemU">ElemU</a>) OutIpsData() (data []*<a href="#OutIpData">OutIpData</a>)</pre>
				<p>
OutIpsData returns data from all integration points for output
</p>

				
				
				
			
				
				<h3 id="ElemU.RestoreIvs">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=14579:14627#L557">RestoreIvs</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) RestoreIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
RestoreIvs restore internal variables from copies
</p>

				
				
				
			
				
				<h3 id="ElemU.SetEleConds">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=8073:8150#L274">SetEleConds</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEleConds set element conditions
</p>

				
				
				
			
				
				<h3 id="ElemU.SetEqs">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=7709:7777#L257">SetEqs</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEqs set equations
</p>

				
				
				
			
				
				<h3 id="ElemU.SetIniIvs">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=13656:13734#L515">SetIniIvs</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) SetIniIvs(sol *<a href="#Solution">Solution</a>, ivs map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetIniIvs sets initial ivs for given values in sol and ivs map
</p>

				
				
				
			
				
				<h3 id="ElemU.Update">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=12350:12399#L468">Update</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) Update(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Update perform (tangent) update
</p>

				
				
				
			
				
				<h3 id="ElemU.Ureset">func (*ElemU) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_u.go?s=14856:14905#L571">Ureset</a></h3>
				<pre>func (o *<a href="#ElemU">ElemU</a>) Ureset(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Ureset fixes internal variables after u (displacements) have been zeroed
</p>

				
				
				
			
		
			
			
			<h2 id="ElemUP">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=907:1747#L15">ElemUP</a></h2>
			<pre>type ElemUP struct {

    <span class="comment">// auxiliary</span>
    Sim  *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Simulation">Simulation</a> <span class="comment">// simulation</span>
    Cell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>       <span class="comment">// cell</span>
    Edat *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#ElemData">ElemData</a>   <span class="comment">// element data; stored in allocator to be used in Connect</span>
    Ndim <a href="/pkg/builtin/#int">int</a>             <span class="comment">// space dimension</span>

    <span class="comment">// underlying elements</span>
    U *<a href="#ElemU">ElemU</a> <span class="comment">// u-element</span>
    P *<a href="#ElemP">ElemP</a> <span class="comment">// p-element</span>

    Kup [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nu][np] Kup := dRus/dpl consistent tangent matrix</span>
    Kpu [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [np][nu] Kpu := dRpl/dus consistent tangent matrix</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
ElemUP represents an element for porous media based on the u-p formulation [1]
</p>
<pre>References:
 [1] Pedroso DM. A consistent u-p formulation for porous media with hysteresis.
     Int Journal for Numerical Methods in Engineering, 101(8):606-634; 2015
     <a href="http://dx.doi.org/10.1002/nme.4808">http://dx.doi.org/10.1002/nme.4808</a>
 [2] Pedroso DM. A solution to transient seepage in unsaturated porous media.
     Computer Methods in Applied Mechanics and Engineering, 285:791-816; 2015
     <a href="http://dx.doi.org/10.1016/j.cma.2014.12.009">http://dx.doi.org/10.1016/j.cma.2014.12.009</a>
</pre>


			

			

			
			
			

			

			
				
				<h3 id="ElemUP.AddToKb">func (ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=9372:9452#L358">AddToKb</a></h3>
				<pre>func (o <a href="#ElemUP">ElemUP</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="ElemUP.AddToRhs">func (ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=6474:6539#L236">AddToRhs</a></h3>
				<pre>func (o <a href="#ElemUP">ElemUP</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="ElemUP.BackupIvs">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=16157:16205#L636">BackupIvs</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) BackupIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
BackupIvs create copy of internal variables
</p>

				
				
				
			
				
				<h3 id="ElemUP.Decode">func (ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=17428:17475#L691">Decode</a></h3>
				<pre>func (o <a href="#ElemUP">ElemUP</a>) Decode(dec <a href="#Decoder">Decoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemUP.Encode">func (ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=17262:17309#L682">Encode</a></h3>
				<pre>func (o <a href="#ElemUP">ElemUP</a>) Encode(enc <a href="#Encoder">Encoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="ElemUP.Id">func (ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=4162:4186#L136">Id</a></h3>
				<pre>func (o <a href="#ElemUP">ElemUP</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="ElemUP.InterpStarVars">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=5472:5530#L189">InterpStarVars</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
InterpStarVars interpolates star variables to integration points
</p>

				
				
				
			
				
				<h3 id="ElemUP.Ipoints">func (ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=14755:14801#L575">Ipoints</a></h3>
				<pre>func (o <a href="#ElemUP">ElemUP</a>) Ipoints() (coords [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Ipoints returns the real coordinates of integration points [nip][ndim]
</p>

				
				
				
			
				
				<h3 id="ElemUP.OutIpsData">func (ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=17623:17671#L700">OutIpsData</a></h3>
				<pre>func (o <a href="#ElemUP">ElemUP</a>) OutIpsData() (data []*<a href="#OutIpData">OutIpData</a>)</pre>
				<p>
OutIpsData returns data from all integration points for output
</p>

				
				
				
			
				
				<h3 id="ElemUP.RestoreIvs">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=16346:16395#L645">RestoreIvs</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) RestoreIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
RestoreIvs restore internal variables from copies
</p>

				
				
				
			
				
				<h3 id="ElemUP.SetEleConds">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=5214:5292#L180">SetEleConds</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEleConds set element conditions
</p>

				
				
				
			
				
				<h3 id="ElemUP.SetEqs">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=4233:4302#L139">SetEqs</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEqs set equations
</p>

				
				
				
			
				
				<h3 id="ElemUP.SetIniIvs">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=15016:15095#L584">SetIniIvs</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) SetIniIvs(sol *<a href="#Solution">Solution</a>, ivs map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetIniIvs sets initial ivs for given values in sol and ivs map
</p>

				
				
				
			
				
				<h3 id="ElemUP.Update">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=14446:14496#L564">Update</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) Update(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Update perform (tangent) update
</p>

				
				
				
			
				
				<h3 id="ElemUP.Ureset">func (*ElemUP) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_up.go?s=16561:16611#L654">Ureset</a></h3>
				<pre>func (o *<a href="#ElemUP">ElemUP</a>) Ureset(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Ureset fixes internal variables after u (displacements) have been zeroed
</p>

				
				
				
			
		
			
			
			<h2 id="Encoder">type <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=375:430#L10">Encoder</a></h2>
			<pre>type Encoder interface {
    Encode(e interface{}) <a href="/pkg/builtin/#error">error</a>
}</pre>
			<p>
Encoder defines encoders; e.g. gob or json
</p>


			

			

			
			
			

			
				
				<h3 id="GetEncoder">func <a href="https://github.com/cpmech/gofem/blob/master/fem/fileio.go?s=571:625#L20">GetEncoder</a></h3>
				<pre>func GetEncoder(w <a href="/pkg/io/">goio</a>.<a href="/pkg/io/#Writer">Writer</a>, enctype <a href="/pkg/builtin/#string">string</a>) <a href="#Encoder">Encoder</a></pre>
				<p>
GetEncoder returns a new encoder
</p>

				
				
			

			
		
			
			
			<h2 id="EssentialBc">type <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=901:1135#L22">EssentialBc</a></h2>
			<pre>type EssentialBc struct {
    Key   <a href="/pkg/builtin/#string">string</a>    <span class="comment">// ux, uy, rigid, incsup</span>
    Eqs   []<a href="/pkg/builtin/#int">int</a>     <span class="comment">// equations</span>
    ValsA []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// values for matrix A</span>
    Fcn   <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>  <span class="comment">// function that implements the &#34;c&#34; in A * y = c</span>
    Inact <a href="/pkg/builtin/#bool">bool</a>      <span class="comment">// inactive</span>
}</pre>
			<p>
EssentialBc holds information about essential bounday conditions such as constrained nodes.
Lagrange multipliers are used to implement both single- and multi-point constraints.
</p>
<pre>In general, essential bcs / constraints are defined by means of:

    A * y = c

The resulting Kb matrix will then have the following form:
    _       _
   |  K  At  | / δy \   / -R - At*λ \
   |         | |    | = |           |
   |_ A   0 _| \ δλ /   \  c - A*y  /
       Kb       δyb          fb
</pre>


			

			

			
			
			

			

			
		
			
			
			<h2 id="EssentialBcs">type <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=1298:1757#L32">EssentialBcs</a></h2>
			<pre>type EssentialBcs struct {
    HydFcn *<a href="#HydroStatic">HydroStatic</a>   <span class="comment">// for computing hydrostatic conditions</span>
    Eq2idx map[<a href="/pkg/builtin/#int">int</a>][]<a href="/pkg/builtin/#int">int</a>  <span class="comment">// maps eq number to indices in BcsTmp</span>
    Bcs    []*<a href="#EssentialBc">EssentialBc</a> <span class="comment">// active essential bcs / constraints</span>
    A      <a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>     <span class="comment">// matrix of coefficients &#39;A&#39;</span>
    Am     *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#CCMatrix">CCMatrix</a>   <span class="comment">// compressed form of A matrix</span>

    <span class="comment">// temporary</span>
    BcsTmp eqbcpairs <span class="comment">// temporary essential bcs / constraints, including inactive ones. maps the first equation number to bcs</span>
}</pre>
			<p>
EssentialBcs implements a structure to record the definition of essential bcs / constraints.
Each constraint will have a unique Lagrange multiplier index.
</p>


			

			

			
			
			

			

			
				
				<h3 id="EssentialBcs.AddToRhs">func (EssentialBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=2963:3022#L90">AddToRhs</a></h3>
				<pre>func (o <a href="#EssentialBcs">EssentialBcs</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>)</pre>
				<p>
AddtoRhs adds the essential bcs / constraints terms to the augmented fb vector
</p>

				
				
				
			
				
				<h3 id="EssentialBcs.Build">func (*EssentialBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=2210:2262#L54">Build</a></h3>
				<pre>func (o *<a href="#EssentialBcs">EssentialBcs</a>) Build(ny <a href="/pkg/builtin/#int">int</a>) (nλ, nnzA <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Build builds this structure and its iternal data
</p>
<pre>nλ -- is the number of essential bcs / constraints == number of Lagrange multipliers
nnzA -- is the number of non-zeros in matrix &#39;A&#39;
</pre>

				
				
				
			
				
				<h3 id="EssentialBcs.Init">func (*EssentialBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=1845:1893#L44">Init</a></h3>
				<pre>func (o *<a href="#EssentialBcs">EssentialBcs</a>) Init(hydfcn *<a href="#HydroStatic">HydroStatic</a>)</pre>
				<p>
Reset initialises this structure. It also performs a reset of internal structures.
</p>

				
				
				
			
				
				<h3 id="EssentialBcs.List">func (*EssentialBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=7268:7317#L260">List</a></h3>
				<pre>func (o *<a href="#EssentialBcs">EssentialBcs</a>) List(t <a href="/pkg/builtin/#float64">float64</a>) (l <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
List returns a simple list logging bcs at time t
</p>

				
				
				
			
				
				<h3 id="EssentialBcs.Set">func (*EssentialBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/essenbcs.go?s=4710:4803#L142">Set</a></h3>
				<pre>func (o *<a href="#EssentialBcs">EssentialBcs</a>) Set(key <a href="/pkg/builtin/#string">string</a>, nodes []*<a href="#Node">Node</a>, fcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Set sets a constraint if it does NOT exist yet.
</p>
<pre>key   -- can be Dof key such as &#34;ux&#34;, &#34;uy&#34; or constraint type such as &#34;mpc&#34; or &#34;rigid&#34;
extra -- is a keycode-style data. e.g. &#34;!type:incsup2d !alp:30&#34;
Notes: 1) the default for key is single point constraint; e.g. &#34;ux&#34;, &#34;uy&#34;, ...
       2) hydraulic head can be set with key == &#34;H&#34;
</pre>

				
				
				
			
		
			
			
			<h2 id="FEM">type <a href="https://github.com/cpmech/gofem/blob/master/fem/fem.go?s=940:1522#L21">FEM</a></h2>
			<pre>type FEM struct {
    Sim     *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Simulation">Simulation</a> <span class="comment">// simulation data</span>
    Summary *<a href="#Summary">Summary</a>        <span class="comment">// summary structure</span>
    DynCfs  *<a href="#DynCoefs">DynCoefs</a>       <span class="comment">// coefficients for dynamics/transient simulations</span>
    HydSta  *<a href="#HydroStatic">HydroStatic</a>    <span class="comment">// function to compute hydrostatic state</span>
    Domains []*<a href="#Domain">Domain</a>       <span class="comment">// all domains</span>
    Solver  <a href="#FEsolver">FEsolver</a>        <span class="comment">// finite element method solver; e.g. implicit, Richardson extrapolation, etc.</span>
    DebugKb <a href="#DebugKb_t">DebugKb_t</a>       <span class="comment">// debug Kb callback function</span>
    Nproc   <a href="/pkg/builtin/#int">int</a>             <span class="comment">// number of processors</span>
    Proc    <a href="/pkg/builtin/#int">int</a>             <span class="comment">// processor id</span>
    Verbose <a href="/pkg/builtin/#bool">bool</a>            <span class="comment">// show messages</span>
}</pre>
			<p>
FEM holds all data for a simulation using the finite element method
</p>


			

			

			
			
			

			
				
				<h3 id="NewFEM">func <a href="https://github.com/cpmech/gofem/blob/master/fem/fem.go?s=2038:2168#L43">NewFEM</a></h3>
				<pre>func NewFEM(simfilepath, alias <a href="/pkg/builtin/#string">string</a>, erasePrev, saveSummary, readSummary, allowParallel, verbose <a href="/pkg/builtin/#bool">bool</a>, goroutineId <a href="/pkg/builtin/#int">int</a>) (o *<a href="#FEM">FEM</a>)</pre>
				<p>
NewFEM returns a new FEM structure
</p>
<pre>Input:
 simfilepath   -- simulation (.sim) filename including full path
 alias         -- word to be appended to simulation key; e.g. when running multiple FE solutions
 erasePrev     -- erase previous results files
 saveSummary   -- save summary
 readSummary   -- ready summary of previous simulation
 allowParallel -- allow parallel execution; otherwise, run in serial mode regardless whether MPI is on or not
 verbose       -- show messages
</pre>

				
				
			

			
				
				<h3 id="FEM.Run">func (*FEM) <a href="https://github.com/cpmech/gofem/blob/master/fem/fem.go?s=3470:3501#L101">Run</a></h3>
				<pre>func (o *<a href="#FEM">FEM</a>) Run() (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Run runs FE simulation
</p>

				
				
				
			
				
				<h3 id="FEM.SetStage">func (*FEM) <a href="https://github.com/cpmech/gofem/blob/master/fem/fem.go?s=4343:4389#L150">SetStage</a></h3>
				<pre>func (o *<a href="#FEM">FEM</a>) SetStage(stgidx <a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetStage sets stage for all domains
</p>
<pre>Input:
 stgidx -- stage index (in o.Sim.Stages)
</pre>

				
				
				
			
				
				<h3 id="FEM.SolveOneStage">func (*FEM) <a href="https://github.com/cpmech/gofem/blob/master/fem/fem.go?s=5132:5199#L179">SolveOneStage</a></h3>
				<pre>func (o *<a href="#FEM">FEM</a>) SolveOneStage(stgidx <a href="/pkg/builtin/#int">int</a>, zerostage <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SolveOneStage solves one stage that was already set
</p>
<pre>Input:
 stgidx    -- stage index (in o.Sim.Stages)
 zerostage -- zero vectors in domains.Sol =&gt; call ZeroStage
</pre>

				
				
				
			
				
				<h3 id="FEM.ZeroStage">func (*FEM) <a href="https://github.com/cpmech/gofem/blob/master/fem/fem.go?s=4775:4836#L165">ZeroStage</a></h3>
				<pre>func (o *<a href="#FEM">FEM</a>) ZeroStage(stgidx <a href="/pkg/builtin/#int">int</a>, zeroSol <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ZeroStage zeroes solution varaibles; i.e. it initialises solution vectors (Y, dYdt, internal
values such as States.Sig, etc.) in all domains for all nodes and all elements
</p>
<pre>Input:
 stgidx  -- stage index (in o.Sim.Stages)
 zeroSol -- zero vectors in domains.Sol
</pre>

				
				
				
			
		
			
			
			<h2 id="FEsolver">type <a href="https://github.com/cpmech/gofem/blob/master/fem/fem.go?s=607:720#L13">FEsolver</a></h2>
			<pre>type FEsolver interface {
    Run(tf <a href="/pkg/builtin/#float64">float64</a>, dtFunc, dtoFunc <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, verbose <a href="/pkg/builtin/#bool">bool</a>, dbgKb <a href="#DebugKb_t">DebugKb_t</a>) (err <a href="/pkg/builtin/#error">error</a>)
}</pre>
			<p>
FEsolver implements the actual solver (time loop)
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="GeoLayer">type <a href="https://github.com/cpmech/gofem/blob/master/fem/geost.go?s=1151:1916#L29">GeoLayer</a></h2>
			<pre>type GeoLayer struct {
    Tags  []<a href="/pkg/builtin/#int">int</a>   <span class="comment">// tags of cells within this layer</span>
    Zmin  <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// coordinate (elevation) at bottom of layer</span>
    Zmax  <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// coordinate (elevation) at top of layer</span>
    Nodes []*<a href="#Node">Node</a> <span class="comment">// nodes in layer</span>
    Elems []<a href="#Elem">Elem</a>  <span class="comment">// elements in layer</span>
    Cl    <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// liquid compressibility</span>
    RhoS0 <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// initial density of solids</span>

    K0    <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// earth-pressure at rest</span>
    Dpl   <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// liquid pressure added by this layer</span>
    DsigV <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// absolute value of vertical stress increment added by this layer</span>

    Jac <a href="/pkg/github.com/cpmech/gosl/ode/">ode</a>.<a href="/pkg/github.com/cpmech/gosl/ode/#Cb_jac">Cb_jac</a> <span class="comment">// Jacobian for ode solver</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
GeoLayer holds information of one soil layer. It computes pressures (σVabs, pl) and
densities (ρL, ρ) based on the following model (fully liquid saturated)
</p>
<pre>ρL  = ρL0 + Cl・pl   thus   dρL/dpl = Cl
sl  = 1
ρ   = nf・sl・ρL + (1 - nf)・ρS
ns  = 1 - nf

Z(z) = zmax + T・(z - zmax)   with 0 ≤ T ≤ 1
dZ   = (z - zmax)・dT
dpl  = ρL(pl)・g・(-dZ)
dpl  = ρL(pl)・g・(zmax - z)・dT
dσV  = ρ(pl)・g・(zmax - z)・dT
Δz   = zmax - z

        / dpl/dT \   / ρL(pl)・g・Δz  \
dY/dT = | dρL/dT | = | Cl・dpl/dT     |
        | dρ/dT  |   | nf・sl・dρL/dT |
        \ dσV/dT /   \ ρ(pl)・g・Δz   /
</pre>


			

			

			
			
			

			

			
				
				<h3 id="GeoLayer.Calc">func (GeoLayer) <a href="https://github.com/cpmech/gofem/blob/master/fem/geost.go?s=2723:2775#L75">Calc</a></h3>
				<pre>func (o <a href="#GeoLayer">GeoLayer</a>) Calc(z <a href="/pkg/builtin/#float64">float64</a>) (*geostate, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Calc computes state @ level z
</p>

				
				
				
			
				
				<h3 id="GeoLayer.Start">func (*GeoLayer) <a href="https://github.com/cpmech/gofem/blob/master/fem/geost.go?s=2030:2081#L49">Start</a></h3>
				<pre>func (o *<a href="#GeoLayer">GeoLayer</a>) Start(prev *geostate, g <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Start starts ODE solver for computing state variables in Calc
</p>
<pre>prev -- previous state @ top of this layer
</pre>

				
				
				
			
		
			
			
			<h2 id="GeoLayers">type <a href="https://github.com/cpmech/gofem/blob/master/fem/geost.go?s=3099:3125#L87">GeoLayers</a></h2>
			<pre>type GeoLayers []*<a href="#GeoLayer">GeoLayer</a></pre>
			<p>
GeoLayers is a set of Layer
</p>


			

			

			
			
			

			

			
				
				<h3 id="GeoLayers.Len">func (GeoLayers) <a href="https://github.com/cpmech/gofem/blob/master/fem/geost.go?s=3155:3183#L90">Len</a></h3>
				<pre>func (o <a href="#GeoLayers">GeoLayers</a>) Len() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Len the length of Layers
</p>

				
				
				
			
				
				<h3 id="GeoLayers.Less">func (GeoLayers) <a href="https://github.com/cpmech/gofem/blob/master/fem/geost.go?s=3342:3380#L100">Less</a></h3>
				<pre>func (o <a href="#GeoLayers">GeoLayers</a>) Less(i, j <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Less compares Layers: sort from top to bottom
</p>

				
				
				
			
				
				<h3 id="GeoLayers.String">func (GeoLayers) <a href="https://github.com/cpmech/gofem/blob/master/fem/geost.go?s=8378:8412#L299">String</a></h3>
				<pre>func (o <a href="#GeoLayers">GeoLayers</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
String prints a json formatted string with GeoLayers&#39; content
</p>

				
				
				
			
				
				<h3 id="GeoLayers.Swap">func (GeoLayers) <a href="https://github.com/cpmech/gofem/blob/master/fem/geost.go?s=3229:3262#L95">Swap</a></h3>
				<pre>func (o <a href="#GeoLayers">GeoLayers</a>) Swap(i, j <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Swap swaps two Layers
</p>

				
				
				
			
		
			
			
			<h2 id="HydroStatic">type <a href="https://github.com/cpmech/gofem/blob/master/fem/hydrost.go?s=821:967#L20">HydroStatic</a></h2>
			<pre>type HydroStatic struct {
    Cl <a href="/pkg/builtin/#float64">float64</a>

    Jac <a href="/pkg/github.com/cpmech/gosl/ode/">ode</a>.<a href="/pkg/github.com/cpmech/gosl/ode/#Cb_jac">Cb_jac</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
HydroStatic computes water pressure (pl) and intrinsic liquid density (ρL)
based on the following model
</p>
<pre>ρL = ρL0 + Cl・pl   thus   dρL/dpl = Cl

Z(z) = zmax + T・(z - zmax)   with 0 ≤ T ≤ 1
dZ   = (z - zmax)・dT
dpl  = ρL(pl)・g・(-dZ)
dpl  = ρL(pl)・g・(zmax - z)・dT
Δz   = zmax - z

        / dpl/dT \   / ρL(pl)・g・Δz \
dY/dT = |        | = |               |
        \ dρL/dT /   \ Cl・dpl/dT    /
</pre>


			

			

			
			
			

			

			
				
				<h3 id="HydroStatic.Calc">func (HydroStatic) <a href="https://github.com/cpmech/gofem/blob/master/fem/hydrost.go?s=1922:1987#L68">Calc</a></h3>
				<pre>func (o <a href="#HydroStatic">HydroStatic</a>) Calc(z <a href="/pkg/builtin/#float64">float64</a>) (pl, ρL <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Calc computes pressure and density
</p>

				
				
				
			
				
				<h3 id="HydroStatic.Init">func (*HydroStatic) <a href="https://github.com/cpmech/gofem/blob/master/fem/hydrost.go?s=1004:1075#L31">Init</a></h3>
				<pre>func (o *<a href="#HydroStatic">HydroStatic</a>) Init(waterLevel, waterRho0, waterBulk, g <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Init initialises this structure
</p>

				
				
				
			
		
			
			
			<h2 id="Info">type <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=2895:3343#L54">Info</a></h2>
			<pre>type Info struct {

    <span class="comment">// essential</span>
    Dofs [][]<a href="/pkg/builtin/#string">string</a>        <span class="comment">// solution variables PER NODE. ex for 2 nodes: [[&#34;ux&#34;, &#34;uy&#34;, &#34;rz&#34;], [&#34;ux&#34;, &#34;uy&#34;, &#34;rz&#34;]]</span>
    Y2F  map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#string">string</a> <span class="comment">// maps &#34;y&#34; keys to &#34;f&#34; keys. ex: &#34;ux&#34; =&gt; &#34;fx&#34;, &#34;pl&#34; =&gt; &#34;ql&#34;</span>

    <span class="comment">// internal Dofs; e.g. for mixed formulations</span>
    NintDofs <a href="/pkg/builtin/#int">int</a> <span class="comment">// number of internal dofs</span>

    <span class="comment">// t1 and t2 variables (time-derivatives of first and second order)</span>
    T1vars []<a href="/pkg/builtin/#string">string</a> <span class="comment">// &#34;pl&#34;</span>
    T2vars []<a href="/pkg/builtin/#string">string</a> <span class="comment">// &#34;ux&#34;, &#34;uy&#34;</span>
}</pre>
			<p>
Info holds all information required to set a simulation stage
</p>


			

			

			
			
			

			
				
				<h3 id="GetElemInfo">func <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=3461:3570#L71">GetElemInfo</a></h3>
				<pre>func GetElemInfo(cell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>, reg *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Region">Region</a>, sim *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Simulation">Simulation</a>) (info *<a href="#Info">Info</a>, inactive <a href="/pkg/builtin/#bool">bool</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
GetElemInfo returns information about elements/formulations
</p>
<pre>cellType -- e.g. &#34;qua8&#34;
elemType -- e.g. &#34;u&#34;
</pre>

				
				
			

			
		
			
			
			<h2 id="NaturalBc">type <a href="https://github.com/cpmech/gofem/blob/master/fem/naturalbcs.go?s=348:559#L1">NaturalBc</a></h2>
			<pre>type NaturalBc struct {
    Key     <a href="/pkg/builtin/#string">string</a>   <span class="comment">// key such as qn, qn0, ql, seepH, seepP, etc...</span>
    IdxFace <a href="/pkg/builtin/#int">int</a>      <span class="comment">// local index of face</span>
    Fcn     <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// function callback</span>
    Extra   <a href="/pkg/builtin/#string">string</a>   <span class="comment">// extra information</span>
}</pre>
			<p>
NaturalBc holds information on natural boundary conditioins such as
distributed loads or fluxes acting on surfaces
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Node">type <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=630:747#L16">Node</a></h2>
			<pre>type Node struct {
    Dofs []*<a href="#Dof">Dof</a>    <span class="comment">// degrees-of-freedom == solution variables</span>
    Vert *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Vert">Vert</a> <span class="comment">// pointer to Vertex</span>
}</pre>
			<p>
Node holds node dofs information
</p>


			

			

			
			
			

			
				
				<h3 id="NewNode">func <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=781:812#L22">NewNode</a></h3>
				<pre>func NewNode(v *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Vert">Vert</a>) *<a href="#Node">Node</a></pre>
				<p>
NewNode allocates a new Node
</p>

				
				
			

			
				
				<h3 id="Node.AddDofAndEq">func (*Node) <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=1241:1304#L40">AddDofAndEq</a></h3>
				<pre>func (o *<a href="#Node">Node</a>) AddDofAndEq(ukey <a href="/pkg/builtin/#string">string</a>, eqnum <a href="/pkg/builtin/#int">int</a>) (nexteq <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
AddDof adds a new dof to thisnode; ignores it if it exists already
</p>
<pre>nexteq -- is the next equation number == eqnum + 1;
          returns eqnum if dof exists already
</pre>

				
				
				
			
				
				<h3 id="Node.GetDof">func (*Node) <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=1755:1794#L61">GetDof</a></h3>
				<pre>func (o *<a href="#Node">Node</a>) GetDof(ukey <a href="/pkg/builtin/#string">string</a>) *<a href="#Dof">Dof</a></pre>
				<p>
GetDof returns the Dof structure for given Dof name (ukey)
</p>
<pre>Note: returns nil if not found
</pre>

				
				
				
			
				
				<h3 id="Node.GetEq">func (*Node) <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=1983:2031#L72">GetEq</a></h3>
				<pre>func (o *<a href="#Node">Node</a>) GetEq(ukey <a href="/pkg/builtin/#string">string</a>) (eqNumber <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
GetEq returns the equation number for given Dof name (ukey)
</p>
<pre>Note: returns -1 if not found
</pre>

				
				
				
			
				
				<h3 id="Node.GetKeys">func (*Node) <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=2174:2207#L82">GetKeys</a></h3>
				<pre>func (o *<a href="#Node">Node</a>) GetKeys() []<a href="/pkg/builtin/#string">string</a></pre>
				<p>
GetKeys returns a slice of keys from all dofs
</p>

				
				
				
			
				
				<h3 id="Node.SetEq">func (*Node) <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=1593:1640#L55">SetEq</a></h3>
				<pre>func (o *<a href="#Node">Node</a>) SetEq(ukey <a href="/pkg/builtin/#string">string</a>, eqNumber <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
SetEq numbers a specific Dof with the equation number in the current (stage) global system
</p>

				
				
				
			
				
				<h3 id="Node.String">func (*Node) <a href="https://github.com/cpmech/gofem/blob/master/fem/node.go?s=902:932#L27">String</a></h3>
				<pre>func (o *<a href="#Node">Node</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
String returns the string representation of this node
</p>

				
				
				
			
		
			
			
			<h2 id="OutIpData">type <a href="https://github.com/cpmech/gofem/blob/master/fem/element.go?s=428:688#L6">OutIpData</a></h2>
			<pre>type OutIpData struct {
    Eid  <a href="/pkg/builtin/#int">int</a>                                    <span class="comment">// id of element that owns this ip</span>
    X    []<a href="/pkg/builtin/#float64">float64</a>                              <span class="comment">// coordinates</span>
    Calc func(sol *<a href="#Solution">Solution</a>) map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nkeys] function to calculate secondary values</span>
}</pre>
			<p>
OutIpData is an auxiliary structure to transfer data from integration points (IP) to output routines.
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="PtNaturalBc">type <a href="https://github.com/cpmech/gofem/blob/master/fem/ptnatbcs.go?s=380:581#L4">PtNaturalBc</a></h2>
			<pre>type PtNaturalBc struct {
    Key   <a href="/pkg/builtin/#string">string</a>    <span class="comment">// key such as fux, fpl, etc...</span>
    Eq    <a href="/pkg/builtin/#int">int</a>       <span class="comment">// equation</span>
    X     []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// location</span>
    Fcn   <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>  <span class="comment">// function</span>
    Extra <a href="/pkg/builtin/#string">string</a>    <span class="comment">// extra information</span>
}</pre>
			<p>
PtNaturalBc holds information on point natural boundary conditions such as
prescribed forces or fluxes) at nodes
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="PtNaturalBcs">type <a href="https://github.com/cpmech/gofem/blob/master/fem/ptnatbcs.go?s=627:792#L13">PtNaturalBcs</a></h2>
			<pre>type PtNaturalBcs struct {
    Eq2idx map[<a href="/pkg/builtin/#int">int</a>]<a href="/pkg/builtin/#int">int</a>    <span class="comment">// maps eq number to indices in Bcs</span>
    Bcs    []*<a href="#PtNaturalBc">PtNaturalBc</a> <span class="comment">//active boundary conditions such as prescribed forces</span>
}</pre>
			<p>
PointLoads is a set of prescribed forces
</p>


			

			

			
			
			

			

			
				
				<h3 id="PtNaturalBcs.AddToRhs">func (PtNaturalBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/ptnatbcs.go?s=1008:1063#L25">AddToRhs</a></h3>
				<pre>func (o <a href="#PtNaturalBcs">PtNaturalBcs</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, t <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
AddToRhs adds the boundary conditions terms to the augmented fb vector
</p>

				
				
				
			
				
				<h3 id="PtNaturalBcs.List">func (*PtNaturalBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/ptnatbcs.go?s=1703:1752#L51">List</a></h3>
				<pre>func (o *<a href="#PtNaturalBcs">PtNaturalBcs</a>) List(t <a href="/pkg/builtin/#float64">float64</a>) (l <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
List returns a simple list logging bcs at time t
</p>

				
				
				
			
				
				<h3 id="PtNaturalBcs.Reset">func (*PtNaturalBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/ptnatbcs.go?s=835:865#L19">Reset</a></h3>
				<pre>func (o *<a href="#PtNaturalBcs">PtNaturalBcs</a>) Reset()</pre>
				<p>
Reset initialises internal structures
</p>

				
				
				
			
				
				<h3 id="PtNaturalBcs.Set">func (*PtNaturalBcs) <a href="https://github.com/cpmech/gofem/blob/master/fem/ptnatbcs.go?s=1183:1275#L32">Set</a></h3>
				<pre>func (o *<a href="#PtNaturalBcs">PtNaturalBcs</a>) Set(key <a href="/pkg/builtin/#string">string</a>, nod *<a href="#Node">Node</a>, fcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (setisok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Set sets new point natural boundary condition data
</p>

				
				
				
			
		
			
			
			<h2 id="RichardsonExtrap">type <a href="https://github.com/cpmech/gofem/blob/master/fem/s_richardson.go?s=416:1119#L7">RichardsonExtrap</a></h2>
			<pre>type RichardsonExtrap struct {

    <span class="comment">// variables after big step</span>
    Y_big []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// primary variables</span>

    <span class="comment">// time loop</span>
    Δt    <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// time step</span>
    Δtcpy <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// copy of Δt for divergence control</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
RichardsonExtrap solves FEM problem implicitely and with Richardson&#39;s extrapolation
</p>


			

			

			
			
			

			

			
				
				<h3 id="RichardsonExtrap.Init">func (*RichardsonExtrap) <a href="https://github.com/cpmech/gofem/blob/master/fem/s_richardson.go?s=1366:1399#L47">Init</a></h3>
				<pre>func (o *<a href="#RichardsonExtrap">RichardsonExtrap</a>) Init()</pre>
				
				
				
				
			
				
				<h3 id="RichardsonExtrap.Run">func (*RichardsonExtrap) <a href="https://github.com/cpmech/gofem/blob/master/fem/s_richardson.go?s=1710:1821#L68">Run</a></h3>
				<pre>func (o *<a href="#RichardsonExtrap">RichardsonExtrap</a>) Run(tf <a href="/pkg/builtin/#float64">float64</a>, dtFunc, dtoFunc <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, verbose <a href="/pkg/builtin/#bool">bool</a>, dbgKb <a href="#DebugKb_t">DebugKb_t</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
				
			
		
			
			
			<h2 id="Rjoint">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=2365:4741#L44">Rjoint</a></h2>
			<pre>type Rjoint struct {

    <span class="comment">// basic data</span>
    Sim  *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Simulation">Simulation</a> <span class="comment">// simulation</span>
    Edat *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#ElemData">ElemData</a>   <span class="comment">// element data; stored in allocator to be used in Connect</span>
    Cell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>       <span class="comment">// the cell structure</span>
    Ny   <a href="/pkg/builtin/#int">int</a>             <span class="comment">// total number of dofs == rod.Nu + sld.Nu</span>
    Ndim <a href="/pkg/builtin/#int">int</a>             <span class="comment">// space dimension</span>

    <span class="comment">// essential</span>
    Rod *<a href="#Rod">Rod</a>            <span class="comment">// rod element</span>
    Sld *<a href="#ElemU">ElemU</a>          <span class="comment">// solid element</span>
    Mdl <a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#RjointM1">RjointM1</a> <span class="comment">// material model</span>

    <span class="comment">// shape functions evaluations and extrapolator matrices</span>
    Nmat [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [sldNn][rodNn] shape functions of solids @ [N]odes of rod element</span>
    Pmat [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [sldNn][rodNp] shape functions of solids @ integration [P]oints of rod element (for Coulomb model)</span>
    Emat [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [sldNn][sldNp] solid&#39;s extrapolation matrix (for Coulomb model)</span>

    <span class="comment">// variables for Coulomb model</span>
    Coulomb <a href="/pkg/builtin/#bool">bool</a> <span class="comment">// use Coulomb model</span>

    <span class="comment">// auxiliary variables</span>
    ΔuC [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [rodNn][ndim] relative displ. increment of solid @ nodes of rod; Eq (30)</span>
    Δw  []<a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// [ndim] relative velocity; Eq (32)</span>

    <span class="comment">// temporary Jacobian matrices. see Eq. (57)</span>
    Krr [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [rodNu][rodNu] Eq. (58)</span>
    Krs [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [rodNu][sldNu] Eq. (59)</span>
    Ksr [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [sldNu][rodNu] Eq. (60)</span>
    Kss [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [sldNu][sldNu] Eq. (61)</span>

    <span class="comment">// internal values</span>
    States    []*<a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#OnedState">OnedState</a> <span class="comment">// [nip] internal states</span>
    StatesBkp []*<a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#OnedState">OnedState</a> <span class="comment">// [nip] backup internal states</span>
    StatesAux []*<a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#OnedState">OnedState</a> <span class="comment">// [nip] backup internal states</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Rjoint implements the rod-joint (interface/link) element for reinforced solids.
</p>
<pre>The following convention is considered:
 n or N   -- means [N]odes
 p or P   -- means integratioin [P]oints
 nn or Nn -- number of nodes
 np or Np -- number of integration [P]points
 ndim     -- space dimension
 nsig     -- number of stress/strain components == 2 * ndim
 rod      -- means rod element
 rodH     -- rod shape structure
 rodNn    -- rod number of nodes
 rodNp    -- rod number of integration points
 rodS     -- rod shape functions
 sld      -- means solid element
 sldH     -- rod shape structure
 sldNn    -- solid number of nodes
 sldNp    -- solid number of integration points
 sldS     -- solid shape functions
 rodYn    -- rod&#39;s (real) coordinates of node
 rodYp    -- rod&#39;s (real) coordinates of integration point
 r or R   -- means natural coordinates in the solids&#39; system
 z or Z   -- means natural coordinates in the rod&#39;s system
 s or S   -- parametric coordinate along rod
 rodRn    -- natural coordinates or rod&#39;s nodes w.r.t solid&#39;s system
 rodRp    -- natural coordinates of rod&#39;s integration point w.r.t to solid&#39;s system
 Nmat     -- solid shape functions evaluated at rod nodes
 Pmat     -- solid shape functions evaluated at rod integration points
References:
 [1] Durand R, Farias MM, Pedroso DM. Modelling the strengthening of solids with
     incompatible line finite elements. Submitted.
 [2] Durand R, Farias MM, Pedroso DM. Computing intersections between non-compatible
     curves and finite elements. Computational Mechanics, 56(3):463-475; 2015
     <a href="http://dx.doi.org/10.1007/s00466-015-1181-y">http://dx.doi.org/10.1007/s00466-015-1181-y</a>
 [3] Durand R and Farias MM. A local extrapolation method for finite elements.
     Advances in Engineering Software, 67:1-9; 2014
     <a href="http://dx.doi.org/10.1016/j.advengsoft.2013.07.002">http://dx.doi.org/10.1016/j.advengsoft.2013.07.002</a>
</pre>


			

			

			
			
			

			

			
				
				<h3 id="Rjoint.AddToKb">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=11473:11554#L395">AddToKb</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="Rjoint.AddToRhs">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=10173:10239#L337">AddToRhs</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="Rjoint.BackupIvs">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=18040:18088#L679">BackupIvs</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) BackupIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
BackupIvs create copy of internal variables
</p>

				
				
				
			
				
				<h3 id="Rjoint.Connect">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=5380:5456#L124">Connect</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) Connect(cid2elem []<a href="#Elem">Elem</a>, c *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>) (nnzK <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Connect connects rod/solid elements in this Rjoint
</p>

				
				
				
			
				
				<h3 id="Rjoint.Decode">func (Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=18895:18942#L719">Decode</a></h3>
				<pre>func (o <a href="#Rjoint">Rjoint</a>) Decode(dec <a href="#Decoder">Decoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="Rjoint.Encode">func (Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=18776:18823#L714">Encode</a></h3>
				<pre>func (o <a href="#Rjoint">Rjoint</a>) Encode(enc <a href="#Encoder">Encoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="Rjoint.Id">func (Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=5279:5303#L121">Id</a></h3>
				<pre>func (o <a href="#Rjoint">Rjoint</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="Rjoint.InterpStarVars">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=10061:10119#L332">InterpStarVars</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
InterpStarVars interpolates star variables to integration points
</p>

				
				
				
			
				
				<h3 id="Rjoint.Ipoints">func (Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=17444:17490#L660">Ipoints</a></h3>
				<pre>func (o <a href="#Rjoint">Rjoint</a>) Ipoints() (coords [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Ipoints returns the real coordinates of integration points [nip][ndim]
</p>

				
				
				
			
				
				<h3 id="Rjoint.OutIpsData">func (Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=19099:19147#L728">OutIpsData</a></h3>
				<pre>func (o <a href="#Rjoint">Rjoint</a>) OutIpsData() (data []*<a href="#OutIpData">OutIpData</a>)</pre>
				<p>
OutIpsData returns data from all integration points for output
</p>

				
				
				
			
				
				<h3 id="Rjoint.RestoreIvs">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=18294:18343#L693">RestoreIvs</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) RestoreIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
RestoreIvs restore internal variables from copies
</p>

				
				
				
			
				
				<h3 id="Rjoint.SetEleConds">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=9901:9979#L327">SetEleConds</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEleConds set element conditions
</p>

				
				
				
			
				
				<h3 id="Rjoint.SetEqs">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=9780:9849#L322">SetEqs</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEqs set equations
</p>

				
				
				
			
				
				<h3 id="Rjoint.SetIniIvs">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=17586:17665#L665">SetIniIvs</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) SetIniIvs(sol *<a href="#Solution">Solution</a>, ivs map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetIniIvs sets initial ivs for given values in sol and ivs map
</p>

				
				
				
			
				
				<h3 id="Rjoint.Update">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=14757:14807#L541">Update</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) Update(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Update perform (tangent) update
</p>

				
				
				
			
				
				<h3 id="Rjoint.Ureset">func (*Rjoint) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rjoint.go?s=18572:18622#L707">Ureset</a></h3>
				<pre>func (o *<a href="#Rjoint">Rjoint</a>) Ureset(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Ureset fixes internal variables after u (displacements) have been zeroed
</p>

				
				
				
			
		
			
			
			<h2 id="Rod">type <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=454:1495#L8">Rod</a></h2>
			<pre>type Rod struct {

    <span class="comment">// basic data</span>
    Cell *<a href="/pkg/github.com/cpmech/gofem/inp/">inp</a>.<a href="/pkg/github.com/cpmech/gofem/inp/#Cell">Cell</a>   <span class="comment">// the cell structure</span>
    X    [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// matrix of nodal coordinates [ndim][nnode]</span>
    Shp  *<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Shape">Shape</a>  <span class="comment">// shape structure</span>
    Nu   <a href="/pkg/builtin/#int">int</a>         <span class="comment">// total number of unknowns == 2 * nsn</span>
    Ndim <a href="/pkg/builtin/#int">int</a>         <span class="comment">// space dimension</span>

    <span class="comment">// parameters</span>
    A <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// cross-sectional area</span>

    <span class="comment">// variables for dynamics</span>
    Rho  <a href="/pkg/builtin/#float64">float64</a>  <span class="comment">// density of solids</span>
    Gfcn <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a> <span class="comment">// gravity function</span>

    <span class="comment">// integration points</span>
    IpsElem []*<a href="/pkg/github.com/cpmech/gofem/shp/">shp</a>.<a href="/pkg/github.com/cpmech/gofem/shp/#Ipoint">Ipoint</a> <span class="comment">// integration points of element</span>

    <span class="comment">// vectors and matrices</span>
    K [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// element K matrix</span>
    M [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// element M matrix</span>

    <span class="comment">// problem variables</span>
    Umap []<a href="/pkg/builtin/#int">int</a> <span class="comment">// assembly map (location array/element equations)</span>

    <span class="comment">// material model and internal variables</span>
    Model     <a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#OnedSolid">OnedSolid</a>
    States    []*<a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#OnedState">OnedState</a>
    StatesBkp []*<a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#OnedState">OnedState</a>
    StatesAux []*<a href="/pkg/github.com/cpmech/gofem/msolid/">msolid</a>.<a href="/pkg/github.com/cpmech/gofem/msolid/#OnedState">OnedState</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Rod represents a structural rod element (for only axial loads)
</p>


			

			

			
			
			

			

			
				
				<h3 id="Rod.AddToKb">func (Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=5008:5085#L194">AddToKb</a></h3>
				<pre>func (o <a href="#Rod">Rod</a>) AddToKb(Kb *<a href="/pkg/github.com/cpmech/gosl/la/">la</a>.<a href="/pkg/github.com/cpmech/gosl/la/#Triplet">Triplet</a>, sol *<a href="#Solution">Solution</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AddToKb adds element K to global Jacobian matrix Kb
</p>

				
				
				
			
				
				<h3 id="Rod.AddToRhs">func (Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=4375:4437#L164">AddToRhs</a></h3>
				<pre>func (o <a href="#Rod">Rod</a>) AddToRhs(fb []<a href="/pkg/builtin/#float64">float64</a>, sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AddToRhs adds -R to global residual vector fb
</p>

				
				
				
			
				
				<h3 id="Rod.BackupIvs">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=7983:8028#L323">BackupIvs</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) BackupIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
BackupIvs create copy of internal variables
</p>

				
				
				
			
				
				<h3 id="Rod.Decode">func (Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=8826:8870#L363">Decode</a></h3>
				<pre>func (o <a href="#Rod">Rod</a>) Decode(dec <a href="#Decoder">Decoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Decode decodes internal variables
</p>

				
				
				
			
				
				<h3 id="Rod.Encode">func (Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=8710:8754#L358">Encode</a></h3>
				<pre>func (o <a href="#Rod">Rod</a>) Encode(enc <a href="#Encoder">Encoder</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Encode encodes internal variables
</p>

				
				
				
			
				
				<h3 id="Rod.Id">func (Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=3731:3752#L136">Id</a></h3>
				<pre>func (o <a href="#Rod">Rod</a>) Id() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Id returns the cell Id
</p>

				
				
				
			
				
				<h3 id="Rod.InterpStarVars">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=4097:4152#L151">InterpStarVars</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) InterpStarVars(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
InterpStarVars interpolates star variables to integration points
</p>

				
				
				
			
				
				<h3 id="Rod.Ipoints">func (Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=6912:6955#L283">Ipoints</a></h3>
				<pre>func (o <a href="#Rod">Rod</a>) Ipoints() (coords [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Ipoints returns the real coordinates of integration points [nip][ndim]
</p>

				
				
				
			
				
				<h3 id="Rod.OutIpsData">func (Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=9027:9072#L372">OutIpsData</a></h3>
				<pre>func (o <a href="#Rod">Rod</a>) OutIpsData() (data []*<a href="#OutIpData">OutIpData</a>)</pre>
				<p>
OutIpsData returns data from all integration points for output
</p>

				
				
				
			
				
				<h3 id="Rod.RestoreIvs">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=8234:8280#L337">RestoreIvs</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) RestoreIvs(aux <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
RestoreIvs restore internal variables from copies
</p>

				
				
				
			
				
				<h3 id="Rod.SetEleConds">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=4204:4279#L156">SetEleConds</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) SetEleConds(key <a href="/pkg/builtin/#string">string</a>, f <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, extra <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEleConds set element conditions
</p>

				
				
				
			
				
				<h3 id="Rod.SetEqs">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=3799:3865#L139">SetEqs</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) SetEqs(eqs [][]<a href="/pkg/builtin/#int">int</a>, mixedform_eqs []<a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetEqs set equations
</p>

				
				
				
			
				
				<h3 id="Rod.SetIniIvs">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=7162:7238#L292">SetIniIvs</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) SetIniIvs(sol *<a href="#Solution">Solution</a>, ivs map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetIniIvs sets initial ivs for given values in sol and ivs map
</p>

				
				
				
			
				
				<h3 id="Rod.SetIvs">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=7862:7922#L318">SetIvs</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) SetIvs(zvars map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetIvs set secondary variables; e.g. during initialisation via files
</p>

				
				
				
			
				
				<h3 id="Rod.Update">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=6085:6132#L245">Update</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) Update(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Update perform (tangent) update
</p>

				
				
				
			
				
				<h3 id="Rod.Ureset">func (*Rod) <a href="https://github.com/cpmech/gofem/blob/master/fem/e_rod.go?s=8509:8556#L351">Ureset</a></h3>
				<pre>func (o *<a href="#Rod">Rod</a>) Ureset(sol *<a href="#Solution">Solution</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Ureset fixes internal variables after u (displacements) have been zeroed
</p>

				
				
				
			
		
			
			
			<h2 id="Solution">type <a href="https://github.com/cpmech/gofem/blob/master/fem/domain.go?s=486:1249#L12">Solution</a></h2>
			<pre>type Solution struct {

    <span class="comment">// current state</span>
    T      <a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// current time</span>
    Y      []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// DOFs (solution variables); e.g. y = {u, p}</span>
    Dydt   []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// dy/dt</span>
    D2ydt2 []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// d²y/dt²</span>

    <span class="comment">// auxiliary</span>
    ΔY  []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// total increment (for nonlinear solver)</span>
    Psi []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// t1 star vars; e.g. ψ* = β1.p + β2.dpdt</span>
    Zet []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// t2 star vars; e.g. ζ* = α1.u + α2.v + α3.a</span>
    Chi []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// t2 star vars; e.g. χ* = α4.u + α5.v + α6.a</span>
    L   []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// Lagrange multipliers</span>

    <span class="comment">// problem definition and constants</span>
    Steady  <a href="/pkg/builtin/#bool">bool</a>      <span class="comment">// [from Sim] steady simulation</span>
    Axisym  <a href="/pkg/builtin/#bool">bool</a>      <span class="comment">// [from Sim] axisymmetric</span>
    Pstress <a href="/pkg/builtin/#bool">bool</a>      <span class="comment">// [from Sim] plane-stress</span>
    DynCfs  *<a href="#DynCoefs">DynCoefs</a> <span class="comment">// [from FEM] coefficients for dynamics/transient simulations</span>
}</pre>
			<p>
Solution holds the solution data @ nodes.
</p>
<pre>      / u \         / u \
      |   | =&gt; y =  |   |
yb =  | p |         \ p / (ny x 1)
      |   |
      \ λ / (nyb x 1)
</pre>


			

			

			
			
			

			

			
				
				<h3 id="Solution.Reset">func (*Solution) <a href="https://github.com/cpmech/gofem/blob/master/fem/domain.go?s=13875:13912#L466">Reset</a></h3>
				<pre>func (o *<a href="#Solution">Solution</a>) Reset(steady <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Reset clear values
</p>

				
				
				
			
		
			
			
			<h2 id="SolverImplicit">type <a href="https://github.com/cpmech/gofem/blob/master/fem/s_implicit.go?s=445:522#L6">SolverImplicit</a></h2>
			<pre>type SolverImplicit struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
SolverImplicit solves FEM problem using an implicit procedure (with Newthon-Raphson method)
</p>


			

			

			
			
			

			

			
				
				<h3 id="SolverImplicit.Run">func (*SolverImplicit) <a href="https://github.com/cpmech/gofem/blob/master/fem/s_implicit.go?s=751:860#L23">Run</a></h3>
				<pre>func (o *<a href="#SolverImplicit">SolverImplicit</a>) Run(tf <a href="/pkg/builtin/#float64">float64</a>, dtFunc, dtoFunc <a href="/pkg/github.com/cpmech/gosl/fun/">fun</a>.<a href="/pkg/github.com/cpmech/gosl/fun/#Func">Func</a>, verbose <a href="/pkg/builtin/#bool">bool</a>, dbgKb <a href="#DebugKb_t">DebugKb_t</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
				
			
		
			
			
			<h2 id="Summary">type <a href="https://github.com/cpmech/gofem/blob/master/fem/summary.go?s=353:722#L8">Summary</a></h2>
			<pre>type Summary struct {

    <span class="comment">// main data</span>
    Dirout   <a href="/pkg/builtin/#string">string</a>       <span class="comment">// directory where results are stored</span>
    Fnkey    <a href="/pkg/builtin/#string">string</a>       <span class="comment">// filename key of simulation</span>
    Nproc    <a href="/pkg/builtin/#int">int</a>          <span class="comment">// number of processors</span>
    OutTimes []<a href="/pkg/builtin/#float64">float64</a>    <span class="comment">// [nOutTimes] output times</span>
    Resids   <a href="/pkg/github.com/cpmech/gosl/utl/">utl</a>.<a href="/pkg/github.com/cpmech/gosl/utl/#DblSlist">DblSlist</a> <span class="comment">// residuals (if Stat is on; includes all stages)</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Summary records summary of outputs
</p>


			

			

			
			
			

			

			
				
				<h3 id="Summary.Read">func (*Summary) <a href="https://github.com/cpmech/gofem/blob/master/fem/summary.go?s=1726:1788#L67">Read</a></h3>
				<pre>func (o *<a href="#Summary">Summary</a>) Read(dir, fnkey, enctype <a href="/pkg/builtin/#string">string</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Read reads summary back
</p>

				
				
				
			
				
				<h3 id="Summary.Save">func (Summary) <a href="https://github.com/cpmech/gofem/blob/master/fem/summary.go?s=1181:1276#L39">Save</a></h3>
				<pre>func (o <a href="#Summary">Summary</a>) Save(dirout, fnkey, enctype <a href="/pkg/builtin/#string">string</a>, nproc, proc <a href="/pkg/builtin/#int">int</a>, verbose <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SaveSums saves summary to disc
</p>

				
				
				
			
				
				<h3 id="Summary.SaveDomains">func (*Summary) <a href="https://github.com/cpmech/gofem/blob/master/fem/summary.go?s=794:879#L22">SaveDomains</a></h3>
				<pre>func (o *<a href="#Summary">Summary</a>) SaveDomains(time <a href="/pkg/builtin/#float64">float64</a>, doms []*<a href="#Domain">Domain</a>, verbose <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SaveDomains save the results from all domains (nodes and elements)
</p>

				
				
				
			
		
			
			
			<h2 id="T_iteration">type <a href="https://github.com/cpmech/gofem/blob/master/fem/testing.go?s=439:576#L10">T_iteration</a></h2>
			<pre>type T_iteration struct {
    It     <a href="/pkg/builtin/#int">int</a>     <span class="comment">// iteration number</span>
    ResRel <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// relative residual</span>
    Resid  <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// absolute residual</span>
}</pre>
			<p>
T_iteration testing: iteration results
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="T_results">type <a href="https://github.com/cpmech/gofem/blob/master/fem/testing.go?s=608:1109#L17">T_results</a></h2>
			<pre>type T_results struct {
    Status     <a href="/pkg/builtin/#string">string</a>        <span class="comment">// status message</span>
    LoadFactor <a href="/pkg/builtin/#float64">float64</a>       <span class="comment">// load factor</span>
    Iterations []<a href="#T_iteration">T_iteration</a> <span class="comment">// iterations data</span>
    Kmats      [][][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nele][nu][nu] all stiffness matrices</span>
    Disp       [][]<a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// [nnod][ndim] displacements at nodes</span>
    DispMult   <a href="/pkg/builtin/#float64">float64</a>       <span class="comment">// displacements multiplier</span>
    Note       <a href="/pkg/builtin/#string">string</a>        <span class="comment">// note about number of integration points</span>
    Sigmas     [][][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// [nele][nip][nsig] all stresses @ all ips 2D:{sx, sy, sxy, sz}</span>
}</pre>
			<p>
T_results testing: results
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="T_results_set">type <a href="https://github.com/cpmech/gofem/blob/master/fem/testing.go?s=1159:1190#L29">T_results_set</a></h2>
			<pre>type T_results_set []*<a href="#T_results">T_results</a></pre>
			<p>
T_results_set is a set of comparison results
</p>


			

			

			
			
			

			

			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	
	<table class="dir">
	<tr>
	<th>Name</th>
	<th>&nbsp;&nbsp;&nbsp;&nbsp;</th>
	<th style="text-align: left; width: auto">Synopsis</th>
	</tr>
	
		<tr>
		<td><a href="..">..</a></td>
		</tr>
	
	
		
			<tr>
			<td class="name"><a href="cmp/">cmp</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto"></td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="data/">data</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto"></td>
			</tr>
		
	
	</table>

	

</div><!-- page -->
<div id="footer">
<br /><br />
<hr>
<pre class="copyright">
Copyright (c) 2015, Dorival Pedroso and Raul Durand
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of gofem nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

</pre><!-- copyright -->
</div><!-- footer -->
</body>
</html>
