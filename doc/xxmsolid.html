<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Gofem &ndash; package msolid</title>
<link type="text/css" rel="stylesheet" href="static/style.css">
<script type="text/javascript" src="static/godocs.js"></script>
<style type="text/css"></style>
</head>
<body>
<div id="page"><h1>Gofem &ndash; <b>msolid</b> &ndash; models for solids</h1>
<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script type='text/javascript'>
	document.ANALYSIS_DATA = ;
	document.CALLGRAPH = ;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/cpmech/gofem/msolid"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
package msolid implements models for solids based on continuum mechanics
</p>
<pre>*            |   Nonrate     |    Rate
*  ==========================|=================================
*            |               |
*            |  σ=f(ε)       | dσdt = f(σ,dεdt)
*    Small   |  CalcStressE  | σ_(n+1) = σ_(n) + Δt * f_(n+1)
*            |  D=dσ/dε|_any | StressUpdate
*            |  ContinuousD  | D = dσ/dε_(n+1)
*            |               | ConsistentD
*            |               |
*  --------------------------|---------------------------------
*            |               |
*    Large   | σ=f(F)        | dσdt = f(σ,F,dFdt)
*            | CalcStressF   | D = dσdF_(n+1)
*            | ContinuousD   |
*            |               |
</pre>
<p>
package msolid implements models for solids based on continuum mechanics
</p>

			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="#Calc_E_from_KG">func Calc_E_from_KG(K, G float64) float64</a></dd>
			
				
				<dd><a href="#Calc_E_from_Knu">func Calc_E_from_Knu(K, ν float64) float64</a></dd>
			
				
				<dd><a href="#Calc_E_from_lG">func Calc_E_from_lG(l, G float64) float64</a></dd>
			
				
				<dd><a href="#Calc_G_from_Enu">func Calc_G_from_Enu(E, ν float64) float64</a></dd>
			
				
				<dd><a href="#Calc_G_from_Knu">func Calc_G_from_Knu(K, ν float64) float64</a></dd>
			
				
				<dd><a href="#Calc_K_from_Enu">func Calc_K_from_Enu(E, ν float64) float64</a></dd>
			
				
				<dd><a href="#Calc_K_from_lG">func Calc_K_from_lG(l, G float64) float64</a></dd>
			
				
				<dd><a href="#Calc_l_from_Enu">func Calc_l_from_Enu(E, ν float64) float64</a></dd>
			
				
				<dd><a href="#Calc_l_from_KG">func Calc_l_from_KG(K, G float64) float64</a></dd>
			
				
				<dd><a href="#Calc_l_from_Knu">func Calc_l_from_Knu(K, ν float64) float64</a></dd>
			
				
				<dd><a href="#Calc_nu_from_KG">func Calc_nu_from_KG(K, G float64) float64</a></dd>
			
				
				<dd><a href="#Calc_nu_from_lG">func Calc_nu_from_lG(l, G float64) float64</a></dd>
			
				
				<dd><a href="#CalcΔεElast">func CalcΔεElast(Δε []float64, K, G float64, Δp, Δq float64, axsym bool) (Δεv, Δεd float64)</a></dd>
			
			
				
				<dd><a href="#Driver">type Driver</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Driver.Init">func (o *Driver) Init(simfnk, modelname string, ndim int, pstress bool, prms fun.Prms)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Driver.Run">func (o *Driver) Run(pth *Path) (err error)</a></dd>
				
			
				
				<dd><a href="#DruckerPrager">type DruckerPrager</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#DruckerPrager.CalcD">func (o *DruckerPrager) CalcD(D [][]float64, s *State, firstIt bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DruckerPrager.ContD">func (o *DruckerPrager) ContD(D [][]float64, s *State) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DruckerPrager.GetPrms">func (o *DruckerPrager) GetPrms() fun.Prms</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DruckerPrager.Init">func (o *DruckerPrager) Init(ndim int, pstress bool, prms fun.Prms)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DruckerPrager.InitIntVars">func (o *DruckerPrager) InitIntVars(s *State) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DruckerPrager.Update">func (o *DruckerPrager) Update(s *State, ε, Δε []float64) (err error)</a></dd>
				
			
				
				<dd><a href="#Info">type Info</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GetInfo">func GetInfo(ndim int, modelname string) *Info</a></dd>
				
				
			
				
				<dd><a href="#KGcalculator">type KGcalculator</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GetKgc">func GetKgc(name string, prms fun.Prms) KGcalculator</a></dd>
				
				
			
				
				<dd><a href="#Large">type Large</a></dd>
				
				
			
				
				<dd><a href="#LinElast">type LinElast</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LinElast.CalcD">func (o *LinElast) CalcD(D [][]float64, s *State, firstIt bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LinElast.ContD">func (o *LinElast) ContD(D [][]float64, s *State) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LinElast.GetPrms">func (o *LinElast) GetPrms() fun.Prms</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LinElast.Init">func (o *LinElast) Init(ndim int, pstress bool, prms fun.Prms)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LinElast.InitIntVars">func (o *LinElast) InitIntVars(s *State) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LinElast.Update">func (o *LinElast) Update(s *State, ε, Δε []float64) (err error)</a></dd>
				
			
				
				<dd><a href="#Ogden">type Ogden</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Ogden.CalcA">func (o *Ogden) CalcA(A [][][][]float64, s *State, firstIt bool) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Ogden.GetPrms">func (o *Ogden) GetPrms() fun.Prms</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Ogden.Init">func (o *Ogden) Init(ndim int, pstress bool, prms fun.Prms)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Ogden.InitIntVars">func (o *Ogden) InitIntVars(s *State) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Ogden.Update">func (o *Ogden) Update(s *State, F [][]float64) (err error)</a></dd>
				
			
				
				<dd><a href="#Path">type Path</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Path.ReadJson">func (o *Path) ReadJson(ndim int, fname string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Path.ReadTable">func (o *Path) ReadTable(ndim, nincs, niout int, fname string, n int, mσ, mε float64, stresspath bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Path.SetIsoCompS">func (o *Path) SetIsoCompS(ndim, nincs, niout int, P []float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Path.SetPQstrain">func (o *Path) SetPQstrain(ndim, nincs, niout int, K, G, p0 float64, DP, DQ []float64, noise float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Path.Size">func (o *Path) Size() int</a></dd>
				
			
				
				<dd><a href="#Small">type Small</a></dd>
				
				
			
				
				<dd><a href="#SmallElasticity">type SmallElasticity</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SmallElasticity.CalcD">func (o *SmallElasticity) CalcD(D [][]float64, s *State) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SmallElasticity.GetPrms">func (o *SmallElasticity) GetPrms() fun.Prms</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SmallElasticity.Init">func (o *SmallElasticity) Init(ndim int, pstress bool, prms fun.Prms)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SmallElasticity.Update">func (o *SmallElasticity) Update(s *State, ε []float64) (err error)</a></dd>
				
			
				
				<dd><a href="#SmallStrainUpdater">type SmallStrainUpdater</a></dd>
				
				
			
				
				<dd><a href="#Solid">type Solid</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GetModel">func GetModel(simfnk, matname, modelname string, getnew bool) Solid</a></dd>
				
				
			
				
				<dd><a href="#State">type State</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewState">func NewState(nsig, nalp, nphi int, large bool) *State</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#State.GetCopy">func (o *State) GetCopy() *State</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#State.Set">func (o *State) Set(large bool, other *State)</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/github.com/cpmech/gofem/msolid/dp.go">dp.go</a>
			
				<a href="/src/github.com/cpmech/gofem/msolid/driver.go">driver.go</a>
			
				<a href="/src/github.com/cpmech/gofem/msolid/elasticity.go">elasticity.go</a>
			
				<a href="/src/github.com/cpmech/gofem/msolid/linelast.go">linelast.go</a>
			
				<a href="/src/github.com/cpmech/gofem/msolid/ogden.go">ogden.go</a>
			
				<a href="/src/github.com/cpmech/gofem/msolid/path.go">path.go</a>
			
				<a href="/src/github.com/cpmech/gofem/msolid/solid.go">solid.go</a>
			
				<a href="/src/github.com/cpmech/gofem/msolid/state.go">state.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		<div id="pkg-callgraph" class="toggle" style="display: none">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
		</div> <!-- .expanded -->
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
			<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls&mdash;perhaps dynamically.
			</p>
			<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
			<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
			<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
			<!-- Zero means show all package entry points. -->
			<ul style="margin-left: 0.5in" id="callgraph-0" class="treeview"></ul>
		</div>
		</div> <!-- #pkg-callgraph -->

		
		
		
			
			
			<h2 id="Calc_E_from_KG">func <a href="/src/target/elasticity.go?s=4725:4766#L171">Calc_E_from_KG</a></h2>
			<pre>func Calc_E_from_KG(K, G <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Calc_E_from_KG returns E given K and G
</p>

			
			

		
			
			
			<h2 id="Calc_E_from_Knu">func <a href="/src/target/elasticity.go?s=5162:5205#L188">Calc_E_from_Knu</a></h2>
			<pre>func Calc_E_from_Knu(K, ν <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Calc_E_from_Knu returns E given K and ν
</p>

			
			

		
			
			
			<h2 id="Calc_E_from_lG">func <a href="/src/target/elasticity.go?s=4303:4344#L154">Calc_E_from_lG</a></h2>
			<pre>func Calc_E_from_lG(l, G <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Calc_E_from_lG returns E given l and G
</p>

			
			

		
			
			
			<h2 id="Calc_G_from_Enu">func <a href="/src/target/elasticity.go?s=3987:4030#L142">Calc_G_from_Enu</a></h2>
			<pre>func Calc_G_from_Enu(E, ν <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Calc_G_from_Enu returns G given E and ν. NOTE: G == μ
</p>

			
			

		
			
			
			<h2 id="Calc_G_from_Knu">func <a href="/src/target/elasticity.go?s=5288:5331#L193">Calc_G_from_Knu</a></h2>
			<pre>func Calc_G_from_Knu(K, ν <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Calc_G_from_Kν returns G given K and ν
</p>

			
			

		
			
			
			<h2 id="Calc_K_from_Enu">func <a href="/src/target/elasticity.go?s=4111:4154#L147">Calc_K_from_Enu</a></h2>
			<pre>func Calc_K_from_Enu(E, ν <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Calc_K_from_Enu returns K given E and ν
</p>

			
			

		
			
			
			<h2 id="Calc_K_from_lG">func <a href="/src/target/elasticity.go?s=4548:4589#L164">Calc_K_from_lG</a></h2>
			<pre>func Calc_K_from_lG(l, G <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Calc_K_from_lG returns K given l and G
</p>

			
			

		
			
			
			<h2 id="Calc_l_from_Enu">func <a href="/src/target/elasticity.go?s=3832:3875#L137">Calc_l_from_Enu</a></h2>
			<pre>func Calc_l_from_Enu(E, ν <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Calc_l_from_Enu returns l given E and ν
</p>

			
			

		
			
			
			<h2 id="Calc_l_from_KG">func <a href="/src/target/elasticity.go?s=4982:5023#L181">Calc_l_from_KG</a></h2>
			<pre>func Calc_l_from_KG(K, G <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Calc_l_from_KG returns l given K and G
</p>

			
			

		
			
			
			<h2 id="Calc_l_from_Knu">func <a href="/src/target/elasticity.go?s=5435:5478#L198">Calc_l_from_Knu</a></h2>
			<pre>func Calc_l_from_Knu(K, ν <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Calc_l_from_Kν returns l given K and ν
</p>

			
			

		
			
			
			<h2 id="Calc_nu_from_KG">func <a href="/src/target/elasticity.go?s=4850:4892#L176">Calc_nu_from_KG</a></h2>
			<pre>func Calc_nu_from_KG(K, G <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Calc_nu_from_KG returns ν given K and G
</p>

			
			

		
			
			
			<h2 id="Calc_nu_from_lG">func <a href="/src/target/elasticity.go?s=4432:4474#L159">Calc_nu_from_lG</a></h2>
			<pre>func Calc_nu_from_lG(l, G <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Calc_nu_from_lG returns ν given l and G
</p>

			
			

		
			
			
			<h2 id="CalcΔεElast">func <a href="/src/target/path.go?s=6192:6293#L254">CalcΔεElast</a></h2>
			<pre>func CalcΔεElast(Δε []<a href="/pkg/builtin/#float64">float64</a>, K, G <a href="/pkg/builtin/#float64">float64</a>, Δp, Δq <a href="/pkg/builtin/#float64">float64</a>, axsym <a href="/pkg/builtin/#bool">bool</a>) (Δεv, Δεd <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
CalcΔεElast calculates Δε corresponding to an elastic loading with Δp and Δq
</p>

			
			

		
		
			
			
			<h2 id="Driver">type <a href="/src/target/driver.go?s=384:1092#L5">Driver</a></h2>
			<pre>type Driver struct {

    <span class="comment">// settings</span>
    Silent  <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// do not show error messages</span>
    CheckD  <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// do check consistent matrix</span>
    UseDfwd <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// use DerivFwd (forward differences) instead of DerivCen (central differences) when checking D</span>
    TolD    <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// tolerance to check consistent matrix</span>
    VerD    <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// verbose check of D</span>
    WithPC  <a href="/pkg/builtin/#bool">bool</a>    <span class="comment">// with predictor-corrector data</span>

    <span class="comment">// results</span>
    Res []*<a href="#State">State</a>    <span class="comment">// stress/ivs results</span>
    Eps [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// strains</span>

    <span class="comment">// for checking consistent matrix</span>
    D [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// consistent matrix</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Driver run simulations with constitutive models for solids
</p>


			

			

			
			
			

			

			
				
				<h3 id="Driver.Init">func (*Driver) <a href="/src/target/driver.go?s=1121:1207#L31">Init</a></h3>
				<pre>func (o *<a href="#Driver">Driver</a>) Init(simfnk, modelname <a href="/pkg/builtin/#string">string</a>, ndim <a href="/pkg/builtin/#int">int</a>, pstress <a href="/pkg/builtin/#bool">bool</a>, prms <a href="/pkg/code.google.com/p/gosl/fun/">fun</a>.<a href="/pkg/code.google.com/p/gosl/fun/#Prms">Prms</a>)</pre>
				<p>
Init initialises driver
</p>

				
				
				
			
				
				<h3 id="Driver.Run">func (*Driver) <a href="/src/target/driver.go?s=1457:1500#L42">Run</a></h3>
				<pre>func (o *<a href="#Driver">Driver</a>) Run(pth *<a href="#Path">Path</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Run runs simulation
</p>

				
				
				
			
		
			
			
			<h2 id="DruckerPrager">type <a href="/src/target/dp.go?s=323:561#L3">DruckerPrager</a></h2>
			<pre>type DruckerPrager struct {
    <a href="#SmallElasticity">SmallElasticity</a>
    M  <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// slope of fc line</span>
    Mb <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// slope of fc line of plastic potential</span>

    H <a href="/pkg/builtin/#float64">float64</a> <span class="comment">// hardening variable</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
DruckerPrager implements Drucker-Prager plasticity model
</p>


			

			

			
			
			

			

			
				
				<h3 id="DruckerPrager.CalcD">func (*DruckerPrager) <a href="/src/target/dp.go?s=3118:3198#L131">CalcD</a></h3>
				<pre>func (o *<a href="#DruckerPrager">DruckerPrager</a>) CalcD(D [][]<a href="/pkg/builtin/#float64">float64</a>, s *<a href="#State">State</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
CalcD computes D = dσ_new/dε_new consistent with StressUpdate
</p>

				
				
				
			
				
				<h3 id="DruckerPrager.ContD">func (*DruckerPrager) <a href="/src/target/dp.go?s=4461:4527#L190">ContD</a></h3>
				<pre>func (o *<a href="#DruckerPrager">DruckerPrager</a>) ContD(D [][]<a href="/pkg/builtin/#float64">float64</a>, s *<a href="#State">State</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ContD computes D = dσ_new/dε_new continuous
</p>

				
				
				
			
				
				<h3 id="DruckerPrager.GetPrms">func (*DruckerPrager) <a href="/src/target/dp.go?s=1318:1360#L50">GetPrms</a></h3>
				<pre>func (o *<a href="#DruckerPrager">DruckerPrager</a>) GetPrms() <a href="/pkg/code.google.com/p/gosl/fun/">fun</a>.<a href="/pkg/code.google.com/p/gosl/fun/#Prms">Prms</a></pre>
				<p>
GetPrms gets (an example) of parameters
</p>

				
				
				
			
				
				<h3 id="DruckerPrager.Init">func (*DruckerPrager) <a href="/src/target/dp.go?s=906:973#L27">Init</a></h3>
				<pre>func (o *<a href="#DruckerPrager">DruckerPrager</a>) Init(ndim <a href="/pkg/builtin/#int">int</a>, pstress <a href="/pkg/builtin/#bool">bool</a>, prms <a href="/pkg/code.google.com/p/gosl/fun/">fun</a>.<a href="/pkg/code.google.com/p/gosl/fun/#Prms">Prms</a>)</pre>
				<p>
Init initialises model
</p>

				
				
				
			
				
				<h3 id="DruckerPrager.InitIntVars">func (*DruckerPrager) <a href="/src/target/dp.go?s=1556:1613#L60">InitIntVars</a></h3>
				<pre>func (o *<a href="#DruckerPrager">DruckerPrager</a>) InitIntVars(s *<a href="#State">State</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
InitIntVars initialises internal (secondary) variables
</p>

				
				
				
			
				
				<h3 id="DruckerPrager.Update">func (*DruckerPrager) <a href="/src/target/dp.go?s=1672:1744#L65">Update</a></h3>
				<pre>func (o *<a href="#DruckerPrager">DruckerPrager</a>) Update(s *<a href="#State">State</a>, ε, Δε []<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Update updates stresses for given strains
</p>

				
				
				
			
		
			
			
			<h2 id="Info">type <a href="/src/target/solid.go?s=1096:1436#L21">Info</a></h2>
			<pre>type Info struct {
    Nsig   <a href="/pkg/builtin/#int">int</a>      <span class="comment">// number of stress components == 2 * ndim</span>
    Nalp   <a href="/pkg/builtin/#int">int</a>      <span class="comment">// number of alpha variables</span>
    Nphi   <a href="/pkg/builtin/#int">int</a>      <span class="comment">// number of phi variables</span>
    Rate   <a href="/pkg/builtin/#bool">bool</a>     <span class="comment">// is rate-type model?</span>
    Large  <a href="/pkg/builtin/#bool">bool</a>     <span class="comment">// for large deformation</span>
    Alphas []<a href="/pkg/builtin/#string">string</a> <span class="comment">// names of alpha variables</span>
    Phis   []<a href="/pkg/builtin/#string">string</a> <span class="comment">// names of phi variables</span>
}</pre>
			<p>
Info holds information about a particular solid model
</p>


			

			

			
			
			

			
				
				<h3 id="GetInfo">func <a href="/src/target/solid.go?s=2792:2838#L57">GetInfo</a></h3>
				<pre>func GetInfo(ndim <a href="/pkg/builtin/#int">int</a>, modelname <a href="/pkg/builtin/#string">string</a>) *<a href="#Info">Info</a></pre>
				<p>
GetInfo returns (existent or new) information about a particular solid model
</p>

				
				
			

			
		
			
			
			<h2 id="KGcalculator">type <a href="/src/target/elasticity.go?s=393:476#L5">KGcalculator</a></h2>
			<pre>type KGcalculator interface {
    Init(prms <a href="/pkg/code.google.com/p/gosl/fun/">fun</a>.<a href="/pkg/code.google.com/p/gosl/fun/#Prms">Prms</a>)
    Calc(s *<a href="#State">State</a>) (K, G <a href="/pkg/builtin/#float64">float64</a>)
}</pre>
			<p>
KGcalculator defines calculators of elasticity coefficients K and G
</p>


			

			

			
			
			

			
				
				<h3 id="GetKgc">func <a href="/src/target/elasticity.go?s=598:650#L14">GetKgc</a></h3>
				<pre>func GetKgc(name <a href="/pkg/builtin/#string">string</a>, prms <a href="/pkg/code.google.com/p/gosl/fun/">fun</a>.<a href="/pkg/code.google.com/p/gosl/fun/#Prms">Prms</a>) <a href="#KGcalculator">KGcalculator</a></pre>
				<p>
GetKgc returns a KG calculator
</p>

				
				
			

			
		
			
			
			<h2 id="Large">type <a href="/src/target/solid.go?s=2213:2467#L46">Large</a></h2>
			<pre>type Large interface {
    Update(s *<a href="#State">State</a>, F, FΔ [][]<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#error">error</a>              <span class="comment">// updates stresses for new deformation F and FΔ</span>
    CalcA(A [][][][]<a href="/pkg/builtin/#float64">float64</a>, s *<a href="#State">State</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) <a href="/pkg/builtin/#error">error</a> <span class="comment">// computes tangent modulus A = (2/J) * ∂τ/∂b . b - σ palm I</span>
}</pre>
			<p>
Large defines rate type solid models for large deformation analyses
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="LinElast">type <a href="/src/target/linelast.go?s=274:315#L1">LinElast</a></h2>
			<pre>type LinElast struct {
    <a href="#SmallElasticity">SmallElasticity</a>
}</pre>
			<p>
LinElast implements a linear elastic model
</p>


			

			

			
			
			

			

			
				
				<h3 id="LinElast.CalcD">func (*LinElast) <a href="/src/target/linelast.go?s=1118:1193#L33">CalcD</a></h3>
				<pre>func (o *<a href="#LinElast">LinElast</a>) CalcD(D [][]<a href="/pkg/builtin/#float64">float64</a>, s *<a href="#State">State</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
CalcD computes D = dσ_new/dε_new consistent with StressUpdate
</p>

				
				
				
			
				
				<h3 id="LinElast.ContD">func (*LinElast) <a href="/src/target/linelast.go?s=1286:1347#L38">ContD</a></h3>
				<pre>func (o *<a href="#LinElast">LinElast</a>) ContD(D [][]<a href="/pkg/builtin/#float64">float64</a>, s *<a href="#State">State</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ContD computes D = dσ_new/dε_new continuous
</p>

				
				
				
			
				
				<h3 id="LinElast.GetPrms">func (*LinElast) <a href="/src/target/linelast.go?s=690:727#L18">GetPrms</a></h3>
				<pre>func (o *<a href="#LinElast">LinElast</a>) GetPrms() <a href="/pkg/code.google.com/p/gosl/fun/">fun</a>.<a href="/pkg/code.google.com/p/gosl/fun/#Prms">Prms</a></pre>
				<p>
GetPrms gets (an example) of parameters
</p>

				
				
				
			
				
				<h3 id="LinElast.Init">func (*LinElast) <a href="/src/target/linelast.go?s=534:596#L13">Init</a></h3>
				<pre>func (o *<a href="#LinElast">LinElast</a>) Init(ndim <a href="/pkg/builtin/#int">int</a>, pstress <a href="/pkg/builtin/#bool">bool</a>, prms <a href="/pkg/code.google.com/p/gosl/fun/">fun</a>.<a href="/pkg/code.google.com/p/gosl/fun/#Prms">Prms</a>)</pre>
				<p>
Init initialises model
</p>

				
				
				
			
				
				<h3 id="LinElast.InitIntVars">func (*LinElast) <a href="/src/target/linelast.go?s=827:879#L23">InitIntVars</a></h3>
				<pre>func (o *<a href="#LinElast">LinElast</a>) InitIntVars(s *<a href="#State">State</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
InitIntVars initialises internal (secondary) variables
</p>

				
				
				
			
				
				<h3 id="LinElast.Update">func (*LinElast) <a href="/src/target/linelast.go?s=938:1005#L28">Update</a></h3>
				<pre>func (o *<a href="#LinElast">LinElast</a>) Update(s *<a href="#State">State</a>, ε, Δε []<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Update updates stresses for given strains
</p>

				
				
				
			
		
			
			
			<h2 id="Ogden">type <a href="/src/target/ogden.go?s=345:777#L6">Ogden</a></h2>
			<pre>type Ogden struct {

    <span class="comment">// parameters</span>
    Alp []<a href="/pkg/builtin/#float64">float64</a>
    Mu  []<a href="/pkg/builtin/#float64">float64</a>
    K   <a href="/pkg/builtin/#float64">float64</a>

    <span class="comment">// auxiliary</span>
    Fi [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// inverse of F [3][3]</span>
    J  <a href="/pkg/builtin/#float64">float64</a>     <span class="comment">// det(F)</span>

    P [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// eigenprojectors of b [3][nsig]</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Ogden implements a linear elastic model
</p>


			

			

			
			
			

			

			
				
				<h3 id="Ogden.CalcA">func (*Ogden) <a href="/src/target/ogden.go?s=2574:2650#L101">CalcA</a></h3>
				<pre>func (o *<a href="#Ogden">Ogden</a>) CalcA(A [][][][]<a href="/pkg/builtin/#float64">float64</a>, s *<a href="#State">State</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
CalcA computes tangent modulus A = (2/J) * ∂τ/∂b . b - σ palm I
</p>

				
				
				
			
				
				<h3 id="Ogden.GetPrms">func (*Ogden) <a href="/src/target/ogden.go?s=1601:1635#L62">GetPrms</a></h3>
				<pre>func (o *<a href="#Ogden">Ogden</a>) GetPrms() <a href="/pkg/code.google.com/p/gosl/fun/">fun</a>.<a href="/pkg/code.google.com/p/gosl/fun/#Prms">Prms</a></pre>
				<p>
GetPrms gets (an example) of parameters
</p>

				
				
				
			
				
				<h3 id="Ogden.Init">func (*Ogden) <a href="/src/target/ogden.go?s=985:1044#L33">Init</a></h3>
				<pre>func (o *<a href="#Ogden">Ogden</a>) Init(ndim <a href="/pkg/builtin/#int">int</a>, pstress <a href="/pkg/builtin/#bool">bool</a>, prms <a href="/pkg/code.google.com/p/gosl/fun/">fun</a>.<a href="/pkg/code.google.com/p/gosl/fun/#Prms">Prms</a>)</pre>
				<p>
Init initialises model
</p>

				
				
				
			
				
				<h3 id="Ogden.InitIntVars">func (*Ogden) <a href="/src/target/ogden.go?s=1720:1769#L67">InitIntVars</a></h3>
				<pre>func (o *<a href="#Ogden">Ogden</a>) InitIntVars(s *<a href="#State">State</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
InitIntVars initialises internal (secondary) variables
</p>

				
				
				
			
				
				<h3 id="Ogden.Update">func (*Ogden) <a href="/src/target/ogden.go?s=1828:1887#L72">Update</a></h3>
				<pre>func (o *<a href="#Ogden">Ogden</a>) Update(s *<a href="#State">State</a>, F [][]<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Update updates stresses for given strains
</p>

				
				
				
			
		
			
			
			<h2 id="Path">type <a href="/src/target/path.go?s=349:1168#L6">Path</a></h2>
			<pre>type Path struct {

    <span class="comment">// from json</span>
    Sx    []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// σx stress components</span>
    Sy    []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// σy stress components</span>
    Sz    []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// σz components</span>
    Ex    []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// εx strain components</span>
    Ey    []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// εx strain components</span>
    Ez    []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// εz strain components</span>
    UseS  []<a href="/pkg/builtin/#int">int</a>     <span class="comment">// use stress component</span>
    UseE  []<a href="/pkg/builtin/#int">int</a>     <span class="comment">// use strain component</span>
    Nincs <a href="/pkg/builtin/#int">int</a>       <span class="comment">// number of increments</span>
    Niout <a href="/pkg/builtin/#int">int</a>       <span class="comment">// number of increments for output</span>
    MultS <a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// multiplier for stresses</span>
    MultE <a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// multiplier for strains</span>
    UseMS <a href="/pkg/builtin/#bool">bool</a>      <span class="comment">// use MultS</span>
    UseME <a href="/pkg/builtin/#bool">bool</a>      <span class="comment">// use MultE</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Path holds data for solid constitutive model simulations
</p>


			

			

			
			
			

			

			
				
				<h3 id="Path.ReadJson">func (*Path) <a href="/src/target/path.go?s=2587:2634#L79">ReadJson</a></h3>
				<pre>func (o *<a href="#Path">Path</a>) ReadJson(ndim <a href="/pkg/builtin/#int">int</a>, fname <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
ReadJson reads json file
</p>

				
				
				
			
				
				<h3 id="Path.ReadTable">func (*Path) <a href="/src/target/path.go?s=3005:3109#L99">ReadTable</a></h3>
				<pre>func (o *<a href="#Path">Path</a>) ReadTable(ndim, nincs, niout <a href="/pkg/builtin/#int">int</a>, fname <a href="/pkg/builtin/#string">string</a>, n <a href="/pkg/builtin/#int">int</a>, mσ, mε <a href="/pkg/builtin/#float64">float64</a>, stresspath <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
ReadTable loads path from datafile in table format
</p>
<pre>Note: n -- number of lines to read. use -1 to read all lines
</pre>

				
				
				
			
				
				<h3 id="Path.SetIsoCompS">func (*Path) <a href="/src/target/path.go?s=1327:1390#L35">SetIsoCompS</a></h3>
				<pre>func (o *<a href="#Path">Path</a>) SetIsoCompS(ndim, nincs, niout <a href="/pkg/builtin/#int">int</a>, P []<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
SetIsoCompS sets an isotropic compression path (stress driven)
</p>

				
				
				
			
				
				<h3 id="Path.SetPQstrain">func (*Path) <a href="/src/target/path.go?s=1801:1902#L52">SetPQstrain</a></h3>
				<pre>func (o *<a href="#Path">Path</a>) SetPQstrain(ndim, nincs, niout <a href="/pkg/builtin/#int">int</a>, K, G, p0 <a href="/pkg/builtin/#float64">float64</a>, DP, DQ []<a href="/pkg/builtin/#float64">float64</a>, noise <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
SetPQstrain sets a p-q path with w=1 (compression); but given in terms of strains
</p>

				
				
				
			
				
				<h3 id="Path.Size">func (*Path) <a href="/src/target/path.go?s=1216:1241#L32">Size</a></h3>
				<pre>func (o *<a href="#Path">Path</a>) Size() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Size returns the number of path components
</p>

				
				
				
			
		
			
			
			<h2 id="Small">type <a href="/src/target/solid.go?s=1815:2140#L39">Small</a></h2>
			<pre>type Small interface {
    Update(s *<a href="#State">State</a>, ε, Δε []<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#error">error</a>            <span class="comment">// updates stresses for given strains</span>
    CalcD(D [][]<a href="/pkg/builtin/#float64">float64</a>, s *<a href="#State">State</a>, firstIt <a href="/pkg/builtin/#bool">bool</a>) <a href="/pkg/builtin/#error">error</a> <span class="comment">// computes D = dσ_new/dε_new consistent with StressUpdate</span>
    ContD(D [][]<a href="/pkg/builtin/#float64">float64</a>, s *<a href="#State">State</a>) <a href="/pkg/builtin/#error">error</a>               <span class="comment">// computes D = dσ_new/dε_new continuous</span>
}</pre>
			<p>
Small defines rate type solid models for small strain analyses
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="SmallElasticity">type <a href="/src/target/elasticity.go?s=887:1180#L25">SmallElasticity</a></h2>
			<pre>type SmallElasticity struct {
    E, Nu <a href="/pkg/builtin/#float64">float64</a>      <span class="comment">// Young modulus and Poisson coefficient</span>
    L, G  <a href="/pkg/builtin/#float64">float64</a>      <span class="comment">// Lame&#39;s coefficients. L == λ, G == μ</span>
    K     <a href="/pkg/builtin/#float64">float64</a>      <span class="comment">// Bulk modulus</span>
    Pse   <a href="/pkg/builtin/#bool">bool</a>         <span class="comment">// is plane-stress?</span>
    Kgc   <a href="#KGcalculator">KGcalculator</a> <span class="comment">// K and G calculator for non-linear models</span>
}</pre>
			<p>
SmallElasticity implements linear/non-linear elasticity for small strain analyses
</p>


			

			

			
			
			

			

			
				
				<h3 id="SmallElasticity.CalcD">func (*SmallElasticity) <a href="/src/target/elasticity.go?s=2971:3039#L103">CalcD</a></h3>
				<pre>func (o *<a href="#SmallElasticity">SmallElasticity</a>) CalcD(D [][]<a href="/pkg/builtin/#float64">float64</a>, s *<a href="#State">State</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
CalcD computes D = dσ_new/dε_new (consistent)
</p>

				
				
				
			
				
				<h3 id="SmallElasticity.GetPrms">func (*SmallElasticity) <a href="/src/target/elasticity.go?s=2360:2404#L77">GetPrms</a></h3>
				<pre>func (o *<a href="#SmallElasticity">SmallElasticity</a>) GetPrms() <a href="/pkg/code.google.com/p/gosl/fun/">fun</a>.<a href="/pkg/code.google.com/p/gosl/fun/#Prms">Prms</a></pre>
				<p>
GetPrms gets (an example) of parameters
</p>

				
				
				
			
				
				<h3 id="SmallElasticity.Init">func (*SmallElasticity) <a href="/src/target/elasticity.go?s=1217:1286#L34">Init</a></h3>
				<pre>func (o *<a href="#SmallElasticity">SmallElasticity</a>) Init(ndim <a href="/pkg/builtin/#int">int</a>, pstress <a href="/pkg/builtin/#bool">bool</a>, prms <a href="/pkg/code.google.com/p/gosl/fun/">fun</a>.<a href="/pkg/code.google.com/p/gosl/fun/#Prms">Prms</a>)</pre>
				<p>
Init initialises this structure
</p>

				
				
				
			
				
				<h3 id="SmallElasticity.Update">func (*SmallElasticity) <a href="/src/target/elasticity.go?s=2542:2610#L85">Update</a></h3>
				<pre>func (o *<a href="#SmallElasticity">SmallElasticity</a>) Update(s *<a href="#State">State</a>, ε []<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Update computes new stresses for new strains ε
</p>

				
				
				
			
		
			
			
			<h2 id="SmallStrainUpdater">type <a href="/src/target/solid.go?s=2561:2710#L52">SmallStrainUpdater</a></h2>
			<pre>type SmallStrainUpdater interface {
    StrainUpdate(s *<a href="#State">State</a>, Δσ []<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#error">error</a> <span class="comment">// updates strains for given stresses (small strains formulation)</span>
}</pre>
			<p>
SmallStrainUpdater define small-strain models that can update strains for given stresses
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Solid">type <a href="/src/target/solid.go?s=1486:1747#L32">Solid</a></h2>
			<pre>type Solid interface {
    Init(ndim <a href="/pkg/builtin/#int">int</a>, pstress <a href="/pkg/builtin/#bool">bool</a>, prms <a href="/pkg/code.google.com/p/gosl/fun/">fun</a>.<a href="/pkg/code.google.com/p/gosl/fun/#Prms">Prms</a>) <span class="comment">// initialises model</span>
    GetPrms() <a href="/pkg/code.google.com/p/gosl/fun/">fun</a>.<a href="/pkg/code.google.com/p/gosl/fun/#Prms">Prms</a>                          <span class="comment">// gets (an example) of parameters</span>
    InitIntVars(s *<a href="#State">State</a>) <a href="/pkg/builtin/#error">error</a>                 <span class="comment">// initialises internal (secondary) variables</span>
}</pre>
			<p>
Solid defines the interface for solid models
</p>


			

			

			
			
			

			
				
				<h3 id="GetModel">func <a href="/src/target/solid.go?s=3378:3445#L80">GetModel</a></h3>
				<pre>func GetModel(simfnk, matname, modelname <a href="/pkg/builtin/#string">string</a>, getnew <a href="/pkg/builtin/#bool">bool</a>) <a href="#Solid">Solid</a></pre>
				<p>
GetModel returns (existent or new) solid model
</p>
<pre>simfnk    -- unique simulation filename key
matname   -- name of material
modelname -- model name
getnew    -- force a new allocation; i.e. do not use any model found in database
</pre>

				
				
			

			
		
			
			
			<h2 id="State">type <a href="/src/target/state.go?s=416:679#L4">State</a></h2>
			<pre>type State struct {
    Sig []<a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// σ: Cauchy stress tensor (effective) [nsig]</span>
    Alp []<a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// α: internal variables of rate type [nalp]</span>
    Phi []<a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// φ: internal variables of non-rate type [nphi]</span>
    F   [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// deformation gradient [3][3]</span>
}</pre>
			<p>
State holds all continuum mechanics data, including for updating the state
</p>


			

			

			
			
			

			
				
				<h3 id="NewState">func <a href="/src/target/state.go?s=825:879#L13">NewState</a></h3>
				<pre>func NewState(nsig, nalp, nphi <a href="/pkg/builtin/#int">int</a>, large <a href="/pkg/builtin/#bool">bool</a>) *<a href="#State">State</a></pre>
				<p>
NewState allocates state structure for small or large deformation analyses
</p>
<pre>large  -- large deformation analyses; otherwise small strains
</pre>

				
				
			

			
				
				<h3 id="State.GetCopy">func (*State) <a href="/src/target/state.go?s=1560:1592#L40">GetCopy</a></h3>
				<pre>func (o *<a href="#State">State</a>) GetCopy() *<a href="#State">State</a></pre>
				<p>
GetCopy returns a copy of this state
</p>

				
				
				
			
				
				<h3 id="State.Set">func (*State) <a href="/src/target/state.go?s=1223:1268#L27">Set</a></h3>
				<pre>func (o *<a href="#State">State</a>) Set(large <a href="/pkg/builtin/#bool">bool</a>, other *<a href="#State">State</a>)</pre>
				<p>
Set copies states
</p>
<pre>Note: 1) this and other states must have been pre-allocated with the same sizes
      2) this method does not check for errors
</pre>

				
				
				
			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	
	<table class="dir">
	<tr>
	<th>Name</th>
	<th>&nbsp;&nbsp;&nbsp;&nbsp;</th>
	<th style="text-align: left; width: auto">Synopsis</th>
	</tr>
	
		<tr>
		<td><a href="..">..</a></td>
		</tr>
	
	
		
			<tr>
			<td class="name"><a href="data/">data</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto"></td>
			</tr>
		
	
	</table>

	

</div><!-- page -->
<div id="footer">
<br /><br />
<hr>
<pre class="copyright">
Copyright (c) 2015, Dorival Pedroso & Raul Durand
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of gofem nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

</pre><!-- copyright -->
</div><!-- footer -->
</body>
</html>
